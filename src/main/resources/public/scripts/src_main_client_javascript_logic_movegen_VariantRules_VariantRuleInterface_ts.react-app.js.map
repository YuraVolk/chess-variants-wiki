{"version":3,"file":"src_main_client_javascript_logic_movegen_VariantRules_VariantRuleInterface_ts.react-app.js","mappings":";;;;;;;;;;;;;;;;;;;AAAO;AACA,kDAAkD,QAAQ;AAC1D,8DAA8D,QAAQ;AACtE;AACA;AACP;AACA;AACA;AACO;AACP;AACA;;;;;;;;;;;;;;;;;;ACVuD;AACa;AAC7D,8CAA8C,mEAAuB,OAAO,mEAAuB,YAAY,6EAAc,GAAG,6EAAc;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACF3E;AACZ;AACR;AACoD;AACjD;AACU;AACA;AACiE;AAC1D;AACc;AACL;AACF;AACb;AACgG;AACnG;AACb;AACpD,oGAA4B;AAC5B,oBAAoB,uDAAW,QAAQ,mEAAY;AACnD;AACA;AACA;AACA;AACA,0BAA0B,+EAA6B;AACvD;AACA,qBAAqB,kFAAgC;AACrD;AACA,eAAe,wEAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kEAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,8FAAyB;AAC7C;AACA;AACA;AACA,qBAAqB,kEAAc;AACnC;AACA,qBAAqB,8EAAgB;AACrC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB,EAAE;AACnB;AACA;AACA;AACA;AACA,4BAA4B,kFAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uEAAsB;AACrC;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,8DAAS;AACpC,6DAA6D;AAC7D,sDAAsD;AACtD,2CAA2C,+EAA6B;AACxE;AACA,uBAAuB,8FAAyB,eAAe,iFAAgB;AAC/E;AACA,4BAA4B,8FAAyB,oBAAoB,iFAAgB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uDAAW,QAAQ,mEAAY;AAC1D,2BAA2B,uDAAW,QAAQ,mEAAY;AAC1D;AACA;AACA;AACA;AACA,4BAA4B,6DAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC,4BAA4B,QAAQ;AACpC;AACA,wCAAwC,4FAA0B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,mEAAuB,WAAW,mEAAY;AACnF;AACA;AACA,oCAAoC,6DAAM;AAC1C;AACA;AACA;AACA,iCAAiC,oEAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kFAAqB,GAAG,sBAAsB;AAChE;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA,4CAA4C,MAAM,6FAAoC,EAAE;AACxF;AACA;AACA,4CAA4C,MAAM,wFAA+B,EAAE;AACnF;AACA;AACA;AACA;AACA,mCAAmC,+EAA6B;AAChE,wBAAwB,QAAQ;AAChC,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,4FAA0B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,eAAe;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,kBAAkB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA,6CAA6C,oEAAkB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,qEAAmB;AAC/E;AACA;AACA,0EAA0E,2FAAmB,aAAa,0FAAsB;AAChI,0EAA0E,2FAAmB,aAAa,yFAAqB;AAC/H;AACA,uBAAuB;AACvB;AACA,gBAAgB,yEAAyE;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iCAAiC,OAAO,mFAAe,oCAAoC;AAC3F,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kCAAkC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,oEAAkB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,oEAAkB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,4FAA0B;AAC7D;AACA;AACA;AACA,iFAAiF,qEAAmB;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qFAA4B;AACjE,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qCAAqC,sFAA6B;AAClE,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oEAAkB;AAClD;AACA;AACA;AACA;AACA,qDAAqD,8EAAqB;AAC1E;AACA,qCAAqC;AACrC;AACA;AACA,+CAA+C,mFAAe;AAC9D;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F,2FAAmB;AAC7G;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,8FAAqC;AACnE;AACA,yBAAyB,MAAM,qFAA4B,EAAE;AAC7D;AACA;AACA;AACA;AACA,8BAA8B,uFAA8B;AAC5D;AACA;AACA,8BAA8B,qFAA4B,EAAE,sFAA6B;AACzF;AACA,2CAA2C,MAAM;AACjD;AACA;AACyC;;;;;;;;;;;;;;;;;;;;;;;;;AChhBqC;AAChB;AACU;AACI;AAC5E;AACO,+CAA+C,cAAc,GAAG,cAAc;AAC9E;AACP;AACA,QAAQ,2DAAe;AACvB;AACA;AACA;AACA,8DAA8D,WAAW;AACzE;AACO;AACP,UAAU,sEAAe;AACzB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,mBAAmB,mEAAuB,wBAAwB,mEAAY;AAC9E;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,6BAA6B,sEAAe,kBAAkB,uEAAgB;AAC9E,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,wFAAkB;AACjC;AACA,CAAC;AACM;AACP;AACA;AACA,CAAC;AACM;AACP;AACA,uBAAuB,uEAAsB;AAC7C,uBAAuB,uEAAsB;AAC7C;AACA;AACA;AACA,yBAAyB,uEAAsB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACO;;;;;;;;;;;;;;;;;;ACtE2F;AACxB;AACnE;AACP;AACA;AACA,QAAQ,sEAAkB;AAC1B;AACA;AACA,aAAa,sEAAkB;AAC/B;AACA;AACA,aAAa,sEAAkB;AAC/B;AACA;AACA;AACA,kEAAkE,qBAAqB;AACvF;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,yEAAY;AACjE;AACA;AACA,YAAY,sEAAkB,+BAA+B,8EAAqB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjCoG;AACjB;AACf;AACoB;AACuD;AACX;AAClC;AACG;AACxC;AACe;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kFAAgB,EAAE,kFAAgB,EAAE,kFAAgB,EAAE,kFAAgB;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mEAAuB,kBAAkB,mEAAY;AAChE;AACA;AACA;AACA,oBAAoB,mEAAuB,kBAAkB,mEAAY;AACzE,2BAA2B,mEAAuB,UAAU,qFAAqF,GAAG,mEAAY;AAChK,4BAA4B,mEAAuB,UAAU,qFAAqF,GAAG,mEAAY;AACjK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uDAAW,OAAO,mEAAY;AAC3D;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,gDAAgD;AAChD,oDAAoD;AACpD,qDAAqD;AACrD,6CAA6C;AAC7C,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,sBAAsB;AACtB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAA8E;AAC9F;AACA;AACA;AACA;AACA,2CAA2C,oFAAgB;AAC3D;AACA,iBAAiB,yEAAkB;AACnC,mBAAmB,yEAAkB;AACrC,iEAAiE,oFAAgB;AACjF;AACA;AACA;AACA;AACA;AACA,qBAAqB,qFAA4B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,oHAAoH,oFAAgB;AACpI;AACA;AACA;AACA,oHAAoH,oFAAgB;AACpI;AACA;AACA;AACA,qBAAqB,sFAA6B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,qHAAqH,oFAAgB;AACrI;AACA;AACA;AACA,qHAAqH,oFAAgB;AACrI;AACA;AACA;AACA;AACA,wDAAwD,oEAAW;AACnE,wEAAwE,aAAa;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,6DAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iFAAsB;AACjD;AACA,iBAAiB,qFAA4B;AAC7C,mCAAmC,YAAY;AAC/C;AACA,iBAAiB,sFAA6B;AAC9C,mCAAmC,YAAY;AAC/C;AACA,iBAAiB,uFAA8B;AAC/C,mCAAmC,YAAY;AAC/C;AACA;AACA,gBAAgB,wDAAY;AAC5B;AACA;AACA;AACA,2BAA2B,uDAAW,QAAQ,mEAAY;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,iBAAiB,wFAA+B;AAChD;AACA;AACA;AACA,iBAAiB,qFAA4B;AAC7C,iBAAiB,sFAA6B;AAC9C;AACA;AACA;AACA;AACA,iBAAiB,uFAA8B;AAC/C;AACA,uDAAuD,GAAG,iFAA8B,6CAA6C;AACrI;AACA,+DAA+D,mEAAY;AAC3E;AACA;AACA;AACA,gDAAgD,mEAAY;AAC5D;AACA,wBAAwB,wFAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,8FAAqC;AACtD;AACA;AACA,iBAAiB,mFAA0B;AAC3C;AACA,iBAAiB,6FAAoC;AACrD,+CAA+C,wBAAwB;AACvE;AACA;AACA;AACA;AACA;AACA,gBAAgB,wDAAY;AAC5B;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,0FAAsB;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,iFAA8B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,yEAAkB;AACrE;AACA;AACA,uCAAuC,+GAA0B;AACjE;AACA;AACA,gBAAgB,2FAAmB,CAAC,kFAAc;AAClD;AACA;AACA;AACA,6BAA6B,uDAAW,QAAQ,mEAAY;AAC5D,4BAA4B,6DAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uDAAW,QAAQ,mEAAY;AAC5D,4BAA4B,6DAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iFAA8B;AACjE;AACA;AACA;AACA,YAAY,sEAAkB;AAC9B;AACA;AACA,iBAAiB,sEAAkB;AACnC;AACA;AACA,iBAAiB,sEAAkB;AACnC;AACA;AACA,gBAAgB,iCAAiC;AACjD,wBAAwB,uDAAW,QAAQ,mEAAY,WAAW,uDAAW,QAAQ,mEAAY,eAAe,uDAAW,QAAQ,mEAAY;AAC/I,UAAU;AACV;AACA,4BAA4B,IAAI,mEAAY,EAAE;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,uDAAW,IAAI,mEAAY;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,6DAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,6DAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF,mEAAY;AACrG;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,wBAAwB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,EAAE,EAAE,QAAQ;AACxE;AACA;AACA;AACA,6GAA6G,EAAE,EAAE,UAAU;AAC3H,2DAA2D,EAAE,EAAE,2DAA2D;AAC1H,oEAAoE,EAAE,EAAE,2DAA2D;AACnI;AACA;AACA;AACA;AACA;AACA,4BAA4B,6DAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,mEAAY;AACrD,UAAU;AACV,YAAY,wFAAkB;AAC9B;AACA;AACA;AACA,yDAAyD,WAAW;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,mEAAY;AACzD,UAAU;AACV,YAAY,wFAAkB;AAC9B;AACA;AACA;AACA,yDAAyD,WAAW;AACpE;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+GAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,yEAAkB;AAC/C;AACA;AACA;AACA;AACA,8CAA8C,+GAA0B;AACxE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,6DAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,6DAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,iFAAsB,4BAA4B;AAC7F;AACA;AACA;AACA,gBAAgB,mFAAwB;AACxC,mCAAmC,iCAAiC;AACpE;AACA,qBAAqB,mFAAwB;AAC7C,mCAAmC,iCAAiC;AACpE;AACA;AACA,gBAAgB,wDAAY;AAC5B;AACA;AACA;AACA,+BAA+B,kCAAkC,IAAI,wBAAwB;AAC7F;AACA;AACA;AAC+B;;;;;;;;;;;;;;;;;ACxtBxB;AACP;AACA,CAAC;AACM;AACP;AACA,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACL2D;AACH;AAClD;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,8CAA8C,2BAA2B,UAAU,0BAA0B;AAC7G;AACA;AACA,gCAAgC,kEAAc,gCAAgC;AAC9E;AACA;AACA,6BAA6B,kEAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,+BAA+B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,cAAc,wCAAwC,EAAE,+BAA+B;AACvF;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0EAAY;AAC/B;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0EAAY;AAC/B;AACA;AACO;AACP;AACA,CAAC;AACM;AACP;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AAC5B;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC3IA;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AChB4F;AACnC;AAClD;AACA;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,uDAAe;AACpF;AACA,eAAe;AACf,gBAAgB;AAChB,eAAe;AACf,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,QAAQ,0GAAiB;AACzB;AACA;AACA;AACA;AACO;AACP,wCAAwC,iDAAS;AACjD,8BAA8B,0GAAiB;AAC/C;AACA;AACA;AACA;AACA;AACA,aAAa,0GAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,iDAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnEyD;AACd;AACU;AACe;AACyB;AAC7C;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,oBAAoB,gCAAgC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,4EAA4B;AAC7E;AACA;AACA;AACA,sDAAsD,6EAA6B;AACnF;AACA;AACA;AACA,+CAA+C,kFAAuB;AACtE,gCAAgC,eAAe;AAC/C,iDAAiD,yFAAqB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iBAAiB,OAAO,yBAAyB,mBAAmB;AAC5G;AACA;AACA,6DAA6D,4EAAqB;AAClF;AACA;AACA;AACA;AACA,4DAA4D,gEAAa;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,uFAA4B;AACnF;AACA;AACA,uDAAuD,uFAA4B;AACnF;AACA;AACA,uDAAuD,kFAAuB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,kFAAuB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0EAAY;AAC5C;AACA;AACA;AACA,mDAAmD,wBAAwB;AAC3E;AACA;AACA;AACA;AACA;AACA,uDAAuD,iBAAiB;AACxE,sDAAsD,kFAAuB,sBAAsB;AACnG;AACA;AACA,uDAAuD,iBAAiB;AACxE,uDAAuD,kFAAuB,sBAAsB;AACpG;AACA;AACA,gCAAgC,0EAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0EAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACpP6D;AAC2B;AACA;AACjF;AACP;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AAC5B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sDAAsD;AAChD,oCAAoC;AACpC;AACP;AACA;AACA;AACO;AACP,QAAQ,6DAAkB;AAC1B,aAAa,6DAAkB;AAC/B;AACA,eAAe,yEAAkB;AACjC,eAAe,yEAAkB;AACjC;AACA;AACA;AACA;AACA,aAAa,6DAAkB;AAC/B,aAAa,6DAAkB;AAC/B;AACA,eAAe,yEAAkB;AACjC,eAAe,mGAA+B;AAC9C;AACA,aAAa,6DAAkB;AAC/B,aAAa,6DAAkB;AAC/B;AACA;AACA;AACA,+DAA+D,sBAAsB;AACrF;AACO;AACP;AACA,uCAAuC,mFAAe;AACtD;AACA;AACA;AACO,8DAA8D;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACnEgE;AACL;AACoB;AACf;AACS;AAClE;AACP;AACA,wBAAwB,yDAAc;AACtC;AACA;AACA;AACA;AACA,oBAAoB,mCAAmC;AACvD,mCAAmC,yEAAqB,GAAG,8BAA8B;AACzF;AACA,aAAa;AACb;AACA;AACA,wCAAwC,4EAAiB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6DAAkB;AACtC;AACA;AACA;AACA;AACA,mCAAmC,2FAAmB;AACtD,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,qEAAqB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,IAAI,mEAAY,EAAE;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC3E+E;AACL;AACnE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,sDAAsD;AAChG,gCAAgC,wFAAwF;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,kFAAkF;AAC7H;AACA;AACA;AACA,sDAAsD,sDAAsD;AAC5G,4BAA4B,wFAAwF;AACpH;AACA;AACA;AACA,gBAAgB,6CAA6C;AAC7D,0BAA0B,yFAAc,kBAAkB,yFAAc;AACxE;AACA;AACA,gDAAgD,kFAAc;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,kFAAkF;AAChK;AACA;AACA;AACA;AACA;AACA,8CAA8C,gCAAgC;AAC9E,oCAAoC,sBAAsB;AAC1D;AACA,aAAa;AACb;AACA;AACA;AACA,mEAAmE,iBAAiB;AACpF,gEAAgE,iBAAiB;AACjF;AACA;AACA;AACA,4DAA4D,uDAAuD;AACnH;AACA;AACA;AACA;AACA;AACA,yCAAyC,iCAAiC;AAC1E;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACzMiF;AACb;AACC;AACrE;AACA;AACA;AACA,2BAA2B,yBAAyB,uBAAuB;AAC3E,2BAA2B,yCAAyC;AACpE,kCAAkC,0CAA0C;AAC5E,sBAAsB,kCAAkC;AACxD,sBAAsB,kCAAkC;AACxD;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,0BAA0B;AAC1B,6BAA6B;AAC7B;AACA,4BAA4B,8EAA0B;AACtD;AACA;AACA;AACA;AACA,iCAAiC,6FAAyB,UAAU,gFAAgB;AACpF;AACA;AACA;AACA;AACA;AACyD;;;;;;;;;;;;;;;;;;ACjCX;AACmB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,gEAAgE;AAC1G,0CAA0C,+DAA+D;AACzG;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,0CAA0C,8DAA8D;AACxG,0CAA0C,6DAA6D;AACvG;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,0CAA0C,gEAAgE;AAC1G;AACA;AACA;AACA,0CAA0C,8DAA8D;AACxG;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,0CAA0C,8DAA8D;AACxG,0CAA0C,6DAA6D;AACvG;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,0CAA0C,6DAA6D;AACvG;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,0CAA0C,6DAA6D;AACvG,0CAA0C,8DAA8D;AACxG,0CAA0C,6DAA6D;AACvG;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA;AACA,0CAA0C,oFAAoF;AAC9H,0CAA0C,mFAAmF;AAC7H,0CAA0C,mFAAmF;AAC7H,0CAA0C,kFAAkF;AAC5H,0CAA0C,mFAAmF;AAC7H,0CAA0C,kFAAkF;AAC5H,0CAA0C,oFAAoF;AAC9H,0CAA0C,mFAAmF;AAC7H;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA;AACA,0CAA0C,oFAAoF;AAC9H,0CAA0C,mFAAmF;AAC7H,0CAA0C,mFAAmF;AAC7H,0CAA0C,kFAAkF;AAC5H,0CAA0C,mFAAmF;AAC7H,0CAA0C,kFAAkF;AAC5H,0CAA0C,oFAAoF;AAC9H,0CAA0C,mFAAmF;AAC7H,uDAAuD,6BAA6B,cAAc,IAAI;AACtG;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;ACniC+F;AAC/F,wCAAwC,yGAAiB;AAClD;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,CAAC,KAAK;AACC;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC7BO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AAC1B;;;;;;;;;;;;;;;;;;;ACbsC;AAC+B;AACnB;AACzD;AACO,2BAA2B,8DAAW;AAC7C;AACA,QAAQ,8EAA2B;AACnC;AACA,yBAAyB,OAAO,+CAAK;AACrC,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,gFAAgF,MAAM,mFAA0B,EAAE;AAClH;AACA;AACA;AACA;AACA,wCAAwC,sFAA4C;AACpF;AACA;AACA;;;;;;;;;;;;;;;;;;AC5B6C;AACY;AACzD;AACO,+BAA+B,8DAAW;AACjD;AACA,QAAQ,8EAA2B;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO,+CAAK;AACrC,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS,SAAS,MAAM,QAAQ,sCAAsC,SAAS,sBAAsB,QAAQ;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACpD6C;AACuB;AACQ;AACnB;AACzD;AACO,4BAA4B,8DAAW;AAC9C;AACA,QAAQ,8EAA2B;AACnC;AACA,yBAAyB,OAAO,+CAAK;AACrC,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,uEAA6B;AAC3C;AACA;AACA,yFAAyF,0EAAmB;AAC5G;AACA,6BAA6B,mBAAmB;AAChD;AACA;AACA;AACA;AACA,kDAAkD,MAAM,qFAA4B,EAAE;AACtF;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC1CmE;AACtB;AACsB;AACV;AACzD;AACO,wBAAwB,8DAAW;AAC1C;AACA,QAAQ,8EAA2B;AACnC;AACA,yBAAyB,OAAO,+CAAK;AACrC,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,mBAAmB,mEAAuB,WAAW,mEAAuB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE,qEAAc,GAAG,qEAAc;AAC9C;AACA;AACA;;;;;;;;;;;;;;;;;;AC1C6C;AACY;AACzD;AACO,6BAA6B,8DAAW;AAC/C;AACA,QAAQ,8EAA2B;AACnC;AACA,yBAAyB,OAAO,+CAAK;AACrC,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACxB6C;AACoC;AACxB;AACzD;AACO,uBAAuB,8DAAW;AACzC;AACA,QAAQ,8EAA2B;AACnC;AACA,6CAA6C,WAAW;AACxD,wBAAwB,WAAW;AACnC;AACA;AACA,wBAAwB,OAAO;AAC/B,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,IAAI;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO,+CAAK;AACrC,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,IAAI,qEAAc,iCAAiC;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,8BAA8B;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F,qEAAc;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,IAAI,mEAAY,EAAE;AAC1C;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACzM6C;AACsB;AACV;AAC4C;AAClC;AACnE;AACO,yBAAyB,8DAAW;AAC3C;AACA,QAAQ,8EAA2B;AACnC;AACA,6BAA6B,2EAAa;AAC1C,yBAAyB,OAAO,+CAAK;AACrC,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+GAA0B;AACjD;AACA;AACA;AACA;AACA,wBAAwB,IAAI,qEAAc,EAAE;AAC5C;AACA;AACA;AACA,4BAA4B,IAAI,qEAAc,EAAE;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,+BAA+B;AACzE;AACA;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACpE6C;AACY;AACP;AACiB;AACiC;AACjC;AACnE;AACO,wBAAwB,8DAAW;AAC1C;AACA,QAAQ,8EAA2B;AACnC;AACA,6BAA6B,2DAAc;AAC3C,yBAAyB,OAAO,+CAAK;AACrC,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,4EAAkC;AAChD,4BAA4B,yEAAqB;AACjD;AACA,wBAAwB,IAAI,qEAAc,EAAE;AAC5C,4BAA4B,IAAI,qEAAc,EAAE;AAChD;AACA,kEAAkE,0FAAsB;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,OAAO,mFAAe,+BAA+B;AACjG;AACA,wCAAwC,OAAO,mFAAe,0BAA0B;AACxF;AACA;AACA;AACA;AACA,4CAA4C,qDAAqD;AACjG;AACA,wCAAwC,gDAAgD;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACjEmE;AACC;AACvB;AACuB;AACD;AACV;AACP;AAClD;AACO,uBAAuB,8DAAW;AACzC;AACA,QAAQ,8EAA2B;AACnC;AACA,6BAA6B,2DAAc;AAC3C,yBAAyB,uEAAsB;AAC/C,yBAAyB,OAAO,+CAAK;AACrC,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iFAAuC;AACnD;AACA,kCAAkC,uEAAsB;AACxD;AACA;AACA,gFAAgF,0EAAmB;AACnG;AACA,6BAA6B,mBAAmB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,mBAAmB,mEAAuB,WAAW,mEAAuB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE,qEAAc,GAAG,qEAAc;AAC9C;AACA;AACA;;;;;;;;;;;;;;;;;;;ACrE6C;AACuB;AACX;AACzD;AACO,4BAA4B,8DAAW;AAC9C;AACA,QAAQ,8EAA2B;AACnC;AACA;AACA,yBAAyB,OAAO,+CAAK;AACrC,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iFAAuC;AACnD;AACA;AACA;AACA,gFAAgF,0EAAmB;AACnG;AACA,6BAA6B,mBAAmB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6EAAmC;AACtD;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AClD4D;AACf;AACoB;AACiB;AACzB;AACzD;AACO,wBAAwB,8DAAW;AAC1C;AACA,QAAQ,8EAA2B;AACnC;AACA,yBAAyB,OAAO,+CAAK;AACrC,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,wBAAwB,IAAI,mEAAY,EAAE;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACO,4BAA4B,8DAAW;AAC9C;AACA,QAAQ,8EAA2B;AACnC;AACA,yBAAyB,OAAO,+CAAK;AACrC,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,QAAQ,+DAAY;AACpB;AACA;AACA;AACA;AACO,0BAA0B,8DAAW;AAC5C;AACA,QAAQ,8EAA2B;AACnC;AACA,yBAAyB,OAAO,+CAAK;AACrC,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,YAAY,wFAAkB;AAC9B;AACA;AACA;AACA,YAAY,wFAAkB;AAC9B;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC/EoE;AACvB;AACY;AACzD;AACO,yBAAyB,8DAAW;AAC3C;AACA,QAAQ,8EAA2B;AACnC;AACA,yBAAyB,OAAO,+CAAK;AACrC,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uEAAsB;AACzC;AACA;AACA;;;;;;;;;;;;;;;;;;AC3B6C;AACY;AACzD;AACO,8BAA8B,8DAAW;AAChD;AACA,QAAQ,8EAA2B;AACnC;AACA,6CAA6C,YAAY;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,yBAAyB,OAAO,+CAAK;AACrC;AACA,8DAA8D,IAAI;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gBAAgB;AAClD;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACrGmE;AACtB;AACsB;AACV;AACzD;AACO,+BAA+B,8DAAW;AACjD;AACA,QAAQ,8EAA2B;AACnC;AACA,yBAAyB,OAAO,+CAAK;AACrC,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,mBAAmB,mEAAuB,WAAW,mEAAuB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE,qEAAc,GAAG,qEAAc;AAC9C;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC1C6C;AACuB;AACT;AACK;AACP;AACzD;AACO,4BAA4B,8DAAW;AAC9C;AACA,QAAQ,8EAA2B;AACnC;AACA;AACA,yBAAyB,OAAO,+CAAK;AACrC,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6CAA6C;AAC7D,4BAA4B,6DAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,cAAc,sCAAsC,eAAe;AACnF;AACA,YAAY,sEAAkB;AAC9B,6CAA6C,0EAAmB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,uEAA6B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0BAA0B,uCAAuC;AACjF;AACA,sCAAsC,0EAAmB;AACzD;AACA;AACA;AACA;AACA,cAAc,4EAAkC;AAChD;AACA;AACA,iCAAiC,yCAAyC;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC7E6C;AAC2C;AAC/B;AACzD;AACO,wBAAwB,8DAAW;AAC1C;AACA,QAAQ,8EAA2B;AACnC;AACA,yBAAyB,OAAO,+CAAK;AACrC,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,+EAAqC;AACnD;AACA;AACA;AACA;AACA,oBAAoB,yEAAkB;AACtC,wCAAwC,0EAAmB;AAC3D;AACA;AACA;AACA;AACA,wBAAwB,yEAAkB;AAC1C,4CAA4C,0EAAmB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC/CqG;AAClC;AACtB;AAC8B;AACX;AACY;AACnB;AACzD;AACO,yBAAyB,8DAAW;AAC3C;AACA,QAAQ,8EAA2B;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO,+CAAK;AACrC,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA,2BAA2B,iBAAiB,0BAA0B,kBAAkB;AACxF;AACA;AACA;AACA,gBAAgB,oDAAoD;AACpE;AACA;AACA;AACA;AACA;AACA,4BAA4B,6DAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mEAAuB,cAAc,qEAAc;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4EAAkC;AACrD;AACA;AACA;AACA,eAAe,+GAA0B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,mCAAmC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+EAAqC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uEAA6B;AACnD;AACA,wFAAwF,sEAAkB;AAC1G;AACA,+BAA+B,+GAA0B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,6DAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uEAA6B,oBAAoB,MAAM,mFAA0B,EAAE;AAC/F;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACjL6C;AACc;AACF;AACzD;AACO,oBAAoB,8DAAW;AACtC;AACA,QAAQ,8EAA2B;AACnC;AACA,yBAAyB,OAAO,+CAAK;AACrC,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,6DAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACxCoG;AACoB;AACpC;AACH;AACX;AACsB;AACc;AACxB;AACR;AAC1E,0BAA0B,qEAAc,6BAA6B,qEAAc,SAAS,qEAAc;AAC1G,wBAAwB,qEAAc;AACtC;AACO;AACP;AACA,oBAAoB,IAAI,qEAAc,EAAE;AACxC,mBAAmB,oFAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA,oBAAoB,IAAI,qEAAc,EAAE;AACxC,wBAAwB,IAAI,qEAAc,EAAE;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,kCAAkC,0GAAiB;AACzF,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA,sCAAsC,IAAI,0GAAiB;AAC3D,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,+EAAY;AACzE;AACA;AACA;AACA,gBAAgB,+GAA0B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,wCAAwC,WAAW;AACnD,oBAAoB,2BAA2B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F,oFAAgB;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,YAAY;AACjF;AACA,+BAA+B,+FAAsB,uBAAuB,qEAAc;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA,mCAAmC,8FAAmB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,IAAI,qEAAc,EAAE;AACxC,wBAAwB,IAAI,qEAAc,EAAE;AAC5C;AACA;AACA;AACA;AACA,2CAA2C,+EAAY,8BAA8B,0GAAiB;AACtG,4BAA4B,qEAAc;AAC1C,8CAA8C,qEAAc;AAC5D;AACA;AACA,4BAA4B,6DAAM;AAClC,4BAA4B,IAAI,qEAAc,EAAE;AAChD;AACA;AACA;AACA;AACA,iDAAiD,2FAAmB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,0GAAiB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,+FAAsB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,IAAI,qEAAc,EAAE;AACpD,oCAAoC,IAAI,qEAAc,EAAE;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yEAAW,CAAC,+FAAsB,uBAAuB,qEAAc,qBAAqB,mEAAY;AAC/H,6BAA6B,yEAAW,IAAI,mEAAY;AACxD,yCAAyC,yEAAW,YAAY,mEAAY;AAC5E;AACA;AACA;AACA;AACA;AACA,4CAA4C,YAAY,qBAAqB,YAAY;AACzF,4BAA4B,yBAAyB;AACrD,gCAAgC,4BAA4B;AAC5D;AACA;AACA;AACA;AACA;AACA,iCAAiC,OAAO;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,8BAA8B,qFAAuB,OAAO,yEAAW,IAAI,mEAAY,GAAG,mEAAY;AACtG,oBAAoB,IAAI,mEAAY,EAAE;AACtC,wBAAwB,IAAI,mEAAY,EAAE;AAC1C;AACA;AACA;AACA;AACA;AACA,4CAA4C,YAAY,qBAAqB,YAAY;AACzF,6BAA6B,KAAK,qEAAc,EAAE;AAClD,iCAAiC,KAAK,qEAAc,EAAE;AACtD;AACA;AACA;AACA;AACA;AACA,4FAA4F,qCAAqC,EAAE,mCAAmC;AACtK;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,YAAY,qEAAc,EAAE;AACxE,+CAA+C,oFAAQ;AACvD;AACA;AACA;AACA;AACA;AACA,6BAA6B,KAAK,qEAAc,EAAE;AAClD,iCAAiC,KAAK,qEAAc,EAAE;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6DAAM;AAC9B;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa,0GAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,yKAA0C;AACpG;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+GAA0B;AACtC;AACA,6BAA6B,0GAAiB;AAC9C,oBAAoB,+GAA0B;AAC9C;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,yEAAW,QAAQ,mEAAY;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,uDAAuD,sGAAqC;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,yCAAyC,qFAAuB,OAAO,yEAAW,IAAI,mEAAY,GAAG,mEAAY;AACjH,4BAA4B,6DAAM;AAClC;AACA;AACA;AACA,qCAAqC,6DAAM;AAC3C;AACA;AACA;AACA;AACA;AACA,gCAAgC,wBAAwB;AACxD;AACA,iDAAiD,+GAA0B;AAC3E;AACA,wCAAwC,8BAA8B;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,6FAAkB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,wBAAwB;AAC5D,gDAAgD,+GAA0B;AAC1E;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,oCAAoC,+GAA0B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6DAAM;AAClC;AACA;AACA;AACA,4BAA4B,IAAI,mEAAY,EAAE;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4C;;;;;;;;;;;;;;;;;;;ACre2B;AACU;AACgC;AACT;AACT;AAC3B;AACpE;AACA,YAAY,sDAAsD;AAClE,iCAAiC,qFAAuB,OAAO,+FAAsB,WAAW,mGAAY;AAC5G,oBAAoB,IAAI,qGAAc,EAAE;AACxC,wBAAwB,IAAI,qGAAc,EAAE;AAC5C;AACA;AACA;AACA,gCAAgC,6FAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sHAAiB;AAC9C;AACA,6CAA6C,SAAS,qGAAc,EAAE;AACtE,iDAAiD,SAAS,qGAAc,EAAE;AAC1E;AACA;AACA,4DAA4D,iFAAgB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6GAAkC;AAC9D;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;AClD+E;AACsB;AAClD;AACM;AAC2B;AACpF;AACO,qBAAqB,8DAAW;AACvC;AACA,QAAQ,8EAA2B;AACnC;AACA,6BAA6B,4FAAmB;AAChD,yBAAyB,OAAO,qDAAO;AACvC,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sFAAwC;AACtD;AACA;AACA;AACA,mDAAmD,yFAAc;AACjE,sDAAsD,yFAAc;AACpE;AACA;AACA,wBAAwB,+GAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACtDkE;AACf;AACkD;AAC5C;AAC4C;AACrG;AACO,wBAAwB,8DAAW;AAC1C;AACA,QAAQ,8EAA2B;AACnC;AACA,yBAAyB,OAAO,qDAAO;AACvC,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,gBAAgB,mEAAmE;AACnF,qCAAqC,8EAAqB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,+EAA+E,oFAAgB;AAC/F;AACA;AACA;AACA;AACA;AACA,gEAAgE,0FAAsB;AACtF;AACA,gCAAgC,+GAA0B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wFAA0C;AAC7D;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AC7DuD;AACS;AACb;AACgC;AAClB;AACoC;AAC5C;AAC2B;AACiB;AACrG;AACO,2BAA2B,8DAAW;AAC7C;AACA,QAAQ,8EAA2B;AACnC;AACA,6BAA6B,4FAAmB;AAChD,yBAAyB,OAAO,qDAAO;AACvC,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,mCAAmC,yFAA8B;AACjE;AACA,YAAY,sEAAkB;AAC9B,oBAAoB,mEAAmE;AACvF;AACA;AACA;AACA;AACA;AACA,4BAA4B,uDAAW,QAAQ,mEAAY,eAAe,uDAAW,QAAQ,mEAAY;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kFAAoC;AAC7D;AACA;AACA;AACA,iBAAiB,+GAA0B;AAC3C,iGAAiG,2FAAmB,CAAC,kFAAc;AACnI;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACvDmD;AACgC;AAClB;AACR;AACzD;AACO,4BAA4B,8DAAW;AAC9C;AACA,QAAQ,8EAA2B;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO,qDAAO;AACvC,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oBAAoB;AACpD;AACA;AACA;AACA;AACA,4DAA4D,qBAAqB;AACjF;AACA,yEAAyE,qBAAqB;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,wFAA0C;AACxD;AACA,mCAAmC,yFAA8B;AACjE;AACA;AACA,cAAc,kFAAoC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mEAAY;AACzC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACtEmD;AACgC;AAClB;AACR;AACQ;AACa;AAC9E;AACO,uBAAuB,8DAAW;AACzC;AACA,QAAQ,8EAA2B;AACnC;AACA;AACA;AACA;AACA;AACA,6BAA6B,yEAAa,QAAQ,+DAAgB,GAAG,mFAAoC;AACzG,2BAA2B,mEAAY;AACvC,yBAAyB,OAAO,qDAAO;AACvC,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wFAA0C;AACtD;AACA,iBAAiB;AACjB;AACA,mCAAmC,yFAA8B;AACjE;AACA;AACA;AACA;AACA;AACA,yBAAyB,kFAAoC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,mEAAY;AAC9D;AACA;AACA;AACA;AACA,iDAAiD,mEAAY;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,YAAY;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iFAAmC;AACnD;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACjG0E;AACe;AACtB;AAChB;AACgC;AACyB;AAChC;AACnB;AACzD;AACO,4BAA4B,8DAAW;AAC9C;AACA,QAAQ,8EAA2B;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO,qDAAO;AACvC,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,uGAAqB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wFAAa;AACzB;AACA;AACA;AACA,2BAA2B,0BAA0B,kFAAuB,eAAe;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,yFAA8B;AACjE,gBAAgB,gCAAgC;AAChD;AACA;AACA,cAAc,kFAAoC;AAClD;AACA;AACA;AACA;AACA,SAAS;AACT,iDAAiD,MAAM,wFAA+B,EAAE;AACxF;AACA;AACA,qDAAqD,yEAAkB;AACvE;AACA,gCAAgC,6DAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,iFAAsB,0DAA0D;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AChG4E;AACT;AAChB;AACgC;AACV;AACT;AACP;AACzD;AACO,qBAAqB,8DAAW;AACvC;AACA,QAAQ,8EAA2B;AACnC;AACA;AACA;AACA;AACA,4CAA4C,6EAAe,gBAAgB,mEAAY;AACvF;AACA;AACA;AACA;AACA,iCAAiC,yEAAW,IAAI,mEAAY;AAC5D;AACA;AACA,yBAAyB,OAAO,qDAAO;AACvC,0BAA0B;AAC1B;AACA,8EAA8E,IAAI;AAClF;AACA;AACA,4BAA4B,oBAAoB;AAChD;AACA;AACA;AACA;AACA,iCAAiC,mEAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,6BAA6B;AAC/C;AACA;AACA,yHAAyH,EAAE;AAC3H;AACA,qBAAqB,OAAO;AAC5B,4BAA4B,OAAO;AACnC,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA,4BAA4B,6DAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,yFAA8B;AACjE,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA,cAAc,kFAAoC;AAClD,+BAA+B,sEAAkB;AACjD;AACA;AACA;AACA,iCAAiC,yEAAW,IAAI,mEAAY;AAC5D,gCAAgC,6DAAM;AACtC;AACA;AACA;AACA;AACA,+BAA+B,yEAAkB;AACjD;AACA;AACA;AACA;AACA;AACA,oCAAoC,6DAAM;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC5GmD;AACsC;AACA;AAChC;AACzD;AACO,iCAAiC,8DAAW;AACnD;AACA,QAAQ,8EAA2B;AACnC;AACA;AACA,yBAAyB,OAAO,qDAAO;AACvC,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,6BAA6B;AACpD;AACA;AACA;AACA;AACA,8BAA8B,6BAA6B;AAC3D,wDAAwD,8BAA8B;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mEAAY;AACxC,qCAAqC,iFAAsB;AAC3D,mBAAmB,2FAA0B;AAC7C;AACA;AACA;AACA;AACA,kBAAkB,sFAAwC;AAC1D;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC/CkE;AACf;AACM;AACkB;AAC3E;AACO,mCAAmC,8DAAW;AACrD;AACA,QAAQ,8EAA2B;AACnC;AACA,yBAAyB,OAAO,qDAAO;AACvC,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wFAA0C;AAC/D;AACA;AACA;AACA,yCAAyC,qFAA4B;AACrE;AACA;AACA,8CAA8C,sFAA6B;AAC3E;AACA;AACA;AACA,sCAAsC,iFAAsB;AAC5D;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC1CoF;AACjC;AACgC;AACE;AAC5B;AACzD;AACO,8BAA8B,8DAAW;AAChD,yBAAyB,OAAO,qDAAO;AACvC,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,mCAAmC,yFAA8B;AACjE;AACA,iBAAiB,sEAAkB;AACnC,oBAAoB,sEAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,2FAAmB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kFAAoC;AACvD;AACA;AACA;;;;;;;;;;;;;;;;;;;ACrDmD;AACc;AACR;AACzD;AACO,0BAA0B,8DAAW;AAC5C;AACA,QAAQ,8EAA2B;AACnC;AACA,2BAA2B,mEAAY;AACvC;AACA;AACA;AACA,yBAAyB,OAAO,qDAAO;AACvC,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,mEAAY;AAC9D;AACA;AACA;AACA;AACA,iDAAiD,mEAAY;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,YAAY;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC1DmD;AACM;AACzD;AACO,4BAA4B,8DAAW;AAC9C;AACA,QAAQ,8EAA2B;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO,qDAAO;AACvC,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mBAAmB;AACnD;AACA;AACA;AACA,qBAAqB,mBAAmB;AACxC,6BAA6B,mBAAmB;AAChD,iEAAiE,oBAAoB;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC3C4D;AACT;AACyB;AACnB;AACzD;AACO;AACP;AACA;AACA;AACA;AACO;AACA,+BAA+B,8DAAW;AACjD;AACA,QAAQ,8EAA2B;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO,qDAAO;AACvC,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oBAAoB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,wCAAwC;AACnF,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,wFAA0C;AACxD,kCAAkC,wFAA+B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0EAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACrGmE;AAChB;AACgC;AACV;AACS;AACmB;AACzB;AACa;AAChC;AACzD;AACO,uBAAuB,8DAAW;AACzC;AACA,QAAQ,8EAA2B;AACnC;AACA,yBAAyB,OAAO,qDAAO;AACvC,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,qFAA4B;AAC9D,qCAAqC,uFAA8B;AACnE,qCAAqC,sFAA6B;AAClE,oBAAoB,gCAAgC;AACpD;AACA;AACA;AACA;AACA,oBAAoB,2FAA0B;AAC9C,gEAAgE,2FAAmB,CAAC,kFAAc;AAClG;AACA;AACA;AACA,uCAAuC,mEAAY;AACnD;AACA,oBAAoB,wFAAkB;AACtC;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,kBAAkB,wFAA0C;AAC5D;AACA;AACA,mCAAmC,yFAA8B;AACjE;AACA;AACA;AACA,cAAc,kFAAoC;AAClD,4BAA4B,6DAAM;AAClC;AACA;AACA;AACA;AACA,6CAA6C,2FAA0B;AACvE;AACA,iEAAiE,2FAAmB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,yEAAkB;AAC/C;AACA;AACA;AACA;AACA,8CAA8C,2FAA0B;AACxE;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;;;AC7FmD;AACgC;AAC1B;AACzD;AACO,kCAAkC,8DAAW;AACpD;AACA,QAAQ,8EAA2B;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO,qDAAO;AACvC,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,8BAA8B;AACpE;AACA;AACA;AACA;AACA,iEAAiE,8BAA8B;AAC/F;AACA,+FAA+F,+BAA+B;AAC9H;AACA;AACA;AACA,mCAAmC,yFAA8B;AACjE;AACA;AACA,cAAc,kFAAoC;AAClD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACvDuD;AACU;AACC;AACT;AACzD;AACO,yBAAyB,8DAAW;AAC3C;AACA,QAAQ,8EAA2B;AACnC;AACA,yBAAyB,OAAO,oEAAY;AAC5C,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,0BAA0B,uDAAW,QAAQ,mEAAY;AACzD;AACA;AACA;AACA;AACA;AACA,YAAY,6FAAqC;AACjD;AACA;AACA;;;;;;;;;;;;;;;;;;;;AChCwH;AAClB;AACpC;AACT;AACzD;AACO,wBAAwB,8DAAW;AAC1C;AACA,QAAQ,8EAA2B;AACnC;AACA;AACA;AACA;AACA;AACA,qEAAqE,0GAAiB;AACtF;AACA;AACA,yBAAyB,OAAO,oEAAY;AAC5C,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,8BAA8B;AAC1D;AACA;AACA;AACA,8BAA8B,+GAA0B;AACxD;AACA,SAAS;AACT;AACA;AACA,6CAA6C,qFAA2B,CAAC,4EAAkB,cAAc;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AClD0E;AACP;AACD;AACT;AACzD;AACO;AACA,4BAA4B,8DAAW;AAC9C;AACA,QAAQ,8EAA2B;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO,oEAAY;AAC5C,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA,mCAAmC,mBAAmB,EAAE,6EAAmB,sBAAsB;AACjG;AACA;AACA;AACA;AACA;AACA,gEAAgE,qEAAc;AAC9E,gEAAgE,qEAAc;AAC9E;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC9CkE;AACT;AACzD;AACO,kCAAkC,8DAAW;AACpD,yBAAyB,OAAO,oEAAY;AAC5C,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sGAA8C;AACjE;AACA;AACA;;;;;;;;;;;;;;;;;;AC3BkE;AACT;AACzD;AACO,uBAAuB,8DAAW;AACzC;AACA,QAAQ,8EAA2B;AACnC;AACA,yBAAyB,OAAO,oEAAY;AAC5C,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,0CAA0C,6DAA6D;AACvG,0CAA0C,4DAA4D;AACtG,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AClCkE;AACT;AACzD;AACO,wBAAwB,8DAAW;AAC1C;AACA,QAAQ,8EAA2B;AACnC;AACA,yBAAyB,OAAO,oEAAY;AAC5C,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,gBAAgB,gCAAgC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sGAA8C;AACjE;AACA;AACA;;;;;;;;;;;;;;;;;;ACpCkE;AACT;AACzD;AACO,sBAAsB,8DAAW;AACxC;AACA,QAAQ,8EAA2B;AACnC;AACA,yBAAyB,OAAO,oEAAY;AAC5C,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6FAAqC;AACjD;AACA;AACA;;;;;;;;;;;;;;;;;;AC9BmE;AAC5D;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE;AAClE;AACP;AACA;AACA;AACA;AACA;AACA,iGAAiG;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,oBAAoB,8DAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAS,CAAC,2HAA0D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvF7B;AACM;AACe;AAC2B;AACA;AACN;AACV;AACkB;AACV;AACgB;AACM;AACf;AACQ;AACzC;AAC9C;AACP;AACA,CAAC;AACD;AACA,IAAI,0FAAU,EAAE,gGAAa,EAAE,gFAAK,EAAE,gGAAa;AACnD,IAAI,gGAAS,EAAE,wGAAa;AAC5B,IAAI,wFAAQ;AACZ;AACA;AACA;AACA,iCAAiC,+CAAK;AACtC;AACA;AACA,sCAAsC,oEAAY;AAClD;AACA;AACA,sCAAsC,qDAAO;AAC7C;AACA;AACA;AACO;AACP;AACA;AACA,yBAAyB,wGAAa,EAAE,gGAAS,EAAE,wGAAgB,EAAE,kGAAa,EAAE,+GAAmB;AACvG,8BAA8B,+EAA2B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACO;AACP;AACA,4BAA4B,mFAA+B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;ACzIO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC5CO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACdO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACX6D;AACC;AACN;AACsD;AACR;AACI;AACsB;AAClF;AACG;AACjD;AACA,qCAAqC,0EAAW;AAChD;AACA;AACA;AACA;AACA,iCAAiC,aAAa;AAC9C,WAAW,8EAAe;AAC1B;AACA,oFAAoF,0BAA0B;AAC9G,+DAA+D,YAAY;AAC3E;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,8EAAe;AAC9D,wDAAwD,8FAAsB;AAC9E;AACA,mBAAmB,uEAAsB,OAAO,4FAAgB;AAChE,yBAAyB,6DAAO;AAChC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mEAAuB,UAAU,GAAG,2EAAY;AACpE,qCAAqC,8DAAc;AACnD;AACA;AACA;AACA;AACA;AACA,2EAA2E,2DAAY;AACvF;AACA;AACA,0EAA0E,yFAAiB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,IAAI,OAAO,IAAI,MAAM,IAAI;AAChD;AACA;AACA;AACA;AACA;AACA,gBAAgB,4FAAyB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mGAAqB;AAC1C;AACA;AACA,4BAA4B,oFAAU;AACtC;AACA;AACA,4BAA4B,oFAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,8FAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,6FAAiB;AAC5E;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7JwH;AACtD;AACJ;AACR;AACmB;AACjB;AACsB;AAC+B;AACC;AACzB;AACvC;AACiC;AAC/E;AACA;AACA,QAAQ,2DAAe,WAAW,2EAAY;AAC9C;AACA;AACA;AACA;AACA,kCAAkC,2EAAY,EAAE,qBAAqB,gBAAgB;AACrF;AACA;AACA;AACA,mCAAmC,2DAAe,QAAQ,2EAAY;AACtE;AACO;AACP,wBAAwB,6DAAO;AAC/B,kBAAkB,uEAAsB,OAAO,4FAAgB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kGAAoB;AAChC,iCAAiC,2DAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2DAAe,SAAS,2EAAY;AAChD;AACA;AACA;AACA,yEAAyE,iBAAiB;AAC1F;AACA;AACA,uBAAuB,uDAAW,OAAO,2EAAY;AACrD,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,qEAAM;AACtD,sEAAsE,sEAAyB;AAC/F;AACA;AACA;AACA;AACA,oDAAoD,2DAAe,QAAQ,2EAAY;AACvF;AACA,gDAAgD,qEAAM;AACtD;AACA,oCAAoC,8FAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,qEAAM;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,qEAAM;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,gGAAkB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,2DAAe;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,qEAAM;AACtD,gDAAgD,kEAAqB;AACrE;AACA;AACA;AACA;AACA,oDAAoD,2DAAe,QAAQ,2EAAY;AACvF;AACA,gDAAgD,qEAAM;AACtD;AACA;AACA,2FAA2F,+GAA0B;AACrH,2EAA2E,qGAAqB;AAChG;AACA,4CAA4C,0GAAiB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,2DAAe,QAAQ,2EAAY;AACvF;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,2DAAe,QAAQ,2EAAY;AACvF;AACA;AACA;AACA;AACA;AACA,qDAAqD,2DAAe,QAAQ,2EAAY,KAAK,2DAAe,QAAQ,2EAAY;AAChI;AACA,gDAAgD,qEAAM;AACtD;AACA;AACA;AACA;AACA,yCAAyC,8EAAiC;AAC1E;AACA,uDAAuD,kEAAqB;AAC5E;AACA,oFAAoF,kFAAmB;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,qGAAqB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,aAAa;AACb;;;;;;;;;;;;;;;;;;;;;;;AC5NoG;AACuB;AACtD;AACmG;AACnF;AACjC;AAC7C;AACP;AACA;AACA;AACA,8CAA8C,IAAI,mCAAmC,IAAI;AACzF,0CAA0C,IAAI,YAAY,IAAI;AAC9D,kEAAkE,IAAI;AACtE;AACA,yBAAyB;AACzB,uBAAuB;AACvB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,iEAAqB;AAC1D,mCAAmC,iEAAqB;AACxD;AACA;AACA,qBAAqB;AACrB;AACA;AACA,mCAAmC,iEAAqB;AACxD;AACA;AACA,qBAAqB,OAAO,2FAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sFAAqB;AAC9C,iDAAiD,sFAAqB;AACtE,gBAAgB,sFAAqB;AACrC,yBAAyB,MAAM,sFAAqB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kGAAoB,YAAY,8FAAiB;AAC9D;AACA,+BAA+B,iEAAqB;AACpD;AACA;AACA;AACA,mBAAmB,mGAAmB,CAAC,mFAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mGAAmB,CAAC,0FAAc;AAChE;AACA;AACA;AACA,gCAAgC,iEAAqB;AACrD,8BAA8B,iEAAqB;AACnD;AACA,sEAAsE,0BAA0B;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mEAAmE,8FAA6B;AACrH;AACA;AACA,qBAAqB,mEAAmE,6FAA4B;AACpH;AACA;AACA;AACA;AACA;AACA,SAAS,8EAAkB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,4FAAuB;AAC9D,oBAAoB,gGAA2B;AAC/C,kDAAkD;AAClD;AACA;AACA,wFAAwF,4BAA4B;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uFAAkB;AAClC;AACA;AACA;AACA,+DAA+D,KAAK;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yBAAyB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gGAA2B;AAC3C,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC5PO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA,0BAA0B,SAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;UC/DA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;UAEA;UACA;;;;;WCzBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;WACA;WACA;WACA;WACA;;;;;WCJA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA,CAAC;;;;;WCPD,8CAA8C;;;;;WCA9C;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;WCNA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;;;;WCfA;;WAEA;WACA;WACA;WACA;WACA;;WAEA;WACA;;WAEA;;WAEA;;;;;UEbA;UACA;UACA;UACA","sources":["webpack://spring-react-app/./src/main/client/javascript/baseTypes.ts","webpack://spring-react-app/./src/main/client/javascript/logic/BaseInterfaces.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/Board/Board.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/Board/BoardInterface.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/Board/BoardMoveValidator.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/FENData/FENData.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/FENData/FENDataInterface.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/GameInformation/GameData.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/GameInformation/GameUnits/GameUnits.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/GameInformation/GameUnits/PieceString.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/MoveTree/MoveTree.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/MoveTree/MoveTreeInterface.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/MoveTree/MoveTreeValidator.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/PieceControl/PieceControl.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/PieceControl/PieceControlBuilder.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/PieceControl/PieceControlDeclarations.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/PieceControl/PieceControlInterface.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/VariantRule/Zombies/ZombieInterface.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/AllowPassing.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/AlternativeTeams.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/BarePieceRule.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/Blindfold.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/CaptureTheKing.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/Chess960.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/Crazyhouse.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/DuckChess.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/FogOfWar.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/ForcedCapture.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/GameMetadataRules.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/Ghostboard.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/ParadigmChess30.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/PiecesFaceCenter.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/SeirawanSetup.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/SelfCheck.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/SetupChess.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/Taboo.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/BoardVariantModules/InsufficientMaterial/InsufficientMaterialGeneration.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/BoardVariantModules/InsufficientMaterial/PieceMedianCounter.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/Atomic.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/EnPassant.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/FatalCapture.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/FiftyMoveRule.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/Giveaway.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/KingOfTheHill.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/NCheck.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/OppositeMultiplier.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/OppositeSideCastling.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/PiecesGoToBanks.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/PlayForMate.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/PointsForMate.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/StalemateOptions.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/Takeover.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/ThreefoldRepetition.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/PieceControlDecorators/AnyCapture.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/PieceControlDecorators/PromoteTo.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/PieceControlDecorators/PromotionRank.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/PieceControlDecorators/RoyalsCannotCapture.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/PieceControlDecorators/Sideways.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/PieceControlDecorators/Stonewall.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/PieceControlDecorators/Torpedo.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleInterface.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleSetup.ts","webpack://spring-react-app/./src/main/client/javascript/logic/utils/ArrayUtils.ts","webpack://spring-react-app/./src/main/client/javascript/logic/utils/NumberUtils.ts","webpack://spring-react-app/./src/main/client/javascript/logic/utils/ObjectUtils.ts","webpack://spring-react-app/./src/main/client/javascript/logic/utils/Parsers/PGNParser.ts","webpack://spring-react-app/./src/main/client/javascript/logic/utils/Parsers/ParseFENData.ts","webpack://spring-react-app/./src/main/client/javascript/logic/utils/Parsers/ParsePGNMoves.ts","webpack://spring-react-app/./src/main/client/javascript/logic/utils/StringFormatUtils.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/ sync \\.ts$","webpack://spring-react-app/webpack/bootstrap","webpack://spring-react-app/webpack/runtime/define property getters","webpack://spring-react-app/webpack/runtime/get javascript chunk filename","webpack://spring-react-app/webpack/runtime/global","webpack://spring-react-app/webpack/runtime/hasOwnProperty shorthand","webpack://spring-react-app/webpack/runtime/make namespace object","webpack://spring-react-app/webpack/runtime/publicPath","webpack://spring-react-app/webpack/runtime/importScripts chunk loading","webpack://spring-react-app/webpack/before-startup","webpack://spring-react-app/webpack/startup","webpack://spring-react-app/webpack/after-startup"],"sourcesContent":["export const verifyFunctionType = (func) => typeof func === 'function';\r\nexport const createTuple = (val, length) => Array.from({ length }).fill(val);\r\nexport const createTupleFromCallback = (val, length) => Array.from({ length }, val);\r\nexport const verifyTupleType = (arr, length) => arr.length === length;\r\nexport const throwOnNever = (arg) => {\r\n    console.dir(arg);\r\n    throw new TypeError(`Unexpected argument that is supposed to be of type never`);\r\n};\r\nexport function importAll(r) {\r\n    r.keys().forEach(r);\r\n}\r\n","import { createTupleFromCallback } from \"../baseTypes\";\r\nimport { boardDimension } from \"./movegen/GameInformation/GameData\";\r\nexport const initializeBoardSquares = (baseValue) => createTupleFromCallback(() => createTupleFromCallback(baseValue, boardDimension), boardDimension);\r\n","import { createTuple, createTupleFromCallback } from \"../../../baseTypes\";\r\nimport { initializeBoardSquares } from \"../../BaseInterfaces\";\r\nimport { createMoveTree } from \"../MoveTree/MoveTree\";\r\nimport { createBaseMoveWrapper, InternalMoveSignature, SpecialMove } from \"../MoveTree/MoveTreeInterface\";\r\nimport { parsePGN } from \"../../utils/Parsers/PGNParser\";\r\nimport { colors, totalPlayers } from \"../GameInformation/GameData\";\r\nimport { colorEnum } from \"../GameInformation/GameUnits/GameUnits\";\r\nimport { createPieceFromData, nonPlayablePieces, pawnPieceString, wallPieceString } from \"../GameInformation/GameUnits/PieceString\";\r\nimport { PieceControlBuilder } from \"../PieceControl/PieceControlBuilder\";\r\nimport { initPieceControlDeclarations } from \"../PieceControl/PieceControlDeclarations\";\r\nimport { pieceControlConfigSettings } from \"../PieceControl/PieceControlInterface\";\r\nimport { decorateClassWithVariants } from \"../VariantRules/VariantRuleInterface\";\r\nimport { copyVariantRules } from \"../VariantRules/VariantRuleSetup\";\r\nimport { createGameTypeSettings, createComplexMoveLegalityTracker, createBasePreGeneratedAttacks, compareCoordinates, stringifyCoordinate } from \"./BoardInterface\";\r\nimport { validateMoveTree } from \"../MoveTree/MoveTreeValidator\";\r\nimport { copyClass } from \"../../utils/ObjectUtils\";\r\ninitPieceControlDeclarations();\r\nconst baseImmunes = createTuple(false, totalPlayers);\r\nclass Board {\r\n    controls = {};\r\n    data;\r\n    moves;\r\n    preGeneratedAttacks = createBasePreGeneratedAttacks();\r\n    board;\r\n    isComplexSetup = createComplexMoveLegalityTracker();\r\n    gameData;\r\n    gameType = createGameTypeSettings();\r\n    variantRules;\r\n    variantData;\r\n    isTwoPlayer;\r\n    insufficientMaterialModule;\r\n    __baseClass;\r\n    // type = static, game, puzzle\r\n    constructor(pgn4) {\r\n        this.__baseClass = this;\r\n        const parsingResults = parsePGN(pgn4);\r\n        this.gameType.type = parsingResults.gameType;\r\n        this.variantRules = parsingResults.variantRules;\r\n        this.gameData = parsingResults.gameData;\r\n        this.board = parsingResults.board;\r\n        this.data = parsingResults.fenData;\r\n        this.data.injectBoard(this);\r\n        this.data = decorateClassWithVariants(this.data, this.variantRules.fenDataDecorators);\r\n        this.variantData = parsingResults.variantRuleData;\r\n        this.isTwoPlayer = this.data.getRealPlayers() === 2;\r\n        this.initPieceControls(parsingResults.pieceSet);\r\n        this.moves = createMoveTree(this.createSnapshot());\r\n        this.moves.moves = parsingResults.moves;\r\n        this.moves = validateMoveTree(this, this.moves);\r\n        this.pregenerateAttacks();\r\n        /*\r\n                new Promise((resolve: (value: InsufficientMaterialModule) => void) => {\r\n                    setTimeout(() => resolve(generateInsufficientMatingPieces(this)), 0)\r\n                }).then(result => {\r\n                    this.insufficientMaterialModule = result;\r\n                }).catch(exception => {\r\n                    console.error(\"Failed to generate insufficient material module: \");\r\n                    console.trace(exception);\r\n                });*/\r\n    }\r\n    initPieceControls(pieces) {\r\n        if (pieces.size === 0)\r\n            return;\r\n        const builder = new PieceControlBuilder();\r\n        builder.setFENData(this.data);\r\n        builder.setVariantRules(this.variantRules.pieceControlDecorators);\r\n        for (const piece of pieces) {\r\n            const pieceControlConfigurator = builder.createPieceControlWrap(piece);\r\n            this.controls[piece] = pieceControlConfigurator;\r\n        }\r\n    }\r\n    getSquareVisibility() {\r\n        return initializeBoardSquares(() => []);\r\n    }\r\n    createSnapshot() {\r\n        return {\r\n            data: this.data.createSnapshot(),\r\n            board: this.board.map(a => a.slice()),\r\n            isComplexSetup: Object.assign({}, this.isComplexSetup)\r\n        };\r\n    }\r\n    loadSnapshot(snapshot) {\r\n        this.isComplexSetup = snapshot.isComplexSetup;\r\n        this.data.loadSnapshot(snapshot.data);\r\n        this.board = snapshot.board;\r\n        this.pregenerateAttacks();\r\n        this.runComplexLegalityEvaluationChecks();\r\n    }\r\n    createClone() {\r\n        let targetObject = copyClass(this.__baseClass, Board);\r\n        targetObject.board = this.board.map(a => a.slice()); // PieceStrings are immutable\r\n        targetObject.isComplexSetup = Object.assign({}, this.isComplexSetup);\r\n        targetObject.preGeneratedAttacks = createBasePreGeneratedAttacks();\r\n        targetObject.data = this.data.createClone();\r\n        targetObject = decorateClassWithVariants(targetObject, copyVariantRules(this.__baseClass.variantRules.boardDecorators));\r\n        targetObject.data.injectBoard(targetObject);\r\n        targetObject.data = decorateClassWithVariants(targetObject.data, copyVariantRules(this.__baseClass.variantRules.fenDataDecorators));\r\n        const presumedPieceLetters = new Set();\r\n        let letter;\r\n        for (letter in this.controls) {\r\n            if (Object.prototype.hasOwnProperty.call(this.controls, letter)) {\r\n                presumedPieceLetters.add(letter);\r\n            }\r\n        }\r\n        targetObject.initPieceControls(presumedPieceLetters);\r\n        targetObject.pregenerateAttacks();\r\n        return targetObject;\r\n    }\r\n    isKingInCheck(baseColor, fenRoyal = this.data.fenOptions.royal) {\r\n        const royal = fenRoyal[baseColor];\r\n        if (!royal || this.data.fenOptions.dead[baseColor])\r\n            return false;\r\n        const coordinates = royal;\r\n        return !!(this.preGeneratedAttacks.slidingPieces[coordinates[0]][coordinates[1]]\r\n            || this.preGeneratedAttacks.hoppingPieces[coordinates[0]][coordinates[1]]);\r\n    }\r\n    getPlayerPieces() {\r\n        const playerPieces = [[], [], [], []];\r\n        for (let i = 0; i < 14; i++) {\r\n            for (let j = 0; j < 14; j++) {\r\n                const square = this.board[i][j];\r\n                if (square.isEmpty())\r\n                    continue;\r\n                const color = square.color;\r\n                if (color !== 4)\r\n                    playerPieces[color].push([i, j]);\r\n            }\r\n        }\r\n        return playerPieces;\r\n    }\r\n    getCheckmatesAndStalemates() {\r\n        const kingChecks = createTuple(false, totalPlayers);\r\n        const legalMoves = createTuple(false, totalPlayers);\r\n        const playerPieces = this.getPlayerPieces();\r\n        legalMoves[this.data.sideToMove] = true;\r\n        if (this.isKingInCheck(this.data.sideToMove))\r\n            kingChecks[this.data.sideToMove] = true;\r\n        for (const color of colors) {\r\n            if (color === this.data.sideToMove || this.data.fenOptions.dead[color])\r\n                continue;\r\n            const currentState = this.createSnapshot();\r\n            const playerArmy = playerPieces[color];\r\n            this.pregenerateAttacks(color);\r\n            if (this.isKingInCheck(color)) {\r\n                kingChecks[color] = true;\r\n            }\r\n            for (const piece of playerArmy) {\r\n                if (this.getLegalMoves(piece[0], piece[1], color).length) {\r\n                    legalMoves[color] = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!legalMoves[color]) {\r\n                if (this.preGeneratedAttacks.pieceDrops.pawn.length || this.preGeneratedAttacks.pieceDrops.piece.length) {\r\n                    legalMoves[color] = true;\r\n                }\r\n            }\r\n            this.loadSnapshot(currentState);\r\n        }\r\n        const kingCaptures = this.data.fenOptions.royal.map((r, i) => !this.data.fenOptions.dead[i] && r\r\n            ? this.board[r[0]][r[1]].isEmpty() || this.board[r[0]][r[1]].color !== i : false);\r\n        return {\r\n            checkmates: legalMoves.map((move, i) => kingCaptures[i] || (!move && kingChecks[i])),\r\n            stalemates: legalMoves.map((move, i) => !move && !kingChecks[i]),\r\n            checks: kingChecks\r\n        };\r\n    }\r\n    runComplexLegalityEvaluationChecks() {\r\n        if (this.isComplexSetup.hasComplexRules)\r\n            return;\r\n        for (let i = 0; i < 14; i++) {\r\n            for (let j = 0; j < 14; j++) {\r\n                const square = this.board[i][j];\r\n                if (square.isPiece() && pieceControlConfigSettings[square.piece].moveGenerationSettings.isComplex) {\r\n                    this.isComplexSetup.hasComplexPieces = true;\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    getCurrentChecks(sideToMove = this.data.sideToMove) {\r\n        const playerRoyals = this.data.fenOptions.royal.map((r, i) => r && !this.data.fenOptions.dead[i]\r\n            && !this.data.fenOptions.resigned[i] ? r : null);\r\n        const attackingCoordinates = createTupleFromCallback(() => [], totalPlayers);\r\n        for (const [startingCoordinate, attackList] of this.preGeneratedAttacks.pieceMovements) {\r\n            for (const attack of attackList) {\r\n                for (const color of colors) {\r\n                    if (color === sideToMove)\r\n                        continue;\r\n                    const royal = playerRoyals[color];\r\n                    if (royal && compareCoordinates(royal, attack.move)) {\r\n                        attackingCoordinates[color].push(startingCoordinate);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return attackingCoordinates;\r\n    }\r\n    makeMove(move, ignoreNextMoves = false) {\r\n        let returnValues;\r\n        const pregeneratedAttacks = this.preGeneratedAttacks;\r\n        for (let i = 0; i < move.length; i++) {\r\n            if (i === move.length - 1) {\r\n                returnValues = this.data.affectOptions(move[i], {\r\n                    ignoreCheckmateChecks: ignoreNextMoves, ignoreNextTurn: false\r\n                });\r\n            }\r\n            else {\r\n                this.data.affectOptions(move[i], {\r\n                    ignoreCheckmateChecks: ignoreNextMoves, ignoreNextTurn: true\r\n                });\r\n            }\r\n        }\r\n        this.runComplexLegalityEvaluationChecks();\r\n        if (ignoreNextMoves)\r\n            return returnValues;\r\n        const path = this.moves.currentMove.slice();\r\n        path[path.length - 1]++;\r\n        this.moves.setNewMove({\r\n            move: createBaseMoveWrapper({ path, moveData: move }),\r\n            snapshot: {\r\n                boardSnapshot: this.createSnapshot(),\r\n                pregeneratedAttacks\r\n            },\r\n            fenDataString: this.data.constructPreliminaryHashString()\r\n        });\r\n        this.moves.currentMove = path;\r\n        if (returnValues.checkmates[this.data.sideToMove]) {\r\n            returnValues = this.makeMove([{ type: InternalMoveSignature.TeamsCheckmate }], true);\r\n        }\r\n        else if (returnValues.stalemates[this.data.sideToMove]) {\r\n            returnValues = this.makeMove([{ type: InternalMoveSignature.Stalemate }]);\r\n        }\r\n        return returnValues;\r\n    }\r\n    pregenerateAttacks(sideToMove = this.data.sideToMove) {\r\n        this.preGeneratedAttacks = createBasePreGeneratedAttacks();\r\n        for (let i = 0; i < 14; i++) {\r\n            for (let j = 0; j < 14; j++) {\r\n                const square = this.board[i][j];\r\n                if (!square.isPiece())\r\n                    continue;\r\n                const color = square.color;\r\n                const letter = square.piece;\r\n                const controlBuilder = this.controls[letter]().setColor(color).setCoordinates(i, j).setBoard(this.board);\r\n                const setting = pieceControlConfigSettings[square.piece];\r\n                const resultingMoves = [];\r\n                if (color === sideToMove || color === this.gameType.getTeammateColor(sideToMove)) {\r\n                    const control = controlBuilder.setBaseImmunePieces(this.gameType.getBaseColors(color)).constructPieceControl();\r\n                    resultingMoves.push(...control.getPseudoLegalMoves());\r\n                }\r\n                else {\r\n                    const control = controlBuilder.setBaseImmunePieces(baseImmunes).constructPieceControl();\r\n                    if (setting.moveGenerationSettings.isJumping) {\r\n                        const attacks = control.rayGenJumpingAttacks();\r\n                        for (const { move: attack } of attacks) {\r\n                            this.preGeneratedAttacks.hoppingPieces[attack[0]][attack[1]]++;\r\n                            this.preGeneratedAttacks.hoppingPieceLines.push([[i, j], attack]);\r\n                            const l = this.preGeneratedAttacks.attackingColors[attack[0]][attack[1]];\r\n                            if (l !== -1 && this.preGeneratedAttacks.attackingColors[attack[0]][attack[1]] !== color + 1) {\r\n                                this.preGeneratedAttacks.attackingColors[attack[0]][attack[1]] = (l === 0 ? 1 + color : -1);\r\n                            }\r\n                        }\r\n                    }\r\n                    if (setting.moveGenerationSettings.isSliding) {\r\n                        const attacks = control.rayGenSlidingAttacks();\r\n                        for (const attack of attacks) {\r\n                            for (const { move: subAttack } of attack) {\r\n                                this.preGeneratedAttacks.slidingPieces[subAttack[0]][subAttack[1]]++;\r\n                                const l = this.preGeneratedAttacks.attackingColors[subAttack[0]][subAttack[1]];\r\n                                if (l !== -1 && this.preGeneratedAttacks.attackingColors[subAttack[0]][subAttack[1]] !== color + 1) {\r\n                                    this.preGeneratedAttacks.attackingColors[subAttack[0]][subAttack[1]] = (l === 0 ? 1 + color : -1);\r\n                                }\r\n                            }\r\n                            if (attack.length !== 0) {\r\n                                this.preGeneratedAttacks.slidingPiecesLines.push([[i, j], attack.map(m => m.move)]);\r\n                            }\r\n                            else {\r\n                                const coordinateArray = [];\r\n                                this.preGeneratedAttacks.slidingPiecesLines.push([[i, j], coordinateArray]);\r\n                            }\r\n                        }\r\n                        const rayGen = control.rayGenSlidingAttacks(5 /* AttackType.RayTraceLimited */);\r\n                        for (const attack of rayGen) {\r\n                            if (attack.length !== 0) {\r\n                                let isRoyalOnLine = false;\r\n                                const resultingAttack = [];\r\n                                for (const { move } of attack) {\r\n                                    resultingAttack.push(move);\r\n                                    if (isRoyalOnLine) {\r\n                                        this.preGeneratedAttacks.slidingPieces[move[0]][move[1]]++;\r\n                                    }\r\n                                    else if (compareCoordinates(this.data.fenOptions.royal[sideToMove] ?? [-1, -1], move)) {\r\n                                        isRoyalOnLine = true;\r\n                                    }\r\n                                }\r\n                                this.preGeneratedAttacks.slidingPiecesRayTracing.push([[i, j], attack.map(m => m.move)]);\r\n                            }\r\n                            else {\r\n                                this.preGeneratedAttacks.slidingPiecesLines.push([[i, j], []]);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                this.preGeneratedAttacks.pieceMovements.set(stringifyCoordinate([i, j]), resultingMoves);\r\n            }\r\n        }\r\n        this.preGeneratedAttacks.pieceDrops.piece = this.getDroppingMoves(createPieceFromData(sideToMove, nonPlayablePieces.wall));\r\n        this.preGeneratedAttacks.pieceDrops.piece = this.getDroppingMoves(createPieceFromData(sideToMove, pawnPieceString.piece));\r\n    }\r\n    isSetupComplex() { return this.isComplexSetup.hasComplexPieces || this.isComplexSetup.hasComplexRules || this.data.isComplexEvaluation(); }\r\n    isTheMoveLegal(color, moveData, isSeirawanDrop = false) {\r\n        const { startCoordinates: [pieceI, pieceJ], endCoordinates: [attackI, attackJ] } = moveData;\r\n        const data = this.data;\r\n        const royal = data.fenOptions.royal[color];\r\n        if (!this.board[attackI][attackJ].isEmpty() && royal && attackI === royal[0] && attackJ === royal[1])\r\n            return false;\r\n        if (this.isSetupComplex()) {\r\n            const snapshot = this.createSnapshot();\r\n            const moveArray = [{\r\n                    startCoordinates: [pieceI, pieceJ],\r\n                    endCoordinates: [attackI, attackJ]\r\n                }];\r\n            if (isSeirawanDrop)\r\n                moveArray.push({ piece: wallPieceString, endCoordinates: [pieceI, pieceJ] });\r\n            const { checks, checkmates } = this.makeMove(moveArray, true);\r\n            let isKingInCheck = checks[color] || checkmates[color];\r\n            if (!isKingInCheck) {\r\n                this.pregenerateAttacks(color);\r\n                isKingInCheck = this.isKingInCheck(color);\r\n            }\r\n            this.loadSnapshot(snapshot);\r\n            return !isKingInCheck;\r\n        }\r\n        else {\r\n            const [royalI, royalJ] = data.fenOptions.royal[color] ?? [null, null];\r\n            if (royalI === null)\r\n                return true;\r\n            const isRoyalMove = royalI === pieceI && royalJ === pieceJ;\r\n            const attackers = this.preGeneratedAttacks.hoppingPieces[royalI][royalJ] +\r\n                this.preGeneratedAttacks.slidingPieces[royalI][royalJ];\r\n            const targetSafety = this.preGeneratedAttacks.slidingPieces[attackI][attackJ]\r\n                + this.preGeneratedAttacks.hoppingPieces[attackI][attackJ] === 0;\r\n            const legalitySettings = {\r\n                canKingCapture: undefined\r\n            };\r\n            for (let i = 0; i < data.fenOptions.royal.length; i++) {\r\n                const royal = data.fenOptions.royal[i];\r\n                if (i !== color && royal && royal[0] === attackI && royal[1] === attackJ) {\r\n                    const royalDefendedSquare = this.preGeneratedAttacks.attackingColors[royal[1]][royal[0]];\r\n                    if ((royalDefendedSquare === i + 1 || royalDefendedSquare === 0)\r\n                        && (isRoyalMove || this.preGeneratedAttacks.attackingColors[royalI][royalJ] === i + 1)) {\r\n                        legalitySettings.canKingCapture = i + 1;\r\n                    }\r\n                }\r\n            }\r\n            if (!this.gameType.isFFA() && legalitySettings.canKingCapture !== undefined)\r\n                return true;\r\n            for (const [attackingPiece, attackLine] of this.preGeneratedAttacks.slidingPiecesRayTracing) {\r\n                let isPieceUnderAttack = false, isRoyalUnderAttack = false, isTheTargetSquarePinListed = false;\r\n                for (const [attackedX, attackedY] of attackLine) {\r\n                    if (!isPieceUnderAttack && attackedX === pieceI && attackedY === pieceJ)\r\n                        isPieceUnderAttack = true;\r\n                    else if (!isTheTargetSquarePinListed && !isRoyalUnderAttack &&\r\n                        attackedX === attackI && attackedY === attackJ)\r\n                        isTheTargetSquarePinListed = true;\r\n                    if (!isRoyalUnderAttack && attackedX === royalI && attackedY === royalJ)\r\n                        isRoyalUnderAttack = true;\r\n                    if (isRoyalMove) {\r\n                        if (isRoyalUnderAttack && attackedX === attackI && attackedY === attackJ) {\r\n                            if (legalitySettings.canKingCapture && legalitySettings.canKingCapture > 0 && this.board[attackedX][attackedY].color + 1 === legalitySettings.canKingCapture)\r\n                                continue;\r\n                            return false;\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (isPieceUnderAttack && isRoyalUnderAttack && !compareCoordinates(attackingPiece, moveData.endCoordinates) && !isTheTargetSquarePinListed) {\r\n                            if (legalitySettings.canKingCapture && legalitySettings.canKingCapture > 0 && this.board[attackedX][attackedY].color + 1 === legalitySettings.canKingCapture)\r\n                                continue;\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (attackers > 1) {\r\n                return isRoyalMove ? targetSafety || Boolean(legalitySettings.canKingCapture) : Boolean(legalitySettings.canKingCapture);\r\n            }\r\n            else if (attackers === 1) {\r\n                if (!isRoyalMove) {\r\n                    if (this.preGeneratedAttacks.hoppingPieces[royalI][royalJ] === 1) {\r\n                        for (const [attackingPiece, attackCoordinates] of this.preGeneratedAttacks.hoppingPieceLines) {\r\n                            if (attackCoordinates[0] === royalI && attackCoordinates[1] === royalJ\r\n                                && attackingPiece[0] === attackI && attackingPiece[1] === attackJ) {\r\n                                return true;\r\n                            }\r\n                        }\r\n                        return Boolean(legalitySettings.canKingCapture);\r\n                    }\r\n                    else {\r\n                        for (const [attackingPiece, attackLine] of this.preGeneratedAttacks.slidingPiecesLines) {\r\n                            let isRoyalUnderAttack = false, isTheTargetSquareBlocked = false;\r\n                            for (const [attackedX, attackedY] of attackLine) {\r\n                                if (!isRoyalUnderAttack && attackedX === royalI && attackedY === royalJ)\r\n                                    isRoyalUnderAttack = true;\r\n                                else if (!isTheTargetSquareBlocked && !isRoyalUnderAttack &&\r\n                                    attackedX === attackI && attackedY === attackJ)\r\n                                    isTheTargetSquareBlocked = true;\r\n                                if (isRoyalUnderAttack && !compareCoordinates(attackingPiece, moveData.endCoordinates) && !isTheTargetSquareBlocked) {\r\n                                    if (legalitySettings.canKingCapture && legalitySettings.canKingCapture > 0 && this.board[attackedX][attackedY].color + 1 === legalitySettings.canKingCapture)\r\n                                        continue;\r\n                                    return Boolean(legalitySettings.canKingCapture);\r\n                                }\r\n                            }\r\n                        }\r\n                        return true;\r\n                    }\r\n                }\r\n                else {\r\n                    return targetSafety || Boolean(legalitySettings.canKingCapture);\r\n                }\r\n            }\r\n            else {\r\n                return isRoyalMove ? targetSafety || Boolean(legalitySettings.canKingCapture) : true;\r\n            }\r\n        }\r\n    }\r\n    getLegalMoves(i, j, baseColor = this.data.sideToMove, isSeirawanDrop = false) {\r\n        const pieceString = this.board[i]?.[j];\r\n        if (pieceString.isPiece()) {\r\n            const color = pieceString.color;\r\n            const controlSetting = pieceControlConfigSettings[pieceString.piece];\r\n            if (color !== baseColor)\r\n                return [];\r\n            const data = this.data;\r\n            const pseudoLegalMoves = this.preGeneratedAttacks.pieceMovements.get(stringifyCoordinate([i, j]));\r\n            if (!pseudoLegalMoves)\r\n                throw new Error(\"Pseudo-legal moves are expected to be pregenerated during attack pre-generation for \" + [i, j].join(\",\"));\r\n            const specialMoves = [];\r\n            const royal = this.data.fenOptions.royal[baseColor];\r\n            if (royal && royal[0] === i && royal[1] === j) {\r\n                if (data.fenOptions.isKingsideCastlingAvailable(baseColor, this)) {\r\n                    specialMoves.push({\r\n                        startCoordinates: [i, j],\r\n                        endCoordinates: data.fenOptions.getKingsideCastlingEndCoordinate(baseColor),\r\n                        specialType: SpecialMove.CastlingKingside\r\n                    });\r\n                }\r\n                if (data.fenOptions.isQueensideCastlingAvailable(baseColor, this)) {\r\n                    specialMoves.push({\r\n                        startCoordinates: [i, j],\r\n                        endCoordinates: data.fenOptions.getQueensideCastlingEndCoordinate(baseColor),\r\n                        specialType: SpecialMove.CastlingQueenside\r\n                    });\r\n                }\r\n            }\r\n            if (controlSetting.moveGenerationSettings.isPawn) {\r\n                const enPassantCaptures = data.fenOptions.getAvailableEnPassantCaptures(baseColor);\r\n                const pawnAttacks = this.controls[pieceString.piece]()\r\n                    .setBaseImmunePieces(this.gameType.getBaseColors(baseColor))\r\n                    .setBoard(this.board).setCoordinates(i, j).setColor(baseColor)\r\n                    .constructPieceControl().rayGenJumpingAttacks();\r\n                if (enPassantCaptures.length !== 0) {\r\n                    for (const attack of pawnAttacks) {\r\n                        for (const enP of enPassantCaptures) {\r\n                            if (compareCoordinates(attack.move, enP)) {\r\n                                const snapshot = this.createSnapshot();\r\n                                const move = [{\r\n                                        startCoordinates: [i, j],\r\n                                        endCoordinates: attack.move,\r\n                                        specialType: SpecialMove.EnPassant,\r\n                                        isIrreversible: attack.irreversible\r\n                                    }];\r\n                                if (isSeirawanDrop)\r\n                                    move.push({\r\n                                        piece: wallPieceString,\r\n                                        endCoordinates: [i, j],\r\n                                        isIrreversible: attack.irreversible\r\n                                    });\r\n                                this.makeMove(move);\r\n                                if (!this.isKingInCheck(baseColor)) {\r\n                                    specialMoves.push(move[0]);\r\n                                }\r\n                                this.loadSnapshot(snapshot);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return [...pseudoLegalMoves.map(generatedMove => {\r\n                    const moveData = {\r\n                        startCoordinates: [i, j],\r\n                        endCoordinates: generatedMove.move,\r\n                        isIrreversible: generatedMove.irreversible\r\n                    };\r\n                    if (generatedMove.move[2]) {\r\n                        moveData.promotion = generatedMove.move[2].split(\"\").map(piece => createPieceFromData(color, piece));\r\n                    }\r\n                    return moveData;\r\n                }).filter(m => {\r\n                    const capturedPieces = data.getCapturedPieces(m);\r\n                    const isKingCapture = royal && (capturedPieces.find((c) => royal[0] === c[0] && royal[1] === c[1]));\r\n                    return this.isTheMoveLegal(color, m, isSeirawanDrop) && !isKingCapture;\r\n                }), ...specialMoves];\r\n        }\r\n        else {\r\n            return [];\r\n        }\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    getDroppingMoves(_piece, _sideToMove = this.data.sideToMove) {\r\n        return [];\r\n    }\r\n    getAllowedInternalMoves(sideToMove = this.data.sideToMove) {\r\n        const currentMoves = [InternalMoveSignature.DrawByAgreement];\r\n        const currentSnapshot = this.createSnapshot();\r\n        this.makeMove([{ type: InternalMoveSignature.Resign }], true);\r\n        const maximum = Math.max(...this.data.points);\r\n        const pointIndexes = this.data.points.reduce((p, n, i) => n === maximum ? [...p, i] : p, []);\r\n        this.loadSnapshot(currentSnapshot);\r\n        if (pointIndexes.length === 1 && pointIndexes[0] === sideToMove) {\r\n            currentMoves.push(InternalMoveSignature.ClaimWin);\r\n        }\r\n        else {\r\n            currentMoves.push(InternalMoveSignature.Resign, InternalMoveSignature.Timeout);\r\n        }\r\n        return currentMoves.map(type => ({ type }));\r\n    }\r\n}\r\nexport { Board, colorEnum, baseImmunes };\r\n","import { createTupleFromCallback, verifyTupleType } from \"../../../baseTypes\";\r\nimport { initializeBoardSquares } from \"../../BaseInterfaces\";\r\nimport { totalPlayers, VariantType } from \"../GameInformation/GameData\";\r\nimport { verifyNumericColor } from \"../GameInformation/GameUnits/GameUnits\";\r\nconst baseTeams = [true, false, true, false];\r\nexport const stringifyCoordinate = (coordinate) => `${coordinate[0]}:${coordinate[1]}`;\r\nexport const unstringifyCoordinate = (coordinate) => {\r\n    const result = coordinate.split(\":\").map(v => Number(v));\r\n    if (verifyTupleType(result, 2) && result.every(n => !Number.isNaN(n))) {\r\n        return result;\r\n    }\r\n    else\r\n        throw new Error(`Unexpected stringified coordinate: ${coordinate}`);\r\n};\r\nexport const createGameTypeSettings = () => ({\r\n    type: VariantType.FFA,\r\n    teamSettings: {\r\n        firstTeamColors: baseTeams.map(e => e),\r\n        secondTeamColors: baseTeams.map(e => !e)\r\n    },\r\n    getBaseColors(color) {\r\n        if (this.isFFA()) {\r\n            return createTupleFromCallback((_, i) => i === color, totalPlayers);\r\n        }\r\n        else {\r\n            return this.teamSettings.firstTeamColors[color] ? this.teamSettings.firstTeamColors : this.teamSettings.secondTeamColors;\r\n        }\r\n    },\r\n    isFFA() {\r\n        return this.type === VariantType.FFA || this.type === VariantType.Solo;\r\n    },\r\n    isSameTeam(colorA, colorB) {\r\n        if (colorA === colorB)\r\n            return true;\r\n        if (this.isFFA()) {\r\n            return false;\r\n        }\r\n        else {\r\n            return this.teamSettings.firstTeamColors[colorA]\r\n                ? this.teamSettings.firstTeamColors[colorA] && this.teamSettings.firstTeamColors[colorA]\r\n                : this.teamSettings.secondTeamColors[colorA] && this.teamSettings.secondTeamColors[colorB];\r\n        }\r\n    },\r\n    getTeammateColor(color) {\r\n        if (this.isFFA())\r\n            return color;\r\n        const teammateIndex = this.teamSettings.firstTeamColors[color]\r\n            ? this.teamSettings.firstTeamColors.map((b, i) => b && i !== color).indexOf(true)\r\n            : this.teamSettings.secondTeamColors.map((b, i) => b && i !== color).indexOf(true);\r\n        return verifyNumericColor(teammateIndex) ? teammateIndex : color;\r\n    }\r\n});\r\nexport const createComplexMoveLegalityTracker = () => ({\r\n    hasComplexPieces: false,\r\n    hasComplexRules: false,\r\n});\r\nexport const createBasePreGeneratedAttacks = () => {\r\n    return {\r\n        hoppingPieces: initializeBoardSquares(() => 0),\r\n        slidingPieces: initializeBoardSquares(() => 0),\r\n        hoppingPieceLines: [],\r\n        slidingPiecesLines: [],\r\n        slidingPiecesRayTracing: [],\r\n        attackingColors: initializeBoardSquares(() => 0),\r\n        pieceMovements: new Map(),\r\n        pieceDrops: {\r\n            pawn: [], piece: []\r\n        }\r\n    };\r\n};\r\nexport const compareCoordinates = (coordinate1, coordinate2) => coordinate1[0] === coordinate2[0] && coordinate1[1] === coordinate2[1];\r\n","import { verifyDroppingMove, verifyInternalMove, verifyStandardMove } from \"../MoveTree/MoveTree\";\r\nimport { compareMoves, SpecialMove } from \"../MoveTree/MoveTreeInterface\";\r\nexport function validateBoardMove(board, move) {\r\n    let startingMoves;\r\n    const firstMove = move[0];\r\n    if (verifyStandardMove(firstMove)) {\r\n        startingMoves = board.getLegalMoves(firstMove.startCoordinates[0], firstMove.startCoordinates[1]);\r\n    }\r\n    else if (verifyDroppingMove(firstMove)) {\r\n        startingMoves = board.getDroppingMoves(firstMove.piece);\r\n    }\r\n    else if (verifyInternalMove(firstMove)) {\r\n        startingMoves = board.getAllowedInternalMoves();\r\n    }\r\n    else\r\n        throw new Error(`Unexpected move signature encountered: ${JSON.stringify(move)}`);\r\n    const specialMoveSettings = {\r\n        hasEnPassant: false\r\n    };\r\n    if (board.variantData.duckChess && move.length === 1)\r\n        return false;\r\n    for (const moveComponent of move) {\r\n        const move = startingMoves.find(legalMove => compareMoves(legalMove, moveComponent));\r\n        if (!move)\r\n            return false;\r\n        if (verifyStandardMove(move) && move.specialType === SpecialMove.EnPassant) {\r\n            specialMoveSettings.hasEnPassant = true;\r\n        }\r\n        if (move.nextChainedMoves) {\r\n            startingMoves = move.nextChainedMoves;\r\n        }\r\n    }\r\n    return specialMoveSettings;\r\n}\r\n","import { createDefaultArmyDeathSettings, createDefaultFENEffectSettings } from \"./FENDataInterface\";\r\nimport { InternalMoveSignature, SpecialMove } from \"../MoveTree/MoveTreeInterface\";\r\nimport { ZombieType } from \"../VariantRule/Zombies/ZombieInterface\";\r\nimport { createTupleFromCallback, createTuple, throwOnNever } from \"../../../baseTypes\";\r\nimport { colors, getPlayerNameFromColor, totalPlayers, verifyDrawingTermination, verifyWinningTermination } from \"../GameInformation/GameData\";\r\nimport { createPieceFromData, emptyPieceString, deadColorIndex, nonPlayablePieces } from \"../GameInformation/GameUnits/PieceString\";\r\nimport { verifyDroppingMove, verifyInternalMove, verifyStandardMove } from \"../MoveTree/MoveTree\";\r\nimport { pieceControlConfigSettings } from \"@moveGeneration/PieceControl/PieceControlInterface\";\r\nimport { compareCoordinates } from \"../Board/BoardInterface\";\r\nimport { verifyNumericColor } from \"../GameInformation/GameUnits/GameUnits\";\r\nclass FENOptions {\r\n    dead = [false, false, false, false];\r\n    resigned = [false, false, false, false];\r\n    enPassant = [null, null, null, null];\r\n    castleKingside = [true, true, true, true];\r\n    castleQueenside = [true, true, true, true];\r\n    castleWith = \"R\";\r\n    boxOffset = 0;\r\n    zombieType = [ZombieType.Rando, ZombieType.Rando, ZombieType.Rando, ZombieType.Rando];\r\n    zombieImmune = [false, false, false, false];\r\n    pawnBaseRank = 2;\r\n    wb = false;\r\n    dim = [14, 14];\r\n    noCorners = false;\r\n    royal = [null, null, null, null];\r\n    lives = [null, null, null, null];\r\n    bank = createTupleFromCallback(() => new Map(), totalPlayers);\r\n    promotedFrom = new Map();\r\n    setupPoints = null;\r\n    setupComplete = [true, true, true, true];\r\n    seirawanDrops = createTupleFromCallback(() => new Set(), totalPlayers);\r\n    castlingKingsideData = createTupleFromCallback(() => ({ endCoordinates: -1, pieceCoordinates: -1, pieceEndCoordinates: -1, checkSquares: [] }), totalPlayers);\r\n    castlingQueensideData = createTupleFromCallback(() => ({ endCoordinates: -1, pieceCoordinates: -1, pieceEndCoordinates: -1, checkSquares: [] }), totalPlayers);\r\n    hasZombies = false;\r\n    areBanksEnabled = [false, false, false, false];\r\n    createClone() {\r\n        const newOptions = new FENOptions();\r\n        newOptions.dead = [...this.dead];\r\n        newOptions.resigned = [...this.resigned];\r\n        newOptions.castleWith = this.castleWith;\r\n        newOptions.boxOffset = this.boxOffset;\r\n        newOptions.zombieType = this.zombieType;\r\n        newOptions.zombieImmune = this.zombieImmune;\r\n        newOptions.pawnBaseRank = this.pawnBaseRank;\r\n        newOptions.wb = this.wb;\r\n        newOptions.dim = this.dim;\r\n        newOptions.enPassant = this.enPassant.map(e => e ? [[...e[0]], [...e[1]]] : e);\r\n        newOptions.castleKingside = [...this.castleKingside];\r\n        newOptions.castleQueenside = [...this.castleQueenside];\r\n        newOptions.royal = this.royal.map(r => r ? [...r] : r);\r\n        newOptions.lives = [...this.lives];\r\n        newOptions.bank = [...this.bank.map((m) => new Map(m))];\r\n        newOptions.promotedFrom = new Map(this.promotedFrom);\r\n        newOptions.setupComplete = [...this.setupComplete];\r\n        newOptions.setupPoints = this.setupPoints ? [...this.setupPoints] : this.setupPoints;\r\n        newOptions.seirawanDrops = [...this.seirawanDrops.map((s) => new Set(s))];\r\n        newOptions.areBanksEnabled = [...this.areBanksEnabled];\r\n        return newOptions;\r\n    }\r\n    createSnapshot() {\r\n        const newEnPassant = createTuple(null, totalPlayers);\r\n        this.enPassant.forEach((enPassant, i) => {\r\n            newEnPassant[i] = enPassant ? [[...enPassant[0]], [...enPassant[1]]] : enPassant;\r\n        });\r\n        return {\r\n            dead: [...this.dead], resigned: [...this.resigned], enPassant: newEnPassant,\r\n            castleKingside: [...this.castleKingside], castleQueenside: [...this.castleQueenside],\r\n            royal: this.royal.map(r => r ? [...r] : r), lives: [...this.lives],\r\n            bank: this.bank.map(m => new Map(m)), promotedFrom: new Map(this.promotedFrom),\r\n            setupPoints: this.setupPoints === null ? null : [...this.setupPoints],\r\n            setupComplete: [...this.setupComplete], seirawanDrops: this.seirawanDrops.map(s => new Set(s))\r\n        };\r\n    }\r\n    loadSnapshot(snapshot) {\r\n        let key;\r\n        for (key in snapshot) {\r\n            if (Object.prototype.hasOwnProperty.call(snapshot, key)) {\r\n                this.setProperty(key, snapshot[key]);\r\n            }\r\n        }\r\n    }\r\n    setProperty(prop, value) {\r\n        this[prop] = value;\r\n    }\r\n    generateCastling(board) {\r\n        let [dimensionRY, dimensionBG] = this.dim;\r\n        if (!this.noCorners) {\r\n            if (dimensionRY > 8)\r\n                dimensionRY = 8;\r\n            if (dimensionBG > 8)\r\n                dimensionBG = 8;\r\n        }\r\n        const dimensions = [dimensionRY, dimensionBG, dimensionRY, dimensionBG];\r\n        const royalRanks = this.royal.map((r, i) => r ? r[i % 2 === 0 ? 0 : 1] : r);\r\n        const royalCoordinates = this.royal.map((r, i) => r ? r[i % 2 === 0 ? 1 : 0] : r);\r\n        const kingsideCastlePieceCoordinate = [];\r\n        const queensideCastlePieceCoordinate = [];\r\n        const boardSquares = board.board;\r\n        for (let i = 0; i < this.royal.length; i++) {\r\n            const royalCoordinateI = royalCoordinates[i];\r\n            const royalRanksI = royalRanks[i];\r\n            if (royalCoordinateI === null || royalRanksI === null) {\r\n                kingsideCastlePieceCoordinate.push(-1);\r\n                queensideCastlePieceCoordinate.push(-1);\r\n                continue;\r\n            }\r\n            const condition = i % 2 === 0;\r\n            for (let j = royalCoordinateI; j < 14; j++) {\r\n                const pieceString = boardSquares[condition ? royalRanksI : j][condition ? j : royalRanksI];\r\n                if (!pieceString.isEmpty() && pieceString.piece === this.castleWith) {\r\n                    kingsideCastlePieceCoordinate.push(j);\r\n                    break;\r\n                }\r\n                else if (j === 13) {\r\n                    kingsideCastlePieceCoordinate.push(-1);\r\n                }\r\n            }\r\n            for (let j = royalCoordinateI; j > -1; j--) {\r\n                const pieceString = boardSquares[condition ? royalRanksI : j][condition ? j : royalRanksI];\r\n                if (!pieceString.isEmpty() && pieceString.piece === this.castleWith) {\r\n                    queensideCastlePieceCoordinate.push(j);\r\n                    break;\r\n                }\r\n                else if (j === 0) {\r\n                    queensideCastlePieceCoordinate.push(-1);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        for (let i = 0; i < this.royal.length; i++) {\r\n            const royalCoordinate = royalCoordinates[i];\r\n            if (royalCoordinate === null)\r\n                continue;\r\n            const d = dimensions[i] - 6 < 1 ? 1 : dimensions[i] - 6;\r\n            if (kingsideCastlePieceCoordinate[i] === -1) {\r\n                this.castleKingside[i] = false;\r\n            }\r\n            else {\r\n                const kArr = [...Array(kingsideCastlePieceCoordinate[i] - royalCoordinate - 1).keys()];\r\n                const endCoordinates = royalCoordinate + d;\r\n                const castlingData = {\r\n                    endCoordinates, checkSquares: kArr.map(j => j + royalCoordinate + 1),\r\n                    pieceCoordinates: kingsideCastlePieceCoordinate[i], pieceEndCoordinates: endCoordinates - 1\r\n                };\r\n                if (royalCoordinate <= 6) {\r\n                    this.castlingQueensideData[i] = castlingData;\r\n                }\r\n                else {\r\n                    this.castlingKingsideData[i] = castlingData;\r\n                }\r\n            }\r\n            if (queensideCastlePieceCoordinate[i] === -1) {\r\n                this.castleQueenside[i] = false;\r\n            }\r\n            else {\r\n                const qArr = [...Array(royalCoordinate - queensideCastlePieceCoordinate[i] - 1).keys()];\r\n                const endCoordinates = royalCoordinate - d;\r\n                const castlingData = {\r\n                    endCoordinates, checkSquares: royalCoordinate <= 6 ? qArr.map(j => j + royalCoordinate - 2) : qArr.map(j => j + royalCoordinate - 3),\r\n                    pieceCoordinates: queensideCastlePieceCoordinate[i], pieceEndCoordinates: endCoordinates + 1\r\n                };\r\n                if (royalCoordinate <= 6) {\r\n                    this.castlingKingsideData[i] = castlingData;\r\n                }\r\n                else {\r\n                    this.castlingQueensideData[i] = castlingData;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    isCastlingAvailable(player, board, checks) {\r\n        const royal = this.royal[player];\r\n        if (royal === null)\r\n            return false;\r\n        const royalCoordinate = royal[player % 2 === 0 ? 0 : 1];\r\n        const squares = board.board;\r\n        for (const checkSquare of checks) {\r\n            const coordinateA = player % 2 === 0 ? royalCoordinate : checkSquare;\r\n            const coordinateB = player % 2 === 0 ? checkSquare : royalCoordinate;\r\n            if (!squares[coordinateA][coordinateB].isEmpty() ||\r\n                board.preGeneratedAttacks.hoppingPieces[coordinateA][coordinateB] > 0 ||\r\n                board.preGeneratedAttacks.slidingPieces[coordinateA][coordinateB] > 0)\r\n                return false;\r\n        }\r\n        if (board.isKingInCheck(player))\r\n            return false;\r\n        return true;\r\n    }\r\n    isKingsideCastlingAvailable(player, board) {\r\n        if (!this.castleKingside[player])\r\n            return false;\r\n        if (this.castlingKingsideData[player].endCoordinates === -1) {\r\n            this.generateCastling(board);\r\n        }\r\n        return this.isCastlingAvailable(player, board, this.castlingKingsideData[player].checkSquares);\r\n    }\r\n    isQueensideCastlingAvailable(player, board) {\r\n        if (!this.castleQueenside[player])\r\n            return false;\r\n        if (this.castlingQueensideData[player].endCoordinates === -1) {\r\n            this.generateCastling(board);\r\n        }\r\n        return this.isCastlingAvailable(player, board, this.castlingQueensideData[player].checkSquares);\r\n    }\r\n    getCastlingEndCoordinate(player, coordinates) {\r\n        if (!coordinates)\r\n            throw new TypeError(`Calling an end castling coordinate array before castling data generated`);\r\n        const royalCoordinate = this.royal[player]?.[player % 2 === 0 ? 0 : 1];\r\n        if (royalCoordinate === undefined)\r\n            throw new TypeError(`End castling coordinate accessed while royal is undefined`);\r\n        const coordinateA = player % 2 === 0 ? royalCoordinate : coordinates;\r\n        const coordinateB = player % 2 === 0 ? coordinates : royalCoordinate;\r\n        return [coordinateA, coordinateB];\r\n    }\r\n    getKingsideCastlingEndCoordinate(player) { return this.getCastlingEndCoordinate(player, this.castlingKingsideData[player].endCoordinates); }\r\n    getQueensideCastlingEndCoordinate(player) { return this.getCastlingEndCoordinate(player, this.castlingQueensideData[player].endCoordinates); }\r\n    getKingsideCastlingPieceEndCoordinate(player) { return this.getCastlingEndCoordinate(player, this.castlingKingsideData[player].pieceEndCoordinates); }\r\n    getQueensideCastlingPieceEndCoordinate(player) { return this.getCastlingEndCoordinate(player, this.castlingQueensideData[player].pieceEndCoordinates); }\r\n    getKingsideCastlingTandemPiece(player) { return this.castlingKingsideData[player].pieceCoordinates; }\r\n    getQueensideCastlingTandemPiece(player) { return this.castlingQueensideData[player].pieceCoordinates; }\r\n    getAvailableEnPassantCaptures(baseColor) {\r\n        const coordinates = [];\r\n        this.enPassant.forEach((enPassant, i) => {\r\n            if (i === baseColor)\r\n                return;\r\n            if (enPassant)\r\n                coordinates.push(enPassant[0]);\r\n        });\r\n        return coordinates.map(e => [...e]);\r\n    }\r\n    enableZombies() { this.hasZombies = true; }\r\n    isZombies() { return this.hasZombies; }\r\n    isPlayerZombie(player) {\r\n        return this.hasZombies && this.resigned[player];\r\n    }\r\n}\r\nconst defaultPointsForMate = 20;\r\nclass FENData {\r\n    points;\r\n    sideToMove;\r\n    fenOptions;\r\n    plyCount;\r\n    board;\r\n    privateGameOver = false;\r\n    constructor() {\r\n        this.points = [0, 0, 0, 0];\r\n        this.sideToMove = 0;\r\n        this.fenOptions = new FENOptions();\r\n        this.plyCount = 0;\r\n    }\r\n    get gameOver() {\r\n        return this.privateGameOver;\r\n    }\r\n    set gameOver(gameOver) {\r\n        if (gameOver === false || this.privateGameOver === false) {\r\n            this.privateGameOver = gameOver;\r\n        }\r\n    }\r\n    injectBoard(board) {\r\n        this.board = board;\r\n        this.fenOptions.generateCastling(board);\r\n    }\r\n    createClone() {\r\n        const newFENData = new FENData();\r\n        newFENData.fenOptions = this.fenOptions.createClone();\r\n        newFENData.points = [...this.points];\r\n        newFENData.sideToMove = this.sideToMove;\r\n        newFENData.plyCount = this.plyCount;\r\n        return newFENData;\r\n    }\r\n    createSnapshot() {\r\n        return {\r\n            points: [...this.points],\r\n            sideToMove: this.sideToMove,\r\n            fenOptionsSnapshot: this.fenOptions.createSnapshot(),\r\n            plyCount: this.plyCount,\r\n            gameOver: this.gameOver\r\n        };\r\n    }\r\n    loadSnapshot(snapshot) {\r\n        this.fenOptions.loadSnapshot(snapshot.fenOptionsSnapshot);\r\n        this.points = snapshot.points;\r\n        this.sideToMove = snapshot.sideToMove;\r\n        this.plyCount = snapshot.plyCount;\r\n        this.privateGameOver = snapshot.gameOver;\r\n    }\r\n    getCapturedPieces(moveData) {\r\n        const pieceString = this.board.board[moveData.endCoordinates[0]][moveData.endCoordinates[1]];\r\n        return pieceString.isEmpty() || pieceString.isDead() ? [] : [[...moveData.endCoordinates]];\r\n    }\r\n    processStandardMove(moveData) {\r\n        const { startCoordinates: [startI, startJ], endCoordinates: [endI, endJ], promotion } = moveData;\r\n        const endPiece = this.board.board[endI][endJ];\r\n        const piece = promotion?.[0] ?? this.board.board[startI][startJ];\r\n        const capturedPieces = this.getCapturedPieces(moveData);\r\n        this.board.board[endI][endJ] = piece;\r\n        this.board.board[startI][startJ] = emptyPieceString;\r\n        for (const coordinate of capturedPieces) {\r\n            if (!compareCoordinates(coordinate, moveData.endCoordinates)\r\n                || compareCoordinates(coordinate, moveData.startCoordinates)) {\r\n                this.board.board[coordinate[0]][coordinate[1]] = emptyPieceString;\r\n            }\r\n        }\r\n        if (\"specialType\" in moveData) {\r\n            const type = moveData.specialType;\r\n            switch (type) {\r\n                case SpecialMove.CastlingKingside: {\r\n                    const secondKPiece = this.sideToMove % 2 === 0\r\n                        ? this.board.board[startI][this.fenOptions.getKingsideCastlingTandemPiece(this.sideToMove)]\r\n                        : this.board.board[this.fenOptions.getKingsideCastlingTandemPiece(this.sideToMove)][startJ];\r\n                    const [kI, kJ] = this.fenOptions.getKingsideCastlingPieceEndCoordinate(this.sideToMove);\r\n                    if (this.sideToMove % 2 === 0) {\r\n                        this.board.board[kI][kJ] = secondKPiece;\r\n                        this.board.board[startI][this.fenOptions.getKingsideCastlingTandemPiece(this.sideToMove)] = emptyPieceString;\r\n                    }\r\n                    else {\r\n                        this.board.board[kI][kJ] = secondKPiece;\r\n                        this.board.board[this.fenOptions.getKingsideCastlingTandemPiece(this.sideToMove)][startJ] = emptyPieceString;\r\n                    }\r\n                    break;\r\n                }\r\n                case SpecialMove.CastlingQueenside: {\r\n                    const secondQPiece = this.sideToMove % 2 === 0\r\n                        ? this.board.board[startI][this.fenOptions.getQueensideCastlingTandemPiece(this.sideToMove)]\r\n                        : this.board.board[this.fenOptions.getQueensideCastlingTandemPiece(this.sideToMove)][startJ];\r\n                    const [qI, qJ] = this.fenOptions.getQueensideCastlingPieceEndCoordinate(this.sideToMove);\r\n                    if (this.sideToMove % 2 === 0) {\r\n                        this.board.board[qI][qJ] = secondQPiece;\r\n                        this.board.board[startI][this.fenOptions.getQueensideCastlingTandemPiece(this.sideToMove)] = emptyPieceString;\r\n                    }\r\n                    else {\r\n                        this.board.board[qI][qJ] = secondQPiece;\r\n                        this.board.board[this.fenOptions.getQueensideCastlingTandemPiece(this.sideToMove)][startJ] = emptyPieceString;\r\n                    }\r\n                    break;\r\n                }\r\n                default:\r\n                    if (type === undefined || !(type in SpecialMove)) {\r\n                        console.error(`Unknown special move constant: ${String(type)}`);\r\n                    }\r\n            }\r\n        }\r\n        this.fenOptions.royal = this.fenOptions.royal.map((r, i) => {\r\n            if (r) {\r\n                if (r[0] === startI && r[1] === startJ) {\r\n                    this.fenOptions.castleKingside[i] = false;\r\n                    this.fenOptions.castleQueenside[i] = false;\r\n                    return [endI, endJ];\r\n                }\r\n                else\r\n                    return [...r];\r\n            }\r\n            else\r\n                return null;\r\n        });\r\n        return { endPiece: endPiece.isEmpty() ? [] : [endPiece] };\r\n    }\r\n    spreadPointsBetweenPlayersEvenly() {\r\n        const realPlayers = this.fenOptions.resigned.reduce((p, n, i) => p + Number(n || this.fenOptions.dead[i]), 0);\r\n        const individualPoints = Math.ceil(this.obtainPointsForMate() / realPlayers);\r\n        for (const color of colors) {\r\n            if (!this.fenOptions.dead[color]) {\r\n                this.assignPoints(color, individualPoints);\r\n            }\r\n        }\r\n    }\r\n    branchBetweenResignationMoves(move, sideToMove) {\r\n        const playerName = getPlayerNameFromColor(sideToMove).toUpperCase();\r\n        switch (move) {\r\n            case InternalMoveSignature.Resign:\r\n                this.gameOver = `${playerName} RESIGNED!`;\r\n                break;\r\n            case InternalMoveSignature.Timeout:\r\n                this.gameOver = `${playerName} FORFEITS ON TIME!`;\r\n                break;\r\n            case InternalMoveSignature.ClaimWin:\r\n                this.gameOver = `${playerName} CLAIMED THE WIN!`;\r\n                break;\r\n            default:\r\n                throwOnNever(move);\r\n        }\r\n    }\r\n    processInternalMove(internalMove) {\r\n        const stalemates = createTuple(false, totalPlayers);\r\n        const insufficientMaterial = this.board.insufficientMaterialModule?.(this.board)?.every((b, i) => {\r\n            if (i === this.sideToMove) {\r\n                return b;\r\n            }\r\n            else {\r\n                return b || this.fenOptions.dead[i];\r\n            }\r\n        });\r\n        switch (internalMove.type) {\r\n            case InternalMoveSignature.Stalemate:\r\n                this.fenOptions.dead[this.sideToMove] = true;\r\n                stalemates[this.sideToMove] = true;\r\n                break;\r\n            case InternalMoveSignature.Resign:\r\n            case InternalMoveSignature.Timeout:\r\n                if (insufficientMaterial) {\r\n                    this.assignGeneralTermination(\"Timeout vs Insufficient Material\");\r\n                }\r\n            // * Fallthrough\r\n            case InternalMoveSignature.ClaimWin: {\r\n                this.fenOptions.resigned[this.sideToMove] = true;\r\n                this.turnPiecesDead(this.sideToMove, { ...createDefaultArmyDeathSettings(), excludeRoyals: true, doNotSetDead: true });\r\n                const deadPlayers = this.fenOptions.dead.map((d, i) => d || this.fenOptions.resigned[i]).filter(Boolean);\r\n                let isResignationOver = deadPlayers.length === totalPlayers - 1;\r\n                if (insufficientMaterial) {\r\n                    this.spreadPointsBetweenPlayersEvenly();\r\n                }\r\n                else if (deadPlayers.length === totalPlayers - 1) {\r\n                    const alivePlayer = deadPlayers.findIndex(d => !d);\r\n                    if (verifyNumericColor(alivePlayer)) {\r\n                        this.assignPoints(alivePlayer, this.countTotalPointsOnBoard()\r\n                            .reduce((p, n, i) => p + (i === alivePlayer ? n : 0), 0));\r\n                        isResignationOver = true;\r\n                    }\r\n                }\r\n                else if (!this.board.gameType.isFFA()) {\r\n                    isResignationOver = true;\r\n                }\r\n                if (isResignationOver) {\r\n                    this.branchBetweenResignationMoves(internalMove.type, this.sideToMove);\r\n                }\r\n                break;\r\n            }\r\n            case InternalMoveSignature.DrawByAgreement:\r\n                this.gameOver = \"- AGREED.\";\r\n                break;\r\n            case InternalMoveSignature.Pass:\r\n                break;\r\n            case InternalMoveSignature.TeamsCheckmate: {\r\n                this.gameOver = `CHECKMATE  ${this.getCurrentResult()}`;\r\n                this.turnPiecesDead(this.sideToMove);\r\n                this.turnPiecesDead(this.board.gameType.getTeammateColor(this.sideToMove));\r\n                break;\r\n            }\r\n            default:\r\n                throwOnNever(internalMove.type);\r\n        }\r\n        return { stalemates };\r\n    }\r\n    processDroppingMove(move) {\r\n        if (!this.board.variantData.duckChess && !this.fenOptions.areBanksEnabled[this.sideToMove])\r\n            return;\r\n        const bank = this.fenOptions.bank[this.sideToMove];\r\n        const pieceStringReference = [...bank.keys()].find(pieceString => pieceString.piece === move.piece.piece);\r\n        if (!pieceStringReference && !this.board.variantData.duckChess && move.piece.piece !== nonPlayablePieces.duck)\r\n            return;\r\n        const safeReference = pieceStringReference ?? move.piece;\r\n        this.board.board[move.endCoordinates[0]][move.endCoordinates[1]] = move.piece;\r\n        if (!this.fenOptions.setupComplete[this.sideToMove])\r\n            return;\r\n        const bankPieceCount = bank.get(safeReference);\r\n        if (bankPieceCount == 1) {\r\n            bank.delete(safeReference);\r\n        }\r\n        else if (bankPieceCount) {\r\n            bank.set(safeReference, bankPieceCount - 1);\r\n        }\r\n    }\r\n    turnPiecesDead(color, settings = createDefaultArmyDeathSettings()) {\r\n        const royal = this.fenOptions.royal[color];\r\n        if (!settings.doNotSetDead) {\r\n            this.fenOptions.dead[color] = true;\r\n            this.fenOptions.royal[color] = null;\r\n        }\r\n        for (const coordinate of this.board.getPlayerPieces()[color]) {\r\n            if (settings.excludeRoyals && royal && compareCoordinates(coordinate, royal))\r\n                continue;\r\n            const piece = this.board.board[coordinate[0]][coordinate[1]].piece;\r\n            if (settings.onlyPawns && !pieceControlConfigSettings[piece].moveGenerationSettings.isPawn)\r\n                continue;\r\n            this.board.board[coordinate[0]][coordinate[1]] =\r\n                createPieceFromData(deadColorIndex, this.board.board[coordinate[0]][coordinate[1]].piece);\r\n        }\r\n    }\r\n    getKingCaptures() {\r\n        const kingCaptures = createTuple(false, totalPlayers);\r\n        for (const color of colors) {\r\n            const royalCoordinate = this.fenOptions.royal[color];\r\n            if (!royalCoordinate)\r\n                continue;\r\n            const pieceString = this.board.board[royalCoordinate[0]][royalCoordinate[1]];\r\n            if (pieceString.isEmpty() || pieceString.color !== color) {\r\n                kingCaptures[color] = true;\r\n            }\r\n        }\r\n        return kingCaptures;\r\n    }\r\n    processPointsForChecks(currentChecks) {\r\n        const sideToMove = this.sideToMove;\r\n        this.board.pregenerateAttacks();\r\n        const updatedChecks = this.board.getCurrentChecks();\r\n        const playerChecks = createTuple(false, totalPlayers);\r\n        for (const color of colors) {\r\n            for (const coordinate of updatedChecks[color]) {\r\n                if (!currentChecks[color].has(coordinate)) {\r\n                    playerChecks[color] = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        const checkedPlayers = playerChecks.filter(Boolean).length;\r\n        if (checkedPlayers === 2) {\r\n            this.assignPoints(sideToMove, 1);\r\n        }\r\n        else if (checkedPlayers === 3) {\r\n            this.assignPoints(sideToMove, 5);\r\n        }\r\n    }\r\n    affectOptions(move, settings = createDefaultFENEffectSettings()) {\r\n        let moveStalemates;\r\n        let endSquare;\r\n        const currentChecks = this.board.getCurrentChecks().map(arr => new Set(arr));\r\n        if (verifyInternalMove(move)) {\r\n            moveStalemates = this.processInternalMove(move).stalemates;\r\n        }\r\n        else if (verifyStandardMove(move)) {\r\n            endSquare = this.processStandardMove(move).endPiece;\r\n        }\r\n        else if (verifyDroppingMove(move)) {\r\n            this.processDroppingMove(move);\r\n        }\r\n        const { checkmates, stalemates, checks } = settings.ignoreCheckmateChecks ? {\r\n            checkmates: createTuple(false, totalPlayers), checks: createTuple(false, totalPlayers), stalemates: createTuple(false, totalPlayers)\r\n        } : this.board.getCheckmatesAndStalemates();\r\n        if (moveStalemates) {\r\n            for (let i = 0; i < totalPlayers; i++) {\r\n                if (moveStalemates[i]) {\r\n                    stalemates[i] = true;\r\n                }\r\n            }\r\n        }\r\n        const totalMateSum = checkmates.reduce((p, n) => n ? p + this.obtainPointsForMate() : p, 0);\r\n        const boardAlternations = {\r\n            pointDistribution: {\r\n                checkmatePoints: checkmates.map((_, i) => i === this.sideToMove ? totalMateSum : 0),\r\n                pieceCapturingPoints: createTuple(0, totalPlayers)\r\n            }\r\n        };\r\n        if (endSquare) {\r\n            for (const piece of endSquare) {\r\n                boardAlternations.pointDistribution.pieceCapturingPoints[this.sideToMove] = this.getPointsForPiece(piece);\r\n            }\r\n        }\r\n        const kingCaptures = this.getKingCaptures();\r\n        if (this.board.gameType.isFFA()) {\r\n            for (const color of colors) {\r\n                if (this.fenOptions.dead[color] || this.fenOptions.resigned[color]) {\r\n                    continue;\r\n                }\r\n                if (checkmates[color] || (color === this.sideToMove && stalemates[color])) {\r\n                    this.turnPiecesDead(color);\r\n                    continue;\r\n                }\r\n                this.assignPoints(color, boardAlternations.pointDistribution.checkmatePoints[color]\r\n                    + boardAlternations.pointDistribution.pieceCapturingPoints[color]);\r\n            }\r\n        }\r\n        else {\r\n            for (const color of colors) {\r\n                if (kingCaptures[color]) {\r\n                    this.turnPiecesDead(color);\r\n                    this.assignGeneralTermination(\"King Captured\");\r\n                }\r\n            }\r\n        }\r\n        const realPlayers = this.getRealPlayers();\r\n        const isOver = this.board.gameType.isFFA() ? realPlayers === 1 : realPlayers !== totalPlayers;\r\n        if (isOver)\r\n            this.assignGeneralTermination(\"Checkmate\");\r\n        if (!settings.ignoreNextTurn && !isOver) {\r\n            this.processPointsForChecks(currentChecks);\r\n            const insufficientPieces = this.board.insufficientMaterialModule?.(this.board);\r\n            if (!this.gameOver && insufficientPieces?.every((insufficient, i) => this.fenOptions.dead[i] || insufficient)) {\r\n                this.gameOver = `INSUFFICIENT MATERIAL  ${this.getCurrentResult()}`;\r\n                this.spreadPointsBetweenPlayersEvenly();\r\n            }\r\n            if (this.getRealPlayers() > 1) {\r\n                this.sideToMove = this.nextTurn();\r\n                this.board.pregenerateAttacks();\r\n            }\r\n        }\r\n        return { checkmates, stalemates, checks };\r\n    }\r\n    constructPreliminaryHashString() {\r\n        let builder = '';\r\n        builder += this.sideToMove;\r\n        builder = this.fenOptions.castleKingside.reduce((p, n) => p + (n ? '1' : '0'), builder);\r\n        builder = this.fenOptions.castleQueenside.reduce((p, n) => p + (n ? '1' : '0'), builder);\r\n        builder = this.fenOptions.lives.reduce((p, n) => `${p}${n ?? ''}`, builder);\r\n        builder = this.fenOptions.dead.reduce((p, n) => p + (n ? '1' : '0'), builder);\r\n        builder = this.fenOptions.resigned.reduce((p, n) => p + (n ? '1' : '0'), builder);\r\n        builder = this.fenOptions.resigned.reduce((p, n) => p + (n ? '1' : '0'), builder);\r\n        builder = this.fenOptions.enPassant[this.sideToMove] ? this.fenOptions.enPassant.reduce((p, n) => `${p}${String(n)}`, builder) : builder;\r\n        builder = this.fenOptions.bank.reduce((p, n) => `${p}${JSON.stringify(n, (_, v) => v instanceof Map ? [...v] : v)}`, builder);\r\n        builder = this.fenOptions.seirawanDrops.reduce((p, n) => `${p}${JSON.stringify(n, (_, v) => v instanceof Set ? [...v] : v)}`, builder);\r\n        builder = this.board.board.reduce((p, n) => p + n.map(ps => ps.value || \"-\").join(\"\"), builder);\r\n        return builder;\r\n    }\r\n    getRealPlayers() {\r\n        let totalPlayers = 0;\r\n        for (const color of colors) {\r\n            if (this.fenOptions.resigned[color] || this.fenOptions.dead[color])\r\n                continue;\r\n            totalPlayers++;\r\n        }\r\n        return totalPlayers;\r\n    }\r\n    nextTurn(player = this.sideToMove) {\r\n        if (this.getRealPlayers() <= 1) {\r\n            throw new Error(\"Next turn called while the game is terminated\");\r\n        }\r\n        let sideToMove = player;\r\n        do {\r\n            sideToMove = (sideToMove === totalPlayers - 1 ? 0 : sideToMove + 1);\r\n        } while (this.fenOptions.dead[sideToMove] || this.fenOptions.resigned[sideToMove]);\r\n        if (verifyNumericColor(sideToMove)) {\r\n            return sideToMove;\r\n        }\r\n        else\r\n            throw new Error(`Unexpected numeric color: ${sideToMove}`);\r\n    }\r\n    previousTurn(player = this.sideToMove) {\r\n        if (this.getRealPlayers() <= 1)\r\n            throw new Error(\"Previous turn called while the game is terminated\");\r\n        let sideToMove = player;\r\n        do {\r\n            sideToMove = (sideToMove === 0 ? totalPlayers - 1 : sideToMove - 1);\r\n        } while (this.fenOptions.dead[sideToMove] || this.fenOptions.resigned[sideToMove]);\r\n        if (verifyNumericColor(sideToMove)) {\r\n            return sideToMove;\r\n        }\r\n        else\r\n            throw new Error(`Unexpected numeric color: ${sideToMove}`);\r\n    }\r\n    isComplexEvaluation() { return false; }\r\n    obtainPointsForMate() {\r\n        return defaultPointsForMate;\r\n    }\r\n    assignPoints(sideToMove, points) {\r\n        if (points > 0) {\r\n            this.points[sideToMove] += points;\r\n        }\r\n    }\r\n    getPointsForPiece(pieceString) {\r\n        if (pieceString.isPiece() && this.board.gameType.isFFA()) {\r\n            return pieceControlConfigSettings[pieceString.piece].points.singlesPoints;\r\n        }\r\n        else\r\n            return 0;\r\n    }\r\n    countTotalPointsOnBoard() {\r\n        const resultingPoints = [0, 0, 0, 0];\r\n        this.board.getPlayerPieces().forEach((army, color) => {\r\n            if (this.fenOptions.zombieImmune[color])\r\n                return;\r\n            const royal = this.fenOptions.royal[color];\r\n            for (const coordinate of army) {\r\n                if (royal && compareCoordinates(coordinate, royal)) {\r\n                    resultingPoints[color] += this.obtainPointsForMate();\r\n                }\r\n                else if (this.fenOptions.resigned[color]) {\r\n                    const piece = this.board.board[coordinate[0]][coordinate[1]].piece;\r\n                    resultingPoints[color] += pieceControlConfigSettings[piece].points.singlesPoints;\r\n                }\r\n            }\r\n        });\r\n        return resultingPoints;\r\n    }\r\n    getCurrentResult() {\r\n        if (this.board.gameType.isFFA()) {\r\n            if (!this.board.isTwoPlayer)\r\n                throw new Error(\"Result can only get called for 2P and teams\");\r\n            const max = Math.max(...this.points);\r\n            let firstAlivePlayer, maximumIndex;\r\n            for (const color of colors) {\r\n                if (this.fenOptions.dead[color] || this.fenOptions.resigned[color])\r\n                    continue;\r\n                if (this.points[color] === max) {\r\n                    if (maximumIndex === undefined) {\r\n                        maximumIndex = color;\r\n                    }\r\n                    else\r\n                        return \"-\";\r\n                }\r\n                if (firstAlivePlayer === undefined)\r\n                    firstAlivePlayer = color;\r\n            }\r\n            return firstAlivePlayer === maximumIndex ? \"1-0\" : \"0-1\";\r\n        }\r\n        else {\r\n            let result = \"-\";\r\n            for (const color of colors) {\r\n                if (this.points[color] > 0) {\r\n                    result = this.board.gameType.teamSettings.firstTeamColors[color] ? \"1-0\" : \"0-1\";\r\n                    break;\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n    assignGeneralTermination(generalTermination, sideToMove) {\r\n        if (this.board.gameType.isFFA() && !this.board.isTwoPlayer) {\r\n            if (sideToMove !== undefined) {\r\n                switch (generalTermination) {\r\n                    case \"Stalemate\":\r\n                        this.gameOver = `${getPlayerNameFromColor(sideToMove).toUpperCase()} STALEMATED!`;\r\n                        return;\r\n                }\r\n            }\r\n            if (verifyWinningTermination(generalTermination)) {\r\n                this.gameOver = `${generalTermination.toUpperCase()}!`;\r\n            }\r\n            else if (verifyDrawingTermination(generalTermination)) {\r\n                this.gameOver = `${generalTermination.toUpperCase()}`;\r\n            }\r\n            else {\r\n                throwOnNever(generalTermination);\r\n            }\r\n        }\r\n        else {\r\n            this.gameOver = `${generalTermination.toUpperCase()}  ${this.getCurrentResult()}`;\r\n        }\r\n    }\r\n}\r\nexport { FENData, FENOptions };\r\n","export const createDefaultFENEffectSettings = () => ({\r\n    ignoreCheckmateChecks: false, ignoreNextTurn: false\r\n});\r\nexport const createDefaultArmyDeathSettings = () => ({\r\n    excludeRoyals: false, onlyPawns: false, doNotSetDead: false\r\n});\r\n","import { throwOnNever } from \"@client/javascript/baseTypes\";\r\nimport { truncateNumber } from \"../../utils/NumberUtils\";\r\nexport const validateComprehensiveUnionArray = () => (arr) => arr;\r\nexport const playerNames = validateComprehensiveUnionArray()([\"Red\", \"Blue\", \"Yellow\", \"Green\", \"White\", \"Black\"]);\r\nconst individualTerminations = validateComprehensiveUnionArray()([\r\n    \"Won the Race\", \"Checkmated\", \"Stalemated\", \"Forfeits on Time\", \"Claimed the Win\", \"Resigned\"\r\n]);\r\nconst generalWinningTerminations = validateComprehensiveUnionArray()([\r\n    \"Checkmate\", \"King Captured\", \"King of the Hill\", \"Stalemate\"\r\n]);\r\nexport const verifyWinningTermination = (termination) => {\r\n    const generalWins = generalWinningTerminations;\r\n    return generalWins.includes(termination);\r\n};\r\nconst generalDrawingTerminations = validateComprehensiveUnionArray()([\r\n    \"50-move Rule\",\r\n    \"Insufficient Material\", \"Threefold Repetition\", \"Timeout vs Insufficient Material\"\r\n]);\r\nexport const verifyDrawingTermination = (termination) => {\r\n    const generalDraws = generalDrawingTerminations;\r\n    return generalDraws.includes(termination);\r\n};\r\nconst generalTerminations = validateComprehensiveUnionArray()([...generalWinningTerminations, ...generalDrawingTerminations]);\r\nconst results = validateComprehensiveUnionArray()([\"0-1\", \"1-0\", \"-\"]);\r\nexport const validateTerminationString = (termination) => {\r\n    const capitalizedTermination = termination.toUpperCase();\r\n    if (playerNames.some(str => capitalizedTermination.startsWith(str.toUpperCase()))\r\n        && individualTerminations.some(str => capitalizedTermination.endsWith(str.toUpperCase() + \"!\"))) {\r\n        return true;\r\n    }\r\n    else if (/.*?\\s\\s.*/.test(capitalizedTermination)\r\n        && generalTerminations.some(str => capitalizedTermination.startsWith(str.toUpperCase()))\r\n        && results.some(str => capitalizedTermination.endsWith(str.toUpperCase()))) {\r\n        return true;\r\n    }\r\n    else if (capitalizedTermination === \"- AGREED.\") {\r\n        return true;\r\n    }\r\n    return false;\r\n};\r\nexport const stringifyTimeControl = (timeControl) => {\r\n    const noIncrement = timeControl.increment === 0;\r\n    let timeControlString = \"\";\r\n    if (timeControl.baseTime < 60) {\r\n        timeControlString += noIncrement ? `${timeControl.baseTime * 60} sec` : `${timeControl.baseTime * 60}s`;\r\n    }\r\n    else if (timeControl.baseTime > 60 && noIncrement) {\r\n        timeControlString += `${truncateNumber(timeControl.baseTime / 60, 1)} min`;\r\n    }\r\n    else {\r\n        timeControlString += truncateNumber(timeControl.baseTime / 60, 1);\r\n    }\r\n    if (!noIncrement) {\r\n        timeControlString += \"|\";\r\n        timeControlString += timeControl.increment;\r\n    }\r\n    if (timeControl.isDelay) {\r\n        timeControlString += \"D\";\r\n    }\r\n    return timeControlString;\r\n};\r\nexport const obtainTimeControlType = (timeControl) => {\r\n    const { baseTime, increment, isDelay } = timeControl;\r\n    if (isDelay) {\r\n        const formula = baseTime / 40 + increment;\r\n        if (formula > 11.5) {\r\n            return 3 /* TimeControlType.Rapid */;\r\n        }\r\n        else if (formula <= 1.375) {\r\n            return 0 /* TimeControlType.Hyperbullet */;\r\n        }\r\n        else if (formula <= 4.5) {\r\n            return 1 /* TimeControlType.Bullet */;\r\n        }\r\n        else {\r\n            return 2 /* TimeControlType.Blitz */;\r\n        }\r\n    }\r\n    else {\r\n        const formula = baseTime / 60 + increment;\r\n        if (formula > 7.5) {\r\n            return 3 /* TimeControlType.Rapid */;\r\n        }\r\n        else if (formula <= 0.5) {\r\n            return 0 /* TimeControlType.Hyperbullet */;\r\n        }\r\n        else if (formula <= 3) {\r\n            return 1 /* TimeControlType.Bullet */;\r\n        }\r\n        else {\r\n            return 2 /* TimeControlType.Blitz */;\r\n        }\r\n    }\r\n};\r\nexport const convertCoordinateToPGN4 = (coordinate) => {\r\n    return `${String.fromCharCode(coordinate[1] + 97)}${boardDimension - coordinate[0]}`;\r\n};\r\nexport const convertCoordinateToPGN4Array = (coordinate) => {\r\n    return [String.fromCharCode(coordinate[1] + 97), boardDimension - coordinate[0]];\r\n};\r\nexport const getOppositePlacedColor = (color) => {\r\n    switch (color) {\r\n        case 0:\r\n            return 2;\r\n        case 1:\r\n            return 3;\r\n        case 2:\r\n            return 0;\r\n        case 3:\r\n            return 1;\r\n        default:\r\n            return throwOnNever(color);\r\n    }\r\n};\r\nexport const getPlayerNameFromColor = (color, wb = false) => {\r\n    switch (color) {\r\n        case 0:\r\n            return wb ? \"White\" : \"Red\";\r\n        case 1:\r\n            return \"Blue\";\r\n        case 2:\r\n            return wb ? \"Black\" : \"Yellow\";\r\n        case 3:\r\n            return \"Green\";\r\n        default:\r\n            return throwOnNever(color);\r\n    }\r\n};\r\nexport const createDefaultNumericColorAdjustment = () => ({\r\n    wb: false\r\n});\r\nexport var VariantType;\r\n(function (VariantType) {\r\n    VariantType[\"FFA\"] = \"FFA\";\r\n    VariantType[\"Teams\"] = \"Teams\";\r\n    VariantType[\"Solo\"] = \"Solo\";\r\n})(VariantType || (VariantType = {}));\r\nexport const totalPlayers = 4;\r\nexport const boardDimension = 14;\r\nexport const colors = [0, 1, 2, 3];\r\n","export const verifyNumericColor = (num) => num >= 0 && num < 4;\r\nexport const colorEnum = {\r\n    r: 0, b: 1, y: 2, g: 3\r\n};\r\nexport const verifyColorEnumValue = (value) => value in colorEnum;\r\nexport const playerEnum = {\r\n    Red: 0,\r\n    Blue: 1,\r\n    Yellow: 2,\r\n    Green: 3,\r\n    White: 0,\r\n    Black: 2\r\n};\r\nexport const verifyPlayerEnumValue = (player) => player in playerEnum;\r\nexport const stringColorEnum = {\r\n    [0]: 'r', [1]: 'b', [2]: 'y', [3]: 'g', [4]: 'd',\r\n};\r\n","import { verifyPieceLetter } from \"@moveGeneration/PieceControl/PieceControlInterface\";\r\nimport { colorEnum, stringColorEnum } from \"./GameUnits\";\r\nexport const deadColorIndex = 4;\r\nexport const nonPlayablePieces = {\r\n    wall: \"X\", transparentWall: \"x\", duck: \"\"\r\n};\r\nexport class PieceString {\r\n    _color;\r\n    _piece;\r\n    static comparePieceStrings(pieceString1, pieceString2) {\r\n        return pieceString1._piece === pieceString2._piece && pieceString1._color === pieceString2._color;\r\n    }\r\n    value;\r\n    constructor(_color, _piece) {\r\n        this._color = _color;\r\n        this._piece = _piece;\r\n        this.value = _piece.length ? /[xX]/.test(_piece) ? _piece : stringColorEnum[_color] + _piece : '';\r\n    }\r\n    isDead() { return this._color === deadColorIndex && !this.isWall(); }\r\n    isEmpty() { return this._piece.length === 0; }\r\n    isWall() { return this.value.length === 1; }\r\n    isPiece() { return this.value.length === 2 && this._color !== deadColorIndex; }\r\n    get piece() {\r\n        if (this.isEmpty())\r\n            throw new TypeError(\"Accessing a piece string piece value while the piece string is empty.\");\r\n        return this._piece;\r\n    }\r\n    get color() {\r\n        if (this.isEmpty())\r\n            throw new TypeError(\"Accessing a piece string color value while the piece string is empty.\");\r\n        return this._color;\r\n    }\r\n    getStringifiedColor() {\r\n        return this.value.charAt(0);\r\n    }\r\n}\r\nexport const createPieceFromData = (color, piece) => {\r\n    if (verifyPieceLetter(piece)) {\r\n        return new PieceString(color, piece);\r\n    }\r\n    throw new Error(\"Wrong color signature for the piece provided\");\r\n};\r\nexport const createPieceFromString = (piece) => {\r\n    const verifyColorEnum = (p) => p in colorEnum;\r\n    if (piece.length === 1 && verifyPieceLetter(piece)) {\r\n        return new PieceString(deadColorIndex, piece);\r\n    }\r\n    else {\r\n        const color = piece.charAt(0);\r\n        const pieceLetter = piece.charAt(1);\r\n        if (!verifyPieceLetter(pieceLetter))\r\n            throw new Error(\"Wrong signature for the piece provided\");\r\n        if (color === 'd') {\r\n            return new PieceString(deadColorIndex, pieceLetter);\r\n        }\r\n        else {\r\n            if (verifyColorEnum(color)) {\r\n                return new PieceString(colorEnum[color], pieceLetter);\r\n            }\r\n            else\r\n                throw new Error(\"Wrong color signature for the piece provided\");\r\n        }\r\n    }\r\n};\r\nexport const emptyPieceString = new PieceString(0, \"\");\r\nexport const wallPieceString = new PieceString(deadColorIndex, \"X\");\r\nexport const pawnPieceString = new PieceString(0, \"P\");\r\nexport const duckPieceString = new PieceString(deadColorIndex, \"\");\r\n","import { unstringifyCoordinate } from '../Board/BoardInterface';\r\nimport { SpecialMove } from './MoveTreeInterface';\r\nimport { throwOnNever } from '@client/javascript/baseTypes';\r\nimport { pawnPieceString } from '../GameInformation/GameUnits/PieceString';\r\nimport { convertCoordinateToPGN4, convertCoordinateToPGN4Array } from '../GameInformation/GameData';\r\nimport { compareArrays } from '../../utils/ArrayUtils';\r\nexport const verifyInternalMove = (move) => \"type\" in move;\r\nexport const verifyDroppingMove = (move) => \"piece\" in move;\r\nexport const verifyStandardMove = (move) => \"startCoordinates\" in move;\r\nexport const verifyInternalMoveArray = (move) => \"type\" in move[0];\r\nexport const verifyDroppingMoveArray = (move) => \"piece\" in move[0];\r\nexport const verifyStandardMoveArray = (move) => \"startCoordinates\" in move[0];\r\nexport const getLatestChainedMoves = (move) => {\r\n    if (move.length > 0 && move[0].nextChainedMoves) {\r\n        return getLatestChainedMoves(move[0].nextChainedMoves);\r\n    }\r\n    else\r\n        return move;\r\n};\r\nexport const createMoveTree = (baseSnapshot) => {\r\n    const snapshots = new WeakMap();\r\n    const boardHashes = new Map();\r\n    const moves = [];\r\n    const startingSnapshot = {\r\n        boardSnapshot: baseSnapshot,\r\n        get hash() {\r\n            throw new Error(\"Should not access hash on base move\");\r\n        },\r\n        get pregeneratedAttacks() {\r\n            throw new Error(\"Should not access pregenerated attacks on base move\");\r\n        }\r\n    };\r\n    return {\r\n        moves, currentMove: [-1],\r\n        getMove(path) {\r\n            if (moves.length === 0 || path.length === 0)\r\n                return this.moves;\r\n            const movePath = path.slice();\r\n            if (movePath[0] >= moves.length)\r\n                return;\r\n            let currentSelection = moves[movePath.shift() ?? 0];\r\n            while (movePath.length > 0) {\r\n                const currentIndex = movePath.shift();\r\n                if (currentIndex) {\r\n                    if (currentIndex >= currentSelection.alternativeLines.length)\r\n                        return;\r\n                    const alternativeLine = currentSelection.alternativeLines[currentIndex];\r\n                    const index = movePath.shift();\r\n                    if (!index) {\r\n                        return alternativeLine;\r\n                    }\r\n                    if (index >= alternativeLine.length)\r\n                        return;\r\n                    currentSelection = alternativeLine[index];\r\n                }\r\n            }\r\n            return currentSelection;\r\n        },\r\n        setNewMove(parameters) {\r\n            const { move, snapshot, fenDataString } = parameters;\r\n            const moveWrapper = this.getMove(move.path.slice(0, -1));\r\n            if (!moveWrapper)\r\n                return;\r\n            if (Array.isArray(moveWrapper)) {\r\n                moveWrapper.push(move);\r\n                snapshots.set(move, {\r\n                    boardSnapshot: snapshot.boardSnapshot,\r\n                    pregeneratedAttacks: snapshot.pregeneratedAttacks,\r\n                    hash: fenDataString\r\n                });\r\n            }\r\n            else {\r\n                moveWrapper.comment = move.comment;\r\n                moveWrapper.alternativeLines = move.alternativeLines;\r\n                moveWrapper.moveData = move.moveData;\r\n                moveWrapper.cachedNames[1 /* MoveNotation.Full */] = this.stringifyMove(moveWrapper, 1 /* MoveNotation.Full */);\r\n                moveWrapper.cachedNames[0 /* MoveNotation.Shortened */] = this.stringifyMove(moveWrapper, 0 /* MoveNotation.Shortened */);\r\n                snapshots.set(moveWrapper, {\r\n                    boardSnapshot: snapshot.boardSnapshot,\r\n                    pregeneratedAttacks: snapshot.pregeneratedAttacks,\r\n                    hash: fenDataString\r\n                });\r\n            }\r\n            const boardHash = boardHashes.get(fenDataString);\r\n            if (boardHash) {\r\n                boardHashes.set(fenDataString, boardHash + 1);\r\n            }\r\n            else {\r\n                boardHashes.set(fenDataString, 1);\r\n            }\r\n        },\r\n        getBoardSnapshot(move) {\r\n            if (move === -1) {\r\n                return startingSnapshot;\r\n            }\r\n            else {\r\n                return snapshots.get(move);\r\n            }\r\n        },\r\n        deleteMove(path) {\r\n            let items = [];\r\n            const moveWrapper = this.getMove(path.slice(0, -1));\r\n            if (!moveWrapper)\r\n                return;\r\n            const finalIndex = path[path.length - 1];\r\n            if (Array.isArray(moveWrapper)) {\r\n                items = [...moveWrapper.splice(finalIndex + 1, moveWrapper.length - (finalIndex + 1))];\r\n            }\r\n            else {\r\n                if (moveWrapper.alternativeLines.length > 0) {\r\n                    items = moveWrapper.alternativeLines.splice(path[path.length - 1], 1)[0];\r\n                }\r\n            }\r\n            const traverse = (current) => {\r\n                for (const moveWrapper of current) {\r\n                    const snapshot = snapshots.get(moveWrapper);\r\n                    if (snapshot) {\r\n                        const { hash } = snapshot;\r\n                        const boardHash = boardHashes.get(hash);\r\n                        if (boardHash) {\r\n                            if (boardHashes.get(hash) === 1) {\r\n                                boardHashes.delete(hash);\r\n                            }\r\n                            else {\r\n                                boardHashes.set(hash, boardHash - 1);\r\n                            }\r\n                        }\r\n                        for (const line of moveWrapper.alternativeLines) {\r\n                            traverse(line);\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n            traverse(items);\r\n        },\r\n        getHash(preliminaryHashString) {\r\n            return boardHashes.get(preliminaryHashString) ?? 0;\r\n        },\r\n        stringifyMove(moveWrapper, notation) {\r\n            let resultingString = \"\";\r\n            try {\r\n                let firstStandardMoveCaptureSet = false;\r\n                for (const move of moveWrapper.moveData) {\r\n                    if (verifyStandardMove(move)) {\r\n                        if (move.specialType === SpecialMove.CastlingKingside) {\r\n                            resultingString += \"O-O\";\r\n                            continue;\r\n                        }\r\n                        else if (move.specialType === SpecialMove.CastlingQueenside) {\r\n                            resultingString += \"O-O-O\";\r\n                            continue;\r\n                        }\r\n                        const endCoordinates = convertCoordinateToPGN4(move.endCoordinates);\r\n                        const { piece, color } = moveWrapper.metadata.movingPiece;\r\n                        const isPawn = piece === pawnPieceString.piece;\r\n                        if (!isPawn)\r\n                            resultingString += piece;\r\n                        const isCapture = !firstStandardMoveCaptureSet && moveWrapper.metadata.isCapture;\r\n                        switch (notation) {\r\n                            case 0 /* MoveNotation.Shortened */: {\r\n                                const localMove = this.getMove(moveWrapper.path);\r\n                                if (!localMove || Array.isArray(localMove))\r\n                                    throw new Error(\"Move is not defined\");\r\n                                const snapshot = this.getBoardSnapshot(localMove);\r\n                                if (!snapshot)\r\n                                    throw new Error(\"Snapshot is not defined\");\r\n                                const { boardSnapshot: { board }, pregeneratedAttacks: { pieceMovements } } = snapshot;\r\n                                const registeredPieces = [];\r\n                                for (const [piece, movements] of pieceMovements) {\r\n                                    const parsedCoordinate = unstringifyCoordinate(piece);\r\n                                    const boardPiece = board[parsedCoordinate[0]][parsedCoordinate[1]];\r\n                                    if (boardPiece.isEmpty() || boardPiece.color !== color\r\n                                        || boardPiece.piece !== piece)\r\n                                        continue;\r\n                                    if (movements.find(m => compareArrays(move.endCoordinates, m.move)) !== undefined) {\r\n                                        registeredPieces.push(parsedCoordinate);\r\n                                    }\r\n                                }\r\n                                const ambiguousRank = (isCapture && isPawn && color % 2 === 0)\r\n                                    || registeredPieces.some((c, i) => registeredPieces.some((c2, j) => i !== j && c[0] === c2[0]));\r\n                                const ambiguousFile = (isCapture && isPawn && color % 2 !== 0)\r\n                                    || registeredPieces.some((c, i) => registeredPieces.some((c2, j) => i !== j && c[1] === c2[1]));\r\n                                if (ambiguousFile && !ambiguousRank) {\r\n                                    resultingString += convertCoordinateToPGN4Array(move.startCoordinates)[1];\r\n                                }\r\n                                else if (!ambiguousFile && ambiguousRank) {\r\n                                    resultingString += convertCoordinateToPGN4Array(move.startCoordinates)[0];\r\n                                }\r\n                                else if (ambiguousFile && ambiguousRank) {\r\n                                    resultingString += convertCoordinateToPGN4(move.startCoordinates);\r\n                                }\r\n                                if (isCapture) {\r\n                                    resultingString += \"x\";\r\n                                }\r\n                                break;\r\n                            }\r\n                            case 1 /* MoveNotation.Full */:\r\n                                resultingString += convertCoordinateToPGN4(move.startCoordinates);\r\n                                if (isCapture) {\r\n                                    resultingString += \"x\";\r\n                                    firstStandardMoveCaptureSet = true;\r\n                                }\r\n                                else {\r\n                                    resultingString += \"-\";\r\n                                }\r\n                                break;\r\n                            default:\r\n                                throwOnNever(notation);\r\n                        }\r\n                        resultingString += endCoordinates;\r\n                        if (move.promotion) {\r\n                            resultingString += `=${move.promotion[0].piece}`;\r\n                        }\r\n                    }\r\n                    else if (verifyDroppingMove(move)) {\r\n                        switch (notation) {\r\n                            case 0 /* MoveNotation.Shortened */:\r\n                                resultingString += `@${move.piece.piece}`;\r\n                                resultingString += `${convertCoordinateToPGN4(move.endCoordinates)}`;\r\n                                break;\r\n                            case 1 /* MoveNotation.Full */:\r\n                                resultingString += `@${move.piece.value}`;\r\n                                resultingString += `-${convertCoordinateToPGN4(move.endCoordinates)}`;\r\n                                break;\r\n                            default:\r\n                                throwOnNever(notation);\r\n                        }\r\n                    }\r\n                    else if (verifyInternalMove(move)) {\r\n                        resultingString += move.type;\r\n                    }\r\n                    else {\r\n                        throwOnNever(move);\r\n                    }\r\n                }\r\n                resultingString += \"+\".repeat(moveWrapper.metadata.checks);\r\n                resultingString += \"#\".repeat(moveWrapper.metadata.checkmates);\r\n            }\r\n            catch (e) {\r\n                console.trace(e);\r\n            }\r\n            return resultingString;\r\n        }\r\n    };\r\n};\r\n","import { compareCoordinates } from \"../Board/BoardInterface\";\r\nimport { pawnPieceString, PieceString } from \"../GameInformation/GameUnits/PieceString\";\r\nimport { verifyDroppingMove, verifyInternalMove, verifyStandardMove } from \"./MoveTree\";\r\nexport var SpecialMove;\r\n(function (SpecialMove) {\r\n    SpecialMove[SpecialMove[\"CastlingKingside\"] = 0] = \"CastlingKingside\";\r\n    SpecialMove[SpecialMove[\"CastlingQueenside\"] = 1] = \"CastlingQueenside\";\r\n    SpecialMove[SpecialMove[\"EnPassant\"] = 2] = \"EnPassant\";\r\n})(SpecialMove || (SpecialMove = {}));\r\nexport var InternalMoveSignature;\r\n(function (InternalMoveSignature) {\r\n    InternalMoveSignature[\"Resign\"] = \"R\";\r\n    InternalMoveSignature[\"Timeout\"] = \"T\";\r\n    InternalMoveSignature[\"ClaimWin\"] = \"C\";\r\n    InternalMoveSignature[\"DrawByAgreement\"] = \"D\";\r\n    InternalMoveSignature[\"Stalemate\"] = \"S\";\r\n    InternalMoveSignature[\"Pass\"] = \"P\";\r\n    InternalMoveSignature[\"TeamsCheckmate\"] = \"#\";\r\n})(InternalMoveSignature || (InternalMoveSignature = {}));\r\nexport function verifyRequiredMove(move) { return move.length > 0; }\r\nexport function verifyMoveWrapperProperties(moveWrapper) {\r\n    return Boolean(moveWrapper.alternativeLines && moveWrapper.comment !== undefined && moveWrapper.path\r\n        && moveWrapper.metadata && moveWrapper.moveData);\r\n}\r\nexport function compareMoves(move1, move2) {\r\n    if (verifyStandardMove(move1)) {\r\n        if (!verifyStandardMove(move2))\r\n            return false;\r\n        return compareCoordinates(move1.startCoordinates, move2.startCoordinates)\r\n            && compareCoordinates(move1.endCoordinates, move2.endCoordinates)\r\n            && (move1.specialType === move2.specialType\r\n                || move1.specialType === SpecialMove.EnPassant\r\n                || move2.specialType === SpecialMove.EnPassant);\r\n    }\r\n    else if (verifyDroppingMove(move1)) {\r\n        if (!verifyDroppingMove(move2))\r\n            return false;\r\n        return compareCoordinates(move1.endCoordinates, move2.endCoordinates)\r\n            && PieceString.comparePieceStrings(move1.piece, move2.piece);\r\n    }\r\n    else if (verifyInternalMove(move1)) {\r\n        if (!verifyInternalMove(move2))\r\n            return false;\r\n        return move1.type === move2.type;\r\n    }\r\n    throw new Error(`Unexpected move signature of first move ${JSON.stringify(move1)}`);\r\n}\r\nexport function createDummyMoveMetadata() {\r\n    return {\r\n        isCapture: false, movingPiece: pawnPieceString,\r\n        checks: 0, checkmates: 0\r\n    };\r\n}\r\nexport const createBaseMoveWrapper = (requiredSettings, settings = {}) => {\r\n    const wrapper = {\r\n        path: requiredSettings.path, moveData: requiredSettings.moveData,\r\n        comment: \"\", alternativeLines: [],\r\n        metadata: createDummyMoveMetadata(),\r\n        cachedNames: {\r\n            [1 /* MoveNotation.Full */]: \"\",\r\n            [0 /* MoveNotation.Shortened */]: \"\"\r\n        }\r\n    };\r\n    return {\r\n        ...wrapper,\r\n        ...settings\r\n    };\r\n};\r\n","import { validateBoardMove } from \"../Board/BoardMoveValidator\";\r\nimport { totalPlayers } from \"../GameInformation/GameData\";\r\nimport { createPieceFromData } from \"../GameInformation/GameUnits/PieceString\";\r\nimport { createMoveTree, verifyStandardMove } from \"./MoveTree\";\r\nimport { createBaseMoveWrapper, SpecialMove } from \"./MoveTreeInterface\";\r\nexport function validateMoveTree(board, moves) {\r\n    const clonedBoard = board.createClone();\r\n    clonedBoard.moves = createMoveTree(clonedBoard.createSnapshot());\r\n    clonedBoard.pregenerateAttacks();\r\n    function traverse(current) {\r\n        const moves = [];\r\n        for (const moveWrapper of current) {\r\n            const { moveData, path, alternativeLines } = moveWrapper;\r\n            const newMoveWrapper = createBaseMoveWrapper({ moveData, path: path.slice() }, {\r\n                comment: moveWrapper.comment\r\n            });\r\n            let validationResult;\r\n            try {\r\n                if ((validationResult = validateBoardMove(clonedBoard, moveData) || undefined)) {\r\n                    newMoveWrapper.moveData = moveData;\r\n                }\r\n                else\r\n                    break;\r\n            }\r\n            catch (_) {\r\n                break;\r\n            }\r\n            let firstStandardMoveSet = false;\r\n            for (const moveComponent of moveData) {\r\n                if (verifyStandardMove(moveComponent)) {\r\n                    if (\"promotion\" in moveComponent) {\r\n                        moveComponent.promotion = moveComponent.promotion?.map(p => {\r\n                            if (p.isWall())\r\n                                return p;\r\n                            return createPieceFromData(clonedBoard.data.sideToMove, p.piece);\r\n                        });\r\n                    }\r\n                    if (!firstStandardMoveSet) {\r\n                        newMoveWrapper.metadata.movingPiece =\r\n                            clonedBoard.board[moveComponent.startCoordinates[0]][moveComponent.startCoordinates[1]];\r\n                        firstStandardMoveSet = true;\r\n                    }\r\n                    if (validationResult.hasEnPassant) {\r\n                        moveComponent.specialType = SpecialMove.EnPassant;\r\n                        validationResult.hasEnPassant = false;\r\n                        newMoveWrapper.metadata.isCapture = true;\r\n                    }\r\n                    if (clonedBoard.data.getCapturedPieces(moveComponent).length > 0)\r\n                        newMoveWrapper.metadata.isCapture = true;\r\n                }\r\n            }\r\n            const results = clonedBoard.makeMove(moveData);\r\n            for (let i = 0; i < totalPlayers; i++) {\r\n                if (results.checkmates[i]) {\r\n                    newMoveWrapper.metadata.checkmates++;\r\n                }\r\n                else if (results.checks[i]) {\r\n                    newMoveWrapper.metadata.checks++;\r\n                }\r\n            }\r\n            newMoveWrapper.cachedNames[0 /* MoveNotation.Shortened */] = clonedBoard.moves.stringifyMove(newMoveWrapper, 0 /* MoveNotation.Shortened */);\r\n            newMoveWrapper.cachedNames[1 /* MoveNotation.Full */] = clonedBoard.moves.stringifyMove(newMoveWrapper, 1 /* MoveNotation.Full */);\r\n            for (const line of alternativeLines) {\r\n                newMoveWrapper.alternativeLines.push(traverse(line));\r\n            }\r\n            const currentMove = clonedBoard.moves.getMove(newMoveWrapper.path);\r\n            if (Array.isArray(currentMove) || !currentMove)\r\n                throw new Error(\"Move wrapper path is incorrect: \" + newMoveWrapper.path.join(\",\"));\r\n            currentMove.metadata = newMoveWrapper.metadata;\r\n            currentMove.cachedNames = newMoveWrapper.cachedNames;\r\n        }\r\n        return moves;\r\n    }\r\n    traverse(moves.moves);\r\n    return clonedBoard.moves;\r\n}\r\n","import { boardDimension } from \"@moveGeneration/GameInformation/GameData\";\r\nimport { deadColorIndex } from \"../GameInformation/GameUnits/PieceString\";\r\nexport class PieceControl {\r\n    color;\r\n    sliding;\r\n    jumping;\r\n    hooks;\r\n    moves;\r\n    rayGenCache;\r\n    baseRankActive;\r\n    immunePieces;\r\n    fenData;\r\n    board;\r\n    i;\r\n    j;\r\n    /*---------------------------------- INITIALIZATION -----------------------------------------*/\r\n    constructor() {\r\n        this.moves = [];\r\n        this.color = 0; // default\r\n        this.sliding = [];\r\n        this.jumping = [];\r\n        this.rayGenCache = [];\r\n        this.hooks = {\r\n            useTrajectory: undefined,\r\n            usePerspective: undefined,\r\n            usePawnLogic: undefined,\r\n            useHopping: false\r\n        };\r\n        this.baseRankActive = false;\r\n        this.immunePieces = [false, false, false, false];\r\n    }\r\n    configure(configuration) {\r\n        this.color = configuration.color;\r\n        this.immunePieces = configuration.immunePieces;\r\n        [this.i, this.j] = configuration.coordinates;\r\n        const baseRankCalc = [13 - this.i, this.j, this.i, 13 - this.j][this.color] - this.fenData.fenOptions.pawnBaseRank;\r\n        this.baseRankActive = configuration.baseRank || (baseRankCalc === -1 || baseRankCalc === -2);\r\n        this.board = configuration.board;\r\n    }\r\n    setFENData(fenData) {\r\n        this.fenData = fenData;\r\n    }\r\n    isRayTrace(attackType) { return attackType === 4 /* AttackType.RayTrace */ || attackType === 5 /* AttackType.RayTraceLimited */; }\r\n    /*---------------------------------- INITIALIZATION -----------------------------------------*/\r\n    /*-------------------------------------------------------------------------------------------*/\r\n    /*--------------------------------- MOVE GENERATION -----------------------------------------*/\r\n    modifyDisplacements(i, j) {\r\n        const baseDisplacements = [[i, j], [j, -i], [-i, -j], [-j, i]];\r\n        return baseDisplacements[this.color];\r\n    }\r\n    pushMove(settings) {\r\n        if (!settings.isRayGen && this.hooks.usePawnLogic && this.hooks.usePawnLogic.promotionRanks\r\n            && this.hooks.usePawnLogic.promotionRanks[this.color] === (this.color % 2 === 0 ? settings.i : settings.j)\r\n            && this.hooks.usePawnLogic.promotionPieces) {\r\n            this.moves.push({\r\n                move: [settings.i, settings.j, this.hooks.usePawnLogic.promotionPieces.join(\"\")],\r\n                irreversible: settings.irreversible ?? false\r\n            });\r\n            return;\r\n        }\r\n        else {\r\n            this.moves.push({\r\n                move: [settings.i, settings.j],\r\n                irreversible: settings.irreversible ?? false\r\n            });\r\n        }\r\n    }\r\n    generateSlidingAttack(settings) {\r\n        let [displacementI, displacementJ] = settings.displacement, limit = settings.limit ?? Infinity;\r\n        const rayGenCache = settings.rayGenCache, special = settings.special ?? 0 /* AttackType.Normal */;\r\n        let rayTraceLimit = 0;\r\n        if (this.hooks.usePerspective?.[this.color]) {\r\n            [displacementI, displacementJ] = this.modifyDisplacements(displacementI, displacementJ);\r\n        }\r\n        let startI = this.i + displacementI, startJ = this.j + displacementJ;\r\n        const iLength = this.board[0].length, jLength = this.board.length;\r\n        const isRayGen = rayGenCache ?? this.isRayTrace(special);\r\n        while (limit > 0 && startI >= 0 && startI < iLength && startJ >= 0 && startJ < jLength) {\r\n            // TODO add trajectories?\r\n            if (this.getMovePossibility({ displacement: [startI, startJ], special, rayGenCache })) {\r\n                this.pushMove({ i: startI, j: startJ, isRayGen: Boolean(isRayGen), irreversible: settings.irreversible });\r\n            }\r\n            if (special === 5 /* AttackType.RayTraceLimited */ && !this.board[startI][startJ].isEmpty()) {\r\n                rayTraceLimit++;\r\n                if (rayTraceLimit === 2)\r\n                    break;\r\n            }\r\n            if (!this.isRayTrace(special) && !this.board[startI][startJ].isEmpty()) {\r\n                break;\r\n            }\r\n            startI += displacementI;\r\n            startJ += displacementJ;\r\n            limit--;\r\n        }\r\n    }\r\n    generateJumpAttack(settings) {\r\n        let [displacementI, displacementJ] = settings.displacement;\r\n        const rayGenCache = settings.rayGenCache, squareBlockingIndex = settings.squareBlockingIndex, special = settings.special ?? 0 /* AttackType.Normal */;\r\n        if (this.hooks.usePerspective?.[this.color]) {\r\n            [displacementI, displacementJ] = this.modifyDisplacements(displacementI, displacementJ);\r\n        }\r\n        const startI = this.i + displacementI, startJ = this.j + displacementJ;\r\n        const isRayGen = rayGenCache ?? this.isRayTrace(special);\r\n        let isTestPassed = true;\r\n        if (this.hooks.useTrajectory && squareBlockingIndex !== undefined) {\r\n            const trajectory = this.hooks.useTrajectory[squareBlockingIndex];\r\n            let trajectoryX, trajectoryY;\r\n            if (this.hooks.usePerspective?.[this.color]) {\r\n                [trajectoryX, trajectoryY] = this.modifyDisplacements(trajectory[0], trajectory[1]);\r\n            }\r\n            else {\r\n                trajectoryX = trajectory[0], trajectoryY = trajectory[1];\r\n            }\r\n            if (!this.getMovePossibility({ displacement: [this.i + trajectoryX, this.j + trajectoryY], special, rayGenCache })) {\r\n                isTestPassed = false;\r\n            }\r\n        }\r\n        if (isTestPassed && this.getMovePossibility({ displacement: [startI, startJ], special, rayGenCache })) {\r\n            this.pushMove({ i: startI, j: startJ, isRayGen: Boolean(isRayGen), irreversible: settings.irreversible });\r\n        }\r\n    }\r\n    getMovePossibility(configuration) {\r\n        const { displacement: [i, j], rayGenCache, special } = configuration;\r\n        if (i < 0 || i >= boardDimension || j < 0 || j >= boardDimension)\r\n            return false;\r\n        const piece = this.board[i][j];\r\n        if (!piece.isEmpty() && piece.color !== deadColorIndex && !rayGenCache && !this.isRayTrace(special ?? 0 /* AttackType.Normal */)) {\r\n            if (this.immunePieces[piece.color] || this.fenData.fenOptions.zombieImmune[piece.color])\r\n                return false;\r\n        }\r\n        const pushTo = () => {\r\n            if (rayGenCache) {\r\n                this.rayGenCache.push(rayGenCache);\r\n            }\r\n            return true;\r\n        };\r\n        if (special === undefined || special === 0 /* AttackType.Normal */) {\r\n            if (!piece.isWall()) {\r\n                return pushTo();\r\n            }\r\n        }\r\n        else if (special === 3 /* AttackType.RayGen */) {\r\n            if (!piece.isEmpty()) {\r\n                return pushTo();\r\n            }\r\n        }\r\n        else if (special === 2 /* AttackType.AttackOnly */) {\r\n            if (!piece.isEmpty() && !piece.isWall()) {\r\n                return pushTo();\r\n            }\r\n        }\r\n        else if (special === 1 /* AttackType.MoveOnly */) {\r\n            if (piece.isEmpty()) {\r\n                return pushTo();\r\n            }\r\n        }\r\n        else if (this.isRayTrace(special)) {\r\n            return pushTo();\r\n        }\r\n        return false;\r\n    }\r\n    /*--------------------------------- MOVE GENERATION -----------------------------------------*/\r\n    /*-------------------------------------------------------------------------------------------*/\r\n    /*------------------------------- OUTPUT GENERATION -----------------------------------------*/\r\n    getPossibleCells() {\r\n        if (this.hooks.useHopping) {\r\n            this.sliding.forEach(displacement => this.generateSlidingAttack({ displacement, special: 3 /* AttackType.RayGen */, rayGenCache: [...displacement] }));\r\n            const moves = this.moves.slice();\r\n            this.moves = [];\r\n            moves.forEach((s, i) => {\r\n                const startI = s.move[0] + this.rayGenCache[i][0];\r\n                const startJ = s.move[1] + this.rayGenCache[i][1];\r\n                if (this.getMovePossibility({ displacement: [startI, startJ] })) {\r\n                    this.pushMove({ i: startI, j: startJ });\r\n                }\r\n            });\r\n            this.rayGenCache = [];\r\n        }\r\n        else {\r\n            this.sliding.forEach(a => this.generateSlidingAttack({ displacement: a }));\r\n            this.jumping.forEach(a => this.generateJumpAttack({ displacement: a }));\r\n        }\r\n    }\r\n    rayGenJumpingAttacks() {\r\n        this.jumping.forEach(a => this.generateJumpAttack({ displacement: a, special: 4 /* AttackType.RayTrace */ }));\r\n        return this.moves.splice(0);\r\n    }\r\n    rayGenSlidingAttacks(trace) {\r\n        const slidingLines = [];\r\n        this.sliding.forEach(a => {\r\n            this.generateSlidingAttack({ displacement: a, special: trace });\r\n            if (this.moves.length !== 0) {\r\n                slidingLines.push(this.moves.splice(0));\r\n            }\r\n        });\r\n        return slidingLines;\r\n    }\r\n    getPseudoLegalMoves() {\r\n        this.getPossibleCells();\r\n        return this.moves.splice(0);\r\n    }\r\n}\r\n","import { decorateClassWithVariants } from \"../VariantRules/VariantRuleInterface\";\r\nimport { copyVariantRules } from \"../VariantRules/VariantRuleSetup\";\r\nimport { pieceControlConfigSettings } from \"./PieceControlInterface\";\r\nclass PieceControlConfigurator {\r\n    _control;\r\n    _isConfigured;\r\n    constructor(control) { this._control = control; this._isConfigured = { coordinates: undefined, board: undefined, immunePieces: undefined, color: undefined }; }\r\n    setCoordinates(x, y) { this._isConfigured.coordinates = [x, y]; return this; }\r\n    setBaseImmunePieces(immune) { this._isConfigured.immunePieces = immune; return this; }\r\n    setColor(color) { this._isConfigured.color = color; return this; }\r\n    setBoard(board) { this._isConfigured.board = board; return this; }\r\n    constructPieceControl() {\r\n        this._control.configure(this._isConfigured); // Safe type cast\r\n        return this._control;\r\n    }\r\n}\r\nclass PieceControlBuilder {\r\n    _generalConfig;\r\n    constructor() { this._generalConfig = {}; }\r\n    setFENData(fenData) { this._generalConfig.fenData = fenData; }\r\n    setVariantRules(rules) { this._generalConfig.variantRules = rules; }\r\n    createPieceControlWrap(letter) {\r\n        const information = pieceControlConfigSettings[letter];\r\n        const control = new information.construct();\r\n        if (this._generalConfig.fenData === undefined || this._generalConfig.variantRules === undefined)\r\n            throw new Error(\"PieceControl builder setup is not complete\");\r\n        control.setFENData(this._generalConfig.fenData);\r\n        const decoratedControl = decorateClassWithVariants(control, copyVariantRules(this._generalConfig.variantRules));\r\n        return () => {\r\n            return new PieceControlConfigurator(decoratedControl);\r\n        };\r\n    }\r\n}\r\nexport { PieceControlBuilder, PieceControlConfigurator };\r\n","import { PieceControl } from \"./PieceControl\";\r\nimport { createPieceDeclaration } from \"./PieceControlInterface\";\r\nconst orthogonalMoves = [[-1, 0], [1, 0], [0, 1], [0, -1]];\r\nconst diagonalMoves = [[-1, -1], [1, 1], [-1, 1], [1, -1]];\r\nconst kingDirections = [...orthogonalMoves, ...diagonalMoves];\r\nconst knightHops = [[-1, -2], [-2, -1], [-1, 2], [2, -1], [-2, 1], [1, -2], [1, 2], [2, 1]];\r\nconst camelHops = [[-1, -3], [-3, -1], [-1, 3], [3, -1], [-3, 1], [1, -3], [1, 3], [3, 1]];\r\nconst dabbabaHops = [[-2, 0], [2, 0], [0, 2], [0, -2]];\r\nconst alfilHops = [[-2, -2], [2, 2], [-2, 2], [2, -2]];\r\nexport const initPieceControlDeclarations = () => {\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.sliding = orthogonalMoves;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 5,\r\n                teamsPoints: 5,\r\n                botFFAValue: 7,\r\n                botTeamsValue: 7\r\n            },\r\n            piece: \"R\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: false,\r\n                isSliding: true,\r\n                isPawn: false,\r\n                isColorBound: false\r\n            },\r\n            naming: {\r\n                name: \"Rook\",\r\n                shortName: \"r\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.sliding = diagonalMoves;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 5,\r\n                teamsPoints: 4,\r\n                botFFAValue: 6,\r\n                botTeamsValue: 6\r\n            },\r\n            piece: \"B\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: false,\r\n                isSliding: true,\r\n                isPawn: false,\r\n                isColorBound: true\r\n            },\r\n            naming: {\r\n                name: \"Bishop\",\r\n                shortName: \"b\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.jumping = kingDirections;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 3,\r\n                teamsPoints: 0,\r\n                botFFAValue: 3,\r\n                botTeamsValue: 3\r\n            },\r\n            piece: \"K\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: true,\r\n                isSliding: false,\r\n                isPawn: false,\r\n                isColorBound: false\r\n            },\r\n            naming: {\r\n                name: \"King\",\r\n                shortName: \"k\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.sliding = kingDirections;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 9,\r\n                teamsPoints: 10,\r\n                botFFAValue: 14,\r\n                botTeamsValue: 15\r\n            },\r\n            piece: \"Q\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: false,\r\n                isSliding: true,\r\n                isPawn: false,\r\n                isColorBound: false\r\n            },\r\n            naming: {\r\n                name: \"Queen\",\r\n                shortName: \"q\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.sliding = kingDirections;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 9,\r\n                teamsPoints: 10,\r\n                botFFAValue: 13,\r\n                botTeamsValue: 13\r\n            },\r\n            piece: \"D\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: false,\r\n                isSliding: true,\r\n                isPawn: false,\r\n                isColorBound: false\r\n            },\r\n            naming: {\r\n                name: \"1-point queen\",\r\n                shortName: \"d\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.jumping = knightHops;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 3,\r\n                teamsPoints: 3,\r\n                botFFAValue: 4,\r\n                botTeamsValue: 4\r\n            },\r\n            piece: \"N\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: true,\r\n                isSliding: false,\r\n                isPawn: false,\r\n                isColorBound: false\r\n            },\r\n            naming: {\r\n                name: \"Knight\",\r\n                shortName: \"n\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.jumping = [...knightHops, ...kingDirections];\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 5,\r\n                teamsPoints: 5,\r\n                botFFAValue: 7,\r\n                botTeamsValue: 7\r\n            },\r\n            piece: \"M\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: true,\r\n                isSliding: false,\r\n                isPawn: false,\r\n                isColorBound: false\r\n            },\r\n            naming: {\r\n                name: \"General\",\r\n                shortName: \"m\",\r\n                description: \"combines king and knight\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.jumping = diagonalMoves;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 1,\r\n                teamsPoints: 1,\r\n                botFFAValue: 0.6,\r\n                botTeamsValue: 0.6\r\n            },\r\n            piece: \"F\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: true,\r\n                isSliding: false,\r\n                isPawn: false,\r\n                isColorBound: true\r\n            },\r\n            naming: {\r\n                name: \"Ferz\",\r\n                shortName: \"f\",\r\n                description: \"moves one square diagonally\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.jumping = orthogonalMoves;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 1,\r\n                teamsPoints: 1,\r\n                botFFAValue: 0.4,\r\n                botTeamsValue: 0.4\r\n            },\r\n            piece: \"W\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: true,\r\n                isSliding: false,\r\n                isPawn: false,\r\n                isColorBound: false\r\n            },\r\n            naming: {\r\n                name: \"Wazir\",\r\n                shortName: \"w\",\r\n                description: \"moves one square horizontally or vertically\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.jumping = orthogonalMoves;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 1,\r\n                teamsPoints: 1,\r\n                botFFAValue: 0.4,\r\n                botTeamsValue: 0.4\r\n            },\r\n            piece: \"W\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: true,\r\n                isSliding: false,\r\n                isPawn: false,\r\n                isColorBound: false\r\n            },\r\n            naming: {\r\n                name: \"Wazir\",\r\n                shortName: \"w\",\r\n                description: \"moves one square horizontally or vertically\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.jumping = dabbabaHops;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 1,\r\n                teamsPoints: 1,\r\n                botFFAValue: 1.6,\r\n                botTeamsValue: 1.6\r\n            },\r\n            piece: \"S\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: true,\r\n                isSliding: false,\r\n                isPawn: false,\r\n                isColorBound: true\r\n            },\r\n            naming: {\r\n                name: \"Dabbaba\",\r\n                shortName: \"s\",\r\n                description: \"jumps two squares horizontally or vertically\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.sliding = dabbabaHops;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 4,\r\n                teamsPoints: 4,\r\n                botFFAValue: 5.4,\r\n                botTeamsValue: 5.4\r\n            },\r\n            piece: \"T\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: false,\r\n                isSliding: true,\r\n                isPawn: false,\r\n                isColorBound: true\r\n            },\r\n            naming: {\r\n                name: \"Dabbaba-rider\",\r\n                shortName: \"t\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.jumping = alfilHops;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 1,\r\n                teamsPoints: 1,\r\n                botFFAValue: 0.5,\r\n                botTeamsValue: 0.5\r\n            },\r\n            piece: \"I\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: true,\r\n                isSliding: false,\r\n                isPawn: false,\r\n                isColorBound: true\r\n            },\r\n            naming: {\r\n                name: \"Alfil\",\r\n                shortName: \"i\",\r\n                description: \"jumps two squares diagonally\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.sliding = alfilHops;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 3,\r\n                teamsPoints: 3,\r\n                botFFAValue: 4.5,\r\n                botTeamsValue: 4.5\r\n            },\r\n            piece: \"J\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: false,\r\n                isSliding: true,\r\n                isPawn: false,\r\n                isColorBound: true\r\n            },\r\n            naming: {\r\n                name: \"Alfil-rider\",\r\n                shortName: \"j\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.jumping = [...alfilHops, ...dabbabaHops];\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 3,\r\n                teamsPoints: 3,\r\n                botFFAValue: 3,\r\n                botTeamsValue: 3\r\n            },\r\n            piece: \"Y\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: true,\r\n                isSliding: false,\r\n                isPawn: false,\r\n                isColorBound: true\r\n            },\r\n            naming: {\r\n                name: \"Alibaba\",\r\n                shortName: \"y\",\r\n                description: \"combines alfil and dabbaba\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.sliding = [...alfilHops, ...dabbabaHops];\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 6,\r\n                teamsPoints: 6,\r\n                botFFAValue: 6.2,\r\n                botTeamsValue: 6.2\r\n            },\r\n            piece: \"Z\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: false,\r\n                isSliding: true,\r\n                isPawn: false,\r\n                isColorBound: true\r\n            },\r\n            naming: {\r\n                name: \"Alibaba-rider\",\r\n                shortName: \"z\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.jumping = knightHops;\r\n                this.sliding = kingDirections;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 12,\r\n                teamsPoints: 12,\r\n                botFFAValue: 17,\r\n                botTeamsValue: 17\r\n            },\r\n            piece: \"A\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: true,\r\n                isSliding: true,\r\n                isPawn: false,\r\n                isColorBound: false\r\n            },\r\n            naming: {\r\n                name: \"Amazon\",\r\n                shortName: \"a\",\r\n                description: \"combines queen and knight\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.jumping = camelHops;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 3,\r\n                teamsPoints: 3,\r\n                botFFAValue: 4.2,\r\n                botTeamsValue: 4.2\r\n            },\r\n            piece: \"C\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: true,\r\n                isSliding: false,\r\n                isPawn: false,\r\n                isColorBound: true\r\n            },\r\n            naming: {\r\n                name: \"Camel\",\r\n                shortName: \"c\",\r\n                description: \"an elongated 3-1 knight\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.jumping = knightHops;\r\n                this.sliding = orthogonalMoves;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 7,\r\n                teamsPoints: 7,\r\n                botFFAValue: 10,\r\n                botTeamsValue: 10\r\n            },\r\n            piece: \"E\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: true,\r\n                isSliding: true,\r\n                isPawn: false,\r\n                isColorBound: false\r\n            },\r\n            naming: {\r\n                name: \"Chancellor\",\r\n                shortName: \"a\",\r\n                description: \"combines rook and knight\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.jumping = knightHops;\r\n                this.sliding = diagonalMoves;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 7,\r\n                teamsPoints: 7,\r\n                botFFAValue: 9,\r\n                botTeamsValue: 9\r\n            },\r\n            piece: \"H\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: true,\r\n                isSliding: true,\r\n                isPawn: false,\r\n                isColorBound: false\r\n            },\r\n            naming: {\r\n                name: \"Archbishop\",\r\n                shortName: \"h\",\r\n                description: \"combines bishop and knight\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.sliding = knightHops;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 7,\r\n                teamsPoints: 7,\r\n                botFFAValue: 10,\r\n                botTeamsValue: 10\r\n            },\r\n            piece: \"O\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: false,\r\n                isSliding: true,\r\n                isPawn: false,\r\n                isColorBound: false\r\n            },\r\n            naming: {\r\n                name: \"Knight-rider\",\r\n                shortName: \"o\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.sliding = camelHops;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 7,\r\n                teamsPoints: 7,\r\n                botFFAValue: 8,\r\n                botTeamsValue: 8\r\n            },\r\n            piece: \"L\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: false,\r\n                isSliding: true,\r\n                isPawn: false,\r\n                isColorBound: true\r\n            },\r\n            naming: {\r\n                name: \"Camel-rider\",\r\n                shortName: \"l\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.jumping = [...camelHops, ...knightHops];\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 5,\r\n                teamsPoints: 5,\r\n                botFFAValue: 8,\r\n                botTeamsValue: 8\r\n            },\r\n            piece: \"V\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: true,\r\n                isSliding: false,\r\n                isPawn: false,\r\n                isColorBound: false\r\n            },\r\n            naming: {\r\n                name: \"Wildebeest\",\r\n                shortName: \"v\",\r\n                description: \"combines camel and knight\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.hooks.usePerspective = [true, true, true, true];\r\n                this.hooks.usePawnLogic = {};\r\n            }\r\n            getPossibleCells() {\r\n                this.generateJumpAttack({ displacement: [-1, -1], special: 2 /* AttackType.AttackOnly */ });\r\n                this.generateJumpAttack({ displacement: [-1, 1], special: 2 /* AttackType.AttackOnly */ });\r\n                this.generateSlidingAttack({\r\n                    displacement: [-1, 0],\r\n                    special: 1 /* AttackType.MoveOnly */,\r\n                    limit: this.baseRankActive ? 2 : 1,\r\n                    irreversible: true\r\n                });\r\n                return this.moves;\r\n            }\r\n            rayGenJumpingAttacks() {\r\n                this.generateJumpAttack({ displacement: [-1, -1], special: 4 /* AttackType.RayTrace */ });\r\n                this.generateJumpAttack({ displacement: [-1, 1], special: 4 /* AttackType.RayTrace */ });\r\n                const moves = this.moves.slice();\r\n                this.moves = [];\r\n                return moves;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 1,\r\n                teamsPoints: 1,\r\n                botFFAValue: 1,\r\n                botTeamsValue: 0.4\r\n            },\r\n            piece: \"P\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: true,\r\n                isSliding: false,\r\n                isPawn: true,\r\n                isColorBound: false\r\n            },\r\n            naming: {\r\n                name: \"Pawn\",\r\n                shortName: \"p\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.hooks.usePerspective = [true, true, true, true];\r\n                this.hooks.usePawnLogic = {};\r\n            }\r\n            getPossibleCells() {\r\n                this.generateSlidingAttack({\r\n                    displacement: [-1, -1],\r\n                    special: 1 /* AttackType.MoveOnly */,\r\n                    limit: this.baseRankActive ? 2 : 1,\r\n                    irreversible: true\r\n                });\r\n                this.generateSlidingAttack({\r\n                    displacement: [-1, 1],\r\n                    special: 1 /* AttackType.MoveOnly */,\r\n                    limit: this.baseRankActive ? 2 : 1,\r\n                    irreversible: true\r\n                });\r\n                this.generateJumpAttack({ displacement: [-1, -1], special: 2 /* AttackType.AttackOnly */ });\r\n                return this.moves;\r\n            }\r\n            rayGenJumpingAttacks() {\r\n                this.generateJumpAttack({ displacement: [-1, -1], special: 4 /* AttackType.RayTrace */ });\r\n                const moves = this.moves.slice();\r\n                this.moves = [];\r\n                return moves;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 1,\r\n                teamsPoints: 1,\r\n                botFFAValue: 1,\r\n                botTeamsValue: 0.4\r\n            },\r\n            piece: \"\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: true,\r\n                isSliding: false,\r\n                isPawn: true,\r\n                isColorBound: false\r\n            },\r\n            naming: {\r\n                name: \"Berolina\",\r\n                shortName: \"alpha\",\r\n                description: \"a pawn that moves diagonally and captures forwards\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.hooks.usePerspective = [true, true, true, true];\r\n                this.hooks.usePawnLogic = {};\r\n            }\r\n            getPossibleCells() {\r\n                this.generateSlidingAttack({\r\n                    displacement: [-1, -1],\r\n                    special: 1 /* AttackType.MoveOnly */,\r\n                    limit: this.baseRankActive ? 2 : 0,\r\n                    irreversible: true\r\n                });\r\n                this.generateSlidingAttack({\r\n                    displacement: [-1, 1],\r\n                    special: 1 /* AttackType.MoveOnly */,\r\n                    limit: this.baseRankActive ? 2 : 0,\r\n                    irreversible: true\r\n                });\r\n                this.generateJumpAttack({\r\n                    displacement: [-1, -1],\r\n                    irreversible: true\r\n                });\r\n                this.generateJumpAttack({\r\n                    displacement: [-1, 1],\r\n                    irreversible: true\r\n                });\r\n                return this.moves;\r\n            }\r\n            rayGenJumpingAttacks() {\r\n                this.generateJumpAttack({ displacement: [-1, -1], special: 4 /* AttackType.RayTrace */ });\r\n                this.generateJumpAttack({ displacement: [-1, 1], special: 4 /* AttackType.RayTrace */ });\r\n                const moves = this.moves.slice();\r\n                this.moves = [];\r\n                return moves;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 1,\r\n                teamsPoints: 1,\r\n                botFFAValue: 1,\r\n                botTeamsValue: 0.4\r\n            },\r\n            piece: \"\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: true,\r\n                isSliding: false,\r\n                isPawn: true,\r\n                isColorBound: false\r\n            },\r\n            naming: {\r\n                name: \"Stone General\",\r\n                shortName: \"gamma\",\r\n                description: \"a pawn that moves and captures diagonally\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.hooks.usePerspective = [true, true, true, true];\r\n                this.hooks.usePawnLogic = {};\r\n            }\r\n            getPossibleCells() {\r\n                this.generateSlidingAttack({\r\n                    displacement: [-1, 0],\r\n                    special: 1 /* AttackType.MoveOnly */,\r\n                    limit: this.baseRankActive ? 2 : 0,\r\n                    irreversible: true\r\n                });\r\n                this.generateJumpAttack({\r\n                    displacement: [-1, 0],\r\n                    irreversible: true\r\n                });\r\n                return this.moves;\r\n            }\r\n            rayGenJumpingAttacks() {\r\n                this.generateJumpAttack({ displacement: [-1, 0], special: 4 /* AttackType.RayTrace */ });\r\n                const moves = this.moves.slice();\r\n                this.moves = [];\r\n                return moves;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 1,\r\n                teamsPoints: 1,\r\n                botFFAValue: 1,\r\n                botTeamsValue: 0.4\r\n            },\r\n            piece: \"\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: true,\r\n                isSliding: false,\r\n                isPawn: true,\r\n                isColorBound: false\r\n            },\r\n            naming: {\r\n                name: \"Soldier\",\r\n                shortName: \"beta\",\r\n                description: \"a pawn that moves and captures forwards only\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.hooks.usePerspective = [true, true, true, true];\r\n                this.hooks.usePawnLogic = {};\r\n            }\r\n            getPossibleCells() {\r\n                this.generateSlidingAttack({\r\n                    displacement: [-1, -1],\r\n                    special: 1 /* AttackType.MoveOnly */,\r\n                    limit: this.baseRankActive ? 2 : 0,\r\n                    irreversible: true\r\n                });\r\n                this.generateSlidingAttack({\r\n                    displacement: [-1, 1],\r\n                    special: 1 /* AttackType.MoveOnly */,\r\n                    limit: this.baseRankActive ? 2 : 0,\r\n                    irreversible: true\r\n                });\r\n                this.generateSlidingAttack({\r\n                    displacement: [-1, 0],\r\n                    special: 1 /* AttackType.MoveOnly */,\r\n                    limit: this.baseRankActive ? 2 : 0,\r\n                    irreversible: true\r\n                });\r\n                this.generateJumpAttack({\r\n                    displacement: [-1, 0],\r\n                    irreversible: true\r\n                });\r\n                this.generateJumpAttack({\r\n                    displacement: [-1, -1],\r\n                    irreversible: true\r\n                });\r\n                this.generateJumpAttack({\r\n                    displacement: [-1, 1],\r\n                    irreversible: true\r\n                });\r\n                return this.moves;\r\n            }\r\n            rayGenJumpingAttacks() {\r\n                this.generateJumpAttack({ displacement: [-1, 0], special: 4 /* AttackType.RayTrace */ });\r\n                this.generateJumpAttack({ displacement: [-1, -1], special: 4 /* AttackType.RayTrace */ });\r\n                this.generateJumpAttack({ displacement: [-1, 1], special: 4 /* AttackType.RayTrace */ });\r\n                const moves = this.moves.slice();\r\n                this.moves = [];\r\n                return moves;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 1,\r\n                teamsPoints: 1,\r\n                botFFAValue: 1,\r\n                botTeamsValue: 0.4\r\n            },\r\n            piece: \"\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: true,\r\n                isSliding: false,\r\n                isPawn: true,\r\n                isColorBound: false\r\n            },\r\n            naming: {\r\n                name: \"Sergeant\",\r\n                shortName: \"delta\",\r\n                description: \"a pawn that moves and captures forwards and diagonally\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.hooks.useTrajectory = [[-1, 0], [1, 0], [0, 1], [0, -1]];\r\n            }\r\n            getPossibleCells() {\r\n                this.generateJumpAttack({ displacement: [-1, -2], special: 0 /* AttackType.Normal */, squareBlockingIndex: 3 });\r\n                this.generateJumpAttack({ displacement: [1, -2], special: 0 /* AttackType.Normal */, squareBlockingIndex: 3 });\r\n                this.generateJumpAttack({ displacement: [-1, 2], special: 0 /* AttackType.Normal */, squareBlockingIndex: 2 });\r\n                this.generateJumpAttack({ displacement: [1, 2], special: 0 /* AttackType.Normal */, squareBlockingIndex: 2 });\r\n                this.generateJumpAttack({ displacement: [2, -1], special: 0 /* AttackType.Normal */, squareBlockingIndex: 1 });\r\n                this.generateJumpAttack({ displacement: [2, 1], special: 0 /* AttackType.Normal */, squareBlockingIndex: 1 });\r\n                this.generateJumpAttack({ displacement: [-2, -1], special: 0 /* AttackType.Normal */, squareBlockingIndex: 0 });\r\n                this.generateJumpAttack({ displacement: [-2, 1], special: 0 /* AttackType.Normal */, squareBlockingIndex: 0 });\r\n                return this.moves;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 2,\r\n                teamsPoints: 2,\r\n                botFFAValue: 2.1,\r\n                botTeamsValue: 2.1\r\n            },\r\n            piece: \"U\",\r\n            moveGenerationSettings: {\r\n                isComplex: true,\r\n                isJumping: true,\r\n                isSliding: false,\r\n                isPawn: false,\r\n                isColorBound: false\r\n            },\r\n            naming: {\r\n                name: \"Xiangqi horse\",\r\n                shortName: \"u\",\r\n                description: \"moves one square orthogonally and then one diagonally\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.hooks.useTrajectory = [[-1, 0], [1, 0], [0, 1], [0, -1]];\r\n            }\r\n            getPossibleCells() {\r\n                this.generateJumpAttack({ displacement: [-1, -2], special: 0 /* AttackType.Normal */, squareBlockingIndex: 3 });\r\n                this.generateJumpAttack({ displacement: [1, -2], special: 0 /* AttackType.Normal */, squareBlockingIndex: 3 });\r\n                this.generateJumpAttack({ displacement: [-1, 2], special: 0 /* AttackType.Normal */, squareBlockingIndex: 2 });\r\n                this.generateJumpAttack({ displacement: [1, 2], special: 0 /* AttackType.Normal */, squareBlockingIndex: 2 });\r\n                this.generateJumpAttack({ displacement: [2, -1], special: 0 /* AttackType.Normal */, squareBlockingIndex: 1 });\r\n                this.generateJumpAttack({ displacement: [2, 1], special: 0 /* AttackType.Normal */, squareBlockingIndex: 1 });\r\n                this.generateJumpAttack({ displacement: [-2, -1], special: 0 /* AttackType.Normal */, squareBlockingIndex: 0 });\r\n                this.generateJumpAttack({ displacement: [-2, 1], special: 0 /* AttackType.Normal */, squareBlockingIndex: 0 });\r\n                this.sliding.forEach(displacement => { this.generateSlidingAttack({ displacement }); });\r\n                return this.moves;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 6,\r\n                teamsPoints: 6,\r\n                botFFAValue: 7.5,\r\n                botTeamsValue: 7.5\r\n            },\r\n            piece: \"\",\r\n            moveGenerationSettings: {\r\n                isComplex: true,\r\n                isJumping: true,\r\n                isSliding: true,\r\n                isPawn: false,\r\n                isColorBound: false\r\n            },\r\n            naming: {\r\n                name: \"Dragon bishop\",\r\n                shortName: \"deltaUpper\",\r\n                description: \"combines bishop and xiangqi horse\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.hooks.useHopping = true;\r\n                this.sliding = kingDirections;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 3,\r\n                teamsPoints: 3,\r\n                botFFAValue: 5.8,\r\n                botTeamsValue: 5.8\r\n            },\r\n            piece: \"G\",\r\n            moveGenerationSettings: {\r\n                isComplex: true,\r\n                isJumping: true,\r\n                isSliding: false,\r\n                isPawn: false,\r\n                isColorBound: false\r\n            },\r\n            naming: {\r\n                name: \"Grasshopper\",\r\n                shortName: \"g\",\r\n                description: \"jumps in any direction hopping over the first piece, landing immediately behind it\"\r\n            }\r\n        }\r\n    });\r\n};\r\n","import { nonPlayablePieces } from \"@moveGeneration/GameInformation/GameUnits/PieceString\";\r\nconst nonPlayableValues = Object.values(nonPlayablePieces);\r\nexport const verifyPieceLetter = (piece) => piece in pieceControlConfigSettings || nonPlayableValues.includes(piece);\r\nexport const pieceControlConfigSettings = nonPlayableValues.reduce((p, n) => ({\r\n    ...p, [n]: {\r\n        points: {\r\n            singlesPoints: 1,\r\n            teamsPoints: 1,\r\n            botFFAValue: 1,\r\n            botTeamsValue: 1,\r\n        },\r\n        piece: n,\r\n        moveGenerationSettings: {\r\n            isComplex: false,\r\n            isJumping: false,\r\n            isSliding: false,\r\n            isPawn: false,\r\n        },\r\n        naming: {\r\n            name: \"Wall\",\r\n            shortName: n\r\n        }\r\n    }\r\n}), {});\r\nexport const createPieceDeclaration = (configuration) => {\r\n    pieceControlConfigSettings[configuration.configuration.piece] = {\r\n        ...configuration.configuration,\r\n        construct: configuration.baseClassRef\r\n    };\r\n};\r\n","export var ZombieType;\r\n(function (ZombieType) {\r\n    ZombieType[\"Rando\"] = \"rando\";\r\n    ZombieType[\"Futer\"] = \"comfuter\";\r\n    ZombieType[\"Ranter\"] = \"ranter\";\r\n    ZombieType[\"Patzer\"] = \"patzer\";\r\n    ZombieType[\"Pusher\"] = \"pusher\";\r\n    ZombieType[\"Checker\"] = \"checker\";\r\n    ZombieType[\"Muncher\"] = \"muncher\";\r\n    ZombieType[\"F_Pusher\"] = \"pusher_comfuter\";\r\n    ZombieType[\"F_Checker\"] = \"checker_comfuter\";\r\n    ZombieType[\"F_Muncher\"] = \"muncher_comfuter\";\r\n})(ZombieType || (ZombieType = {}));\r\nexport const verifyZombieType = (zombieType) => zombieType in ZombieType;\r\n","import { Board } from \"../../../Board/Board\";\r\nimport { InternalMoveSignature } from \"../../../MoveTree/MoveTreeInterface\";\r\nimport { VariantRule } from \"../../VariantRuleInterface\";\r\nconst tag = \"allowPassing\";\r\nexport class AllowPassing extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(AllowPassing);\r\n    }\r\n    getDecoratorType() { return Board; }\r\n    getParameterValue() { return true; }\r\n    matchesPGNDeclaration(match) {\r\n        return /^AllowPassing$/i.test(match);\r\n    }\r\n    getInformation() {\r\n        return { name: \"Allow Passing\", description: \"Players can pass instead of making a move\", tag };\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"AllowPassing\";\r\n    }\r\n    getAllowedInternalMoves(sideToMove = this.decorator.data.sideToMove) {\r\n        const passingMoves = this.decorator.isKingInCheck(sideToMove) ? [] : [{ type: InternalMoveSignature.Pass }];\r\n        if (this.wrappingDecorator?.getAllowedInternalMoves) {\r\n            return [...passingMoves, ...this.wrappingDecorator.getAllowedInternalMoves(sideToMove)];\r\n        }\r\n        else {\r\n            return [...passingMoves, ...Board.prototype.getAllowedInternalMoves.call(this.decorator, sideToMove)];\r\n        }\r\n    }\r\n}\r\n","import { Board } from \"../../../Board/Board\";\r\nimport { VariantRule } from \"../../VariantRuleInterface\";\r\nconst tag = \"alternativeTeams\";\r\nexport class AlternativeTeams extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(AlternativeTeams);\r\n    }\r\n    teammate;\r\n    constructor(teammate) {\r\n        super();\r\n        if (typeof teammate === \"number\") {\r\n            this.teammate = teammate;\r\n        }\r\n        else {\r\n            this.teammate = 2;\r\n        }\r\n    }\r\n    getDecoratorType() { return Board; }\r\n    getParameterValue() { return this.teammate; }\r\n    matchesPGNDeclaration(match) {\r\n        const matchArray = match.match(/^Teammate=(1|3)$/);\r\n        if (matchArray) {\r\n            this.teammate = Number(matchArray[1]);\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    serializeToParsingForm() {\r\n        return `Teammate=${this.teammate}`;\r\n    }\r\n    getInformation() {\r\n        const rbTeams = this.teammate === 1;\r\n        const teamOne = rbTeams ? \"Red & Blue\" : \"Red & Green\";\r\n        const teamTwo = rbTeams ? \"Yellow & Green\" : \"Blue & Yellow\";\r\n        return { name: `${teamOne} vs. ${teamTwo}`, description: `Alternative Teams: ${teamOne} form a team against ${teamTwo}`, tag: \"alternativeTeams\" };\r\n    }\r\n    initDecoratorSettings() {\r\n        const teamSettings = this.decorator.gameType.teamSettings;\r\n        if (this.teammate === 1) {\r\n            teamSettings.firstTeamColors = [true, true, false, false];\r\n            teamSettings.secondTeamColors = [false, false, true, true];\r\n        }\r\n        else if (this.teammate === 3) {\r\n            teamSettings.firstTeamColors = [true, false, false, true];\r\n            teamSettings.secondTeamColors = [false, true, true, false];\r\n        }\r\n        if (this.wrappingDecorator) {\r\n            this.wrappingDecorator.initDecoratorSettings?.();\r\n        }\r\n    }\r\n}\r\n","import { Board } from \"../../../Board/Board\";\r\nimport { stringifyCoordinate } from \"../../../Board/BoardInterface\";\r\nimport { InternalMoveSignature } from \"../../../MoveTree/MoveTreeInterface\";\r\nimport { VariantRule } from \"../../VariantRuleInterface\";\r\nconst tag = \"barePieceRule\";\r\nexport class BarePieceRule extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(BarePieceRule);\r\n    }\r\n    getDecoratorType() { return Board; }\r\n    getParameterValue() { return true; }\r\n    matchesPGNDeclaration(match) {\r\n        return /^BarePieceLoses$/i.test(match);\r\n    }\r\n    getInformation() {\r\n        return {\r\n            name: \"Bare piece rule\",\r\n            description: \"Players with only one remaining piece are forfeit\",\r\n            tag\r\n        };\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"BarePieceLoses\";\r\n    }\r\n    makeMove(move, ignoreNextMoves = false) {\r\n        const results = this.wrappingDecorator?.makeMove\r\n            ? this.wrappingDecorator.makeMove(move, ignoreNextMoves)\r\n            : Board.prototype.makeMove.call(this.decorator, move, ignoreNextMoves);\r\n        const playerPieces = this.decorator.getPlayerPieces()[this.decorator.data.sideToMove];\r\n        if (playerPieces.length === 1) {\r\n            const pieceMovements = this.decorator.preGeneratedAttacks.pieceMovements.get(stringifyCoordinate(playerPieces[0]));\r\n            if (pieceMovements) {\r\n                for (const { move: coordinate } of pieceMovements) {\r\n                    if (this.decorator.board[coordinate[0]][coordinate[1]].isPiece()) {\r\n                        return results;\r\n                    }\r\n                }\r\n                return this.decorator.makeMove([{ type: InternalMoveSignature.Resign }]);\r\n            }\r\n        }\r\n        return results;\r\n    }\r\n}\r\n","import { createTupleFromCallback } from \"../../../../../baseTypes\";\r\nimport { Board } from \"../../../Board/Board\";\r\nimport { boardDimension } from \"../../../GameInformation/GameData\";\r\nimport { VariantRule } from \"../../VariantRuleInterface\";\r\nconst tag = \"blindfold\";\r\nexport class Blindfold extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(Blindfold);\r\n    }\r\n    getDecoratorType() { return Board; }\r\n    getParameterValue() { return true; }\r\n    matchesPGNDeclaration(match) {\r\n        return /^Blindfold$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"Blindfold\";\r\n    }\r\n    getInformation() {\r\n        return { name: \"Blindfold\", description: \"Pieces are invisible\", tag };\r\n    }\r\n    getSquareVisibility() {\r\n        if (this.wrappingDecorator?.getSquareVisibility) {\r\n            return this.wrappingDecorator.getSquareVisibility().map((r, i) => r.map((v, j) => {\r\n                if (this.decorator.board[i][j].isWall()) {\r\n                    return v;\r\n                }\r\n                else {\r\n                    return [...v, 3 /* DisplaySettings.Blindfolded */];\r\n                }\r\n            }));\r\n        }\r\n        else {\r\n            return createTupleFromCallback((_, i) => createTupleFromCallback((_, j) => {\r\n                if (this.decorator.board[i][j].isWall()) {\r\n                    return [];\r\n                }\r\n                else {\r\n                    return [3 /* DisplaySettings.Blindfolded */];\r\n                }\r\n            }, boardDimension), boardDimension);\r\n        }\r\n    }\r\n}\r\n","import { Board } from \"../../../Board/Board\";\r\nimport { VariantRule } from \"../../VariantRuleInterface\";\r\nconst tag = \"captureTheKing\";\r\nexport class CaptureTheKing extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(CaptureTheKing);\r\n    }\r\n    getDecoratorType() { return Board; }\r\n    getParameterValue() { return true; }\r\n    matchesPGNDeclaration(match) {\r\n        return /^CaptureTheKing$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"CaptureTheKing\";\r\n    }\r\n    getInformation() {\r\n        return { name: \"Capture the King\", description: \"To checkmate, kings must be captured\", tag };\r\n    }\r\n    isKingInCheck() {\r\n        return false;\r\n    }\r\n    isTheMoveLegal() {\r\n        return true;\r\n    }\r\n}\r\n","import { Board } from \"../../../Board/Board\";\r\nimport { boardDimension, totalPlayers } from \"../../../GameInformation/GameData\";\r\nimport { VariantRule } from \"../../VariantRuleInterface\";\r\nconst tag = \"chess960\";\r\nexport class Chess960 extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(Chess960);\r\n    }\r\n    static chess960ranges = [...Array.from({ length: 9 }, (_, i) => [960 * (i + 1) + 1, 960 + 960 * (i + 1)]),\r\n        ...Array.from({ length: 5 }, (_, i) => [10000 + 960 * (i + 1) + 1, 10960 + 960 * (i + 1)])];\r\n    static minorPieceCache = (function () {\r\n        const minorPieceCache = [];\r\n        for (let i = 0; i < 4; i++) {\r\n            for (let j = i + 1; j < 5; j++) {\r\n                minorPieceCache.push([i, j]);\r\n            }\r\n        }\r\n        return minorPieceCache;\r\n    })();\r\n    static pieceMasks = [\r\n        [404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959],\r\n        [5, 6, 7, 9, 10, 11, 13, 14, 15, 17, 18, 19, 33, 34, 35, 37, 38, 39, 41, 42, 43, 45, 46, 47, 49, 50, 51, 53, 54, 55, 57, 58, 59, 61, 62, 63, 65, 66, 67, 69, 70, 71, 73, 74, 75, 77, 78, 79, 81, 82, 83, 85, 86, 87, 89, 90, 91, 93, 94, 95, 101, 102, 103, 105, 106, 107, 109, 110, 111, 113, 114, 115, 129, 130, 131, 145, 146, 147, 161, 162, 163, 177, 178, 179, 197, 198, 199, 201, 202, 203, 205, 206, 207, 209, 210, 211, 225, 226, 227, 241, 242, 243, 257, 258, 259, 273, 274, 275, 293, 294, 295, 297, 298, 299, 301, 302, 303, 305, 306, 307, 321, 322, 323, 337, 338, 339, 353, 354, 355, 369, 370, 371, 421, 422, 423, 425, 426, 427, 429, 430, 431, 437, 438, 439, 441, 442, 443, 445, 446, 447, 453, 454, 455, 457, 458, 459, 461, 462, 463, 469, 470, 471, 473, 474, 475, 477, 478, 479, 517, 518, 519, 521, 522, 523, 525, 526, 527, 533, 534, 535, 537, 538, 539, 541, 542, 543, 549, 550, 551, 553, 554, 555, 557, 558, 559, 565, 566, 567, 569, 570, 571, 573, 574, 575, 613, 614, 615, 617, 618, 619, 621, 622, 623, 629, 630, 631, 633, 634, 635, 637, 638, 639, 645, 646, 647, 649, 650, 651, 653, 654, 655, 661, 662, 663, 665, 666, 667, 669, 670, 671],\r\n        [4, 5, 6, 7, 20, 21, 22, 23, 36, 37, 38, 39, 52, 53, 54, 55, 68, 69, 70, 71, 84, 85, 86, 87, 100, 101, 102, 103, 116, 117, 118, 119, 132, 133, 134, 135, 148, 149, 150, 151, 164, 165, 166, 167, 180, 181, 182, 183, 196, 197, 198, 199, 212, 213, 214, 215, 228, 229, 230, 231, 244, 245, 246, 247, 260, 261, 262, 263, 276, 277, 278, 279, 292, 293, 294, 295, 308, 309, 310, 311, 324, 325, 326, 327, 340, 341, 342, 343, 356, 357, 358, 359, 372, 373, 374, 375, 388, 389, 390, 391, 404, 405, 406, 407, 420, 421, 422, 423, 436, 437, 438, 439, 452, 453, 454, 455, 468, 469, 470, 471, 484, 485, 486, 487, 500, 501, 502, 503, 516, 517, 518, 519, 532, 533, 534, 535, 548, 549, 550, 551, 564, 565, 566, 567, 580, 581, 582, 583, 596, 597, 598, 599, 612, 613, 614, 615, 628, 629, 630, 631, 644, 645, 646, 647, 660, 661, 662, 663, 676, 677, 678, 679, 692, 693, 694, 695, 708, 709, 710, 711, 724, 725, 726, 727, 740, 741, 742, 743, 756, 757, 758, 759, 772, 773, 774, 775, 788, 789, 790, 791, 804, 805, 806, 807, 820, 821, 822, 823, 836, 837, 838, 839, 852, 853, 854, 855, 868, 869, 870, 871, 884, 885, 886, 887, 900, 901, 902, 903, 916, 917, 918, 919, 932, 933, 934, 935, 948, 949, 950, 951],\r\n        [16, 20, 34, 35, 38, 39, 40, 44, 58, 59, 62, 63, 112, 116, 130, 131, 134, 135, 136, 140, 154, 155, 158, 159, 208, 212, 226, 227, 230, 231, 232, 236, 250, 251, 254, 255, 304, 308, 322, 323, 326, 327, 328, 332, 346, 347, 350, 351, 400, 404, 418, 419, 422, 423, 424, 428, 442, 443, 446, 447, 496, 500, 514, 515, 518, 519, 520, 524, 538, 539, 542, 543, 592, 596, 610, 611, 614, 615, 616, 620, 634, 635, 638, 639, 688, 692, 706, 707, 710, 711, 712, 716, 730, 731, 734, 735, 784, 788, 802, 803, 806, 807, 808, 812, 826, 827, 830, 831, 880, 884, 898, 899, 902, 903, 904, 908, 922, 923, 926, 927],\r\n        [14, 15, 30, 31, 46, 47, 62, 63, 66, 67, 70, 71, 76, 77, 82, 83, 86, 87, 92, 93, 110, 111, 126, 127, 142, 143, 158, 159, 162, 163, 166, 167, 172, 173, 178, 179, 182, 183, 188, 189, 194, 195, 198, 199, 204, 205, 210, 211, 214, 215, 220, 221, 226, 227, 230, 231, 236, 237, 240, 241, 244, 245, 256, 257, 260, 261, 272, 273, 276, 277, 290, 291, 294, 295, 300, 301, 306, 307, 310, 311, 316, 317, 322, 323, 326, 327, 332, 333, 336, 337, 340, 341, 352, 353, 356, 357, 368, 369, 372, 373, 398, 399, 414, 415, 430, 431, 446, 447, 450, 451, 454, 455, 460, 461, 466, 467, 470, 471, 476, 477, 482, 483, 486, 487, 492, 493, 498, 499, 502, 503, 508, 509, 514, 515, 518, 519, 524, 525, 528, 529, 532, 533, 544, 545, 548, 549, 560, 561, 564, 565, 578, 579, 582, 583, 588, 589, 594, 595, 598, 599, 604, 605, 610, 611, 614, 615, 620, 621, 624, 625, 628, 629, 640, 641, 644, 645, 656, 657, 660, 661, 672, 673, 676, 677, 688, 689, 692, 693, 768, 769, 772, 773, 784, 785, 788, 789, 864, 865, 868, 869, 880, 881, 884, 885],\r\n        [2, 6, 10, 14, 18, 22, 26, 30, 34, 38, 42, 46, 50, 54, 58, 62, 66, 70, 74, 78, 82, 86, 90, 94, 98, 102, 106, 110, 114, 118, 122, 126, 130, 134, 138, 142, 146, 150, 154, 158, 162, 166, 170, 174, 178, 182, 186, 190, 194, 198, 202, 206, 210, 214, 218, 222, 226, 230, 234, 238, 242, 246, 250, 254, 258, 262, 266, 270, 274, 278, 282, 286, 290, 294, 298, 302, 306, 310, 314, 318, 322, 326, 330, 334, 338, 342, 346, 350, 354, 358, 362, 366, 370, 374, 378, 382, 386, 390, 394, 398, 402, 406, 410, 414, 418, 422, 426, 430, 434, 438, 442, 446, 450, 454, 458, 462, 466, 470, 474, 478, 482, 486, 490, 494, 498, 502, 506, 510, 514, 518, 522, 526, 530, 534, 538, 542, 546, 550, 554, 558, 562, 566, 570, 574, 578, 582, 586, 590, 594, 598, 602, 606, 610, 614, 618, 622, 626, 630, 634, 638, 642, 646, 650, 654, 658, 662, 666, 670, 674, 678, 682, 686, 690, 694, 698, 702, 706, 710, 714, 718, 722, 726, 730, 734, 738, 742, 746, 750, 754, 758, 762, 766, 770, 774, 778, 782, 786, 790, 794, 798, 802, 806, 810, 814, 818, 822, 826, 830, 834, 838, 842, 846, 850, 854, 858, 862, 866, 870, 874, 878, 882, 886, 890, 894, 898, 902, 906, 910, 914, 918, 922, 926, 930, 934, 938, 942, 946, 950, 954, 958],\r\n        [192, 193, 194, 196, 197, 198, 200, 201, 202, 208, 209, 210, 212, 213, 214, 216, 217, 218, 224, 225, 226, 228, 229, 230, 232, 233, 234, 240, 241, 242, 244, 245, 246, 248, 249, 250, 291, 295, 299, 307, 311, 315, 323, 327, 331, 339, 343, 347, 355, 359, 363, 368, 369, 370, 372, 373, 374, 376, 377, 378, 480, 481, 482, 484, 485, 486, 488, 489, 490, 496, 497, 498, 500, 501, 502, 504, 505, 506, 512, 513, 514, 516, 517, 518, 520, 521, 522, 528, 529, 530, 532, 533, 534, 536, 537, 538, 579, 583, 587, 595, 599, 603, 611, 615, 619, 627, 631, 635, 643, 647, 651, 656, 657, 658, 660, 661, 662, 664, 665, 666, 672, 673, 674, 676, 677, 678, 680, 681, 682, 688, 689, 690, 692, 693, 694, 696, 697, 698, 704, 705, 706, 708, 709, 710, 712, 713, 714, 720, 721, 722, 724, 725, 726, 728, 729, 730, 771, 775, 779, 787, 791, 795, 803, 807, 811, 819, 823, 827, 835, 839, 843, 848, 849, 850, 852, 853, 854, 856, 857, 858, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 931, 935, 939, 944, 945, 946, 948, 949, 950, 952, 953, 954],\r\n        [1, 2, 4, 5, 6, 8, 9, 10, 12, 13, 14, 16, 17, 18, 20, 21, 22, 24, 25, 26, 28, 29, 30, 32, 33, 34, 36, 37, 38, 40, 41, 42, 44, 45, 46, 48, 49, 50, 52, 53, 54, 56, 57, 58, 60, 61, 62, 64, 65, 66, 68, 69, 70, 72, 73, 74, 76, 77, 78, 96, 97, 98, 100, 101, 102, 104, 105, 106, 108, 109, 110, 112, 113, 114, 116, 117, 118, 120, 121, 122, 124, 125, 126, 128, 129, 130, 132, 133, 134, 136, 137, 138, 140, 141, 142, 144, 145, 146, 148, 149, 150, 152, 153, 154, 156, 157, 158, 160, 161, 162, 164, 165, 166, 168, 169, 170, 172, 173, 174, 192, 193, 194, 196, 197, 198, 200, 201, 202, 204, 205, 206, 208, 209, 210, 212, 213, 214, 216, 217, 218, 220, 221, 222, 224, 225, 226, 228, 229, 230, 232, 233, 234, 236, 237, 238, 240, 241, 242, 244, 245, 246, 248, 249, 250, 252, 253, 254, 256, 257, 258, 260, 261, 262, 264, 265, 266, 268, 269, 270, 384, 385, 386, 388, 389, 390, 392, 393, 394, 396, 397, 398, 400, 401, 402, 404, 405, 406, 408, 409, 410, 412, 413, 414, 416, 417, 418, 420, 421, 422, 424, 425, 426, 428, 429, 430, 432, 433, 434, 436, 437, 438, 440, 441, 442, 444, 445, 446, 448, 449, 450, 452, 453, 454, 456, 457, 458, 460, 461, 462, 480, 481, 482, 484, 485, 486, 488, 489, 490, 492, 493, 494, 496, 497, 498, 500, 501, 502, 504, 505, 506, 508, 509, 510, 512, 513, 514, 516, 517, 518, 520, 521, 522, 524, 525, 526, 528, 529, 530, 532, 533, 534, 536, 537, 538, 540, 541, 542, 544, 545, 546, 548, 549, 550, 552, 553, 554, 556, 557, 558, 672, 673, 674, 676, 677, 678, 680, 681, 682, 684, 685, 686, 688, 689, 690, 692, 693, 694, 696, 697, 698, 700, 701, 702, 704, 705, 706, 708, 709, 710, 712, 713, 714, 716, 717, 718, 720, 721, 722, 724, 725, 726, 728, 729, 730, 732, 733, 734, 736, 737, 738, 740, 741, 742, 744, 745, 746, 748, 749, 750]\r\n    ];\r\n    static c960range = (function () {\r\n        const arr = [...Array(961).keys()];\r\n        arr.shift();\r\n        return arr;\r\n    })();\r\n    static twins = [959, 955, 951, 947, 958, 954, 950, 946, 957, 953, 949, 945, 956, 952, 948, 944, 943, 939, 935, 931, 942, 938, 934, 930, 941, 937, 933, 929, 940, 936, 932, 928, 927, 923, 919, 915, 926, 922, 918, 914, 925, 921, 917, 913, 924, 920, 916, 912, 911, 907, 903, 899, 910, 906, 902, 898, 909, 905, 901, 897, 908, 904, 900, 896, 895, 891, 887, 883, 894, 890, 886, 882, 893, 889, 885, 881, 892, 888, 884, 880, 879, 875, 871, 867, 878, 874, 870, 866, 877, 873, 869, 865, 876, 872, 868, 864, 863, 859, 855, 851, 862, 858, 854, 850, 861, 857, 853, 849, 860, 856, 852, 848, 847, 843, 839, 835, 846, 842, 838, 834, 845, 841, 837, 833, 844, 840, 836, 832, 831, 827, 823, 819, 830, 826, 822, 818, 829, 825, 821, 817, 828, 824, 820, 816, 815, 811, 807, 803, 814, 810, 806, 802, 813, 809, 805, 801, 812, 808, 804, 800, 799, 795, 791, 787, 798, 794, 790, 786, 797, 793, 789, 785, 796, 792, 788, 784, 783, 779, 775, 771, 782, 778, 774, 770, 781, 777, 773, 769, 780, 776, 772, 768, 671, 667, 663, 659, 670, 666, 662, 658, 669, 665, 661, 657, 668, 664, 660, 656, 655, 651, 647, 643, 654, 650, 646, 642, 653, 649, 645, 641, 652, 648, 644, 640, 639, 635, 631, 627, 638, 634, 630, 626, 637, 633, 629, 625, 636, 632, 628, 624, 623, 619, 615, 611, 622, 618, 614, 610, 621, 617, 613, 609, 620, 616, 612, 608, 607, 603, 599, 595, 606, 602, 598, 594, 605, 601, 597, 593, 604, 600, 596, 592, 591, 587, 583, 579, 590, 586, 582, 578, 589, 585, 581, 577, 588, 584, 580, 576, 383, 379, 375, 371, 382, 378, 374, 370, 381, 377, 373, 369, 380, 376, 372, 368, 367, 363, 359, 355, 366, 362, 358, 354, 365, 361, 357, 353, 364, 360, 356, 352, 351, 347, 343, 339, 350, 346, 342, 338, 349, 345, 341, 337, 348, 344, 340, 336, 335, 331, 327, 323, 334, 330, 326, 322, 333, 329, 325, 321, 332, 328, 324, 320, 319, 315, 311, 307, 318, 314, 310, 306, 317, 313, 309, 305, 316, 312, 308, 304, 303, 299, 295, 291, 302, 298, 294, 290, 301, 297, 293, 289, 300, 296, 292, 288, 767, 763, 759, 755, 766, 762, 758, 754, 765, 761, 757, 753, 764, 760, 756, 752, 751, 747, 743, 739, 750, 746, 742, 738, 749, 745, 741, 737, 748, 744, 740, 736, 735, 731, 727, 723, 734, 730, 726, 722, 733, 729, 725, 721, 732, 728, 724, 720, 719, 715, 711, 707, 718, 714, 710, 706, 717, 713, 709, 705, 716, 712, 708, 704, 703, 699, 695, 691, 702, 698, 694, 690, 701, 697, 693, 689, 700, 696, 692, 688, 687, 683, 679, 675, 686, 682, 678, 674, 685, 681, 677, 673, 684, 680, 676, 672, 575, 571, 567, 563, 574, 570, 566, 562, 573, 569, 565, 561, 572, 568, 564, 560, 559, 555, 551, 547, 558, 554, 550, 546, 557, 553, 549, 545, 556, 552, 548, 544, 543, 539, 535, 531, 542, 538, 534, 530, 541, 537, 533, 529, 540, 536, 532, 528, 527, 523, 519, 515, 526, 522, 518, 514, 525, 521, 517, 513, 524, 520, 516, 512, 511, 507, 503, 499, 510, 506, 502, 498, 509, 505, 501, 497, 508, 504, 500, 496, 495, 491, 487, 483, 494, 490, 486, 482, 493, 489, 485, 481, 492, 488, 484, 480, 287, 283, 279, 275, 286, 282, 278, 274, 285, 281, 277, 273, 284, 280, 276, 272, 271, 267, 263, 259, 270, 266, 262, 258, 269, 265, 261, 257, 268, 264, 260, 256, 255, 251, 247, 243, 254, 250, 246, 242, 253, 249, 245, 241, 252, 248, 244, 240, 239, 235, 231, 227, 238, 234, 230, 226, 237, 233, 229, 225, 236, 232, 228, 224, 223, 219, 215, 211, 222, 218, 214, 210, 221, 217, 213, 209, 220, 216, 212, 208, 207, 203, 199, 195, 206, 202, 198, 194, 205, 201, 197, 193, 204, 200, 196, 192, 479, 475, 471, 467, 478, 474, 470, 466, 477, 473, 469, 465, 476, 472, 468, 464, 463, 459, 455, 451, 462, 458, 454, 450, 461, 457, 453, 449, 460, 456, 452, 448, 447, 443, 439, 435, 446, 442, 438, 434, 445, 441, 437, 433, 444, 440, 436, 432, 431, 427, 423, 419, 430, 426, 422, 418, 429, 425, 421, 417, 428, 424, 420, 416, 415, 411, 407, 403, 414, 410, 406, 402, 413, 409, 405, 401, 412, 408, 404, 400, 399, 395, 391, 387, 398, 394, 390, 386, 397, 393, 389, 385, 396, 392, 388, 384, 191, 187, 183, 179, 190, 186, 182, 178, 189, 185, 181, 177, 188, 184, 180, 176, 175, 171, 167, 163, 174, 170, 166, 162, 173, 169, 165, 161, 172, 168, 164, 160, 159, 155, 151, 147, 158, 154, 150, 146, 157, 153, 149, 145, 156, 152, 148, 144, 143, 139, 135, 131, 142, 138, 134, 130, 141, 137, 133, 129, 140, 136, 132, 128, 127, 123, 119, 115, 126, 122, 118, 114, 125, 121, 117, 113, 124, 120, 116, 112, 111, 107, 103, 99, 110, 106, 102, 98, 109, 105, 101, 97, 108, 104, 100, 96, 95, 91, 87, 83, 94, 90, 86, 82, 93, 89, 85, 81, 92, 88, 84, 80, 79, 75, 71, 67, 78, 74, 70, 66, 77, 73, 69, 65, 76, 72, 68, 64, 63, 59, 55, 51, 62, 58, 54, 50, 61, 57, 53, 49, 60, 56, 52, 48, 47, 43, 39, 35, 46, 42, 38, 34, 45, 41, 37, 33, 44, 40, 36, 32, 31, 27, 23, 19, 30, 26, 22, 18, 29, 25, 21, 17, 28, 24, 20, 16, 15, 11, 7, 3, 14, 10, 6, 2, 13, 9, 5, 1, 12, 8, 4, 0];\r\n    static legacy = {\r\n        legacy2PThreshold: 1000,\r\n        legacy2PRank: 3, legacy4Prank: 0,\r\n        legacy2PTakeaway: 6160\r\n    };\r\n    static displacement = [3, 11];\r\n    static createBaseChess960mappings() {\r\n        return {\r\n            colorBoundPieces: [2, 5],\r\n            supermajorPieces: [3],\r\n            minorPieces: [1, 6],\r\n            royalPiece: [4],\r\n            edgePieces: [0, 7]\r\n        };\r\n    }\r\n    static regExp = /Chess960=(\\d{1,5})/i;\r\n    positionID;\r\n    constructor(positionID) {\r\n        super();\r\n        if (typeof positionID === \"number\") {\r\n            this.positionID = positionID;\r\n        }\r\n        else {\r\n            this.positionID = -1;\r\n        }\r\n    }\r\n    getDecoratorType() { return Board; }\r\n    getParameterValue() { return this.positionID; }\r\n    matchesPGNDeclaration(match) {\r\n        const matchArray = match.match(Chess960.regExp);\r\n        if (matchArray) {\r\n            const newID = Number(matchArray[1]);\r\n            if (newID < 0 || newID > 15760)\r\n                return false;\r\n            this.positionID = newID;\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    serializeToParsingForm() {\r\n        return `Chess960=${this.positionID}`;\r\n    }\r\n    getInformation() {\r\n        return { name: \"Chess960\", description: \"Initial position with randomly shuffled pieces on home ranks\", tag };\r\n    }\r\n    initDecoratorSettings() {\r\n        if (this.positionID === -1)\r\n            throw new Error(\"Position ID for Chess960 is not defined\");\r\n        let nr = this.positionID;\r\n        const boardSquares = this.decorator.board;\r\n        let rank = Chess960.chess960ranges.findIndex((r) => nr >= r[0] && nr <= r[1]);\r\n        if (rank === -1) {\r\n            if (nr > Chess960.legacy.legacy2PThreshold) {\r\n                rank = Chess960.legacy.legacy2PRank;\r\n                nr -= Chess960.legacy.legacy2PTakeaway;\r\n            }\r\n            else {\r\n                rank = Chess960.legacy.legacy4Prank;\r\n            }\r\n        }\r\n        const pieceArrays = [[], [], [], []];\r\n        const ranks = [13 - rank, rank, rank, 13 - rank];\r\n        pieceArrays[0] = boardSquares[ranks[0]].slice(Chess960.displacement[0], Chess960.displacement[1]);\r\n        pieceArrays[1] = boardSquares.map((row) => row[ranks[1]]).slice(Chess960.displacement[0], Chess960.displacement[1]);\r\n        pieceArrays[2] = boardSquares[ranks[2]].slice(Chess960.displacement[0], Chess960.displacement[1]);\r\n        pieceArrays[3] = boardSquares.map((row) => row[ranks[3]]).slice(Chess960.displacement[0], Chess960.displacement[1]);\r\n        const walls = pieceArrays.map(a => a.map(p => p.isWall() ? true : false));\r\n        const intersections = [];\r\n        for (const wall of walls) {\r\n            intersections.push(wall.reduce((p, c, i) => {\r\n                if (c) {\r\n                    return p.filter(v => Chess960.pieceMasks[i].includes(v));\r\n                }\r\n                else\r\n                    return p;\r\n            }, Chess960.c960range));\r\n        }\r\n        const calcNr = nr - Chess960.chess960ranges[rank][0];\r\n        const positions = [];\r\n        const generatePositionIndexes = (calcNr) => {\r\n            const colorBoundIndexes = [2 * Math.floor((calcNr % 16 / 4)), 1 + 2 * (calcNr % 16 % 4)].sort();\r\n            const supermajorIndex = Math.floor(calcNr / 16) % 6;\r\n            const minorPieceIndexes = Chess960.minorPieceCache[Math.floor(calcNr / 96) % 10];\r\n            const position = {\r\n                colorBoundPieces: Array(8).fill(false),\r\n                supermajorPieces: Array(8).fill(false),\r\n                minorPieces: Array(8).fill(false),\r\n                royalPiece: Array(8).fill(false),\r\n                edgePieces: Array(8).fill(false)\r\n            };\r\n            let edgeSet = false, royalSet = false, colorDelta = 0, majorDelta = 0;\r\n            for (let i = 0; i < boardDimension - Chess960.displacement[0] * 2; i++) {\r\n                if (i === colorBoundIndexes[0] || i === colorBoundIndexes[1]) {\r\n                    position.colorBoundPieces[i] = true;\r\n                    colorDelta++;\r\n                }\r\n                else if (i === supermajorIndex + colorDelta) {\r\n                    position.supermajorPieces[i] = true;\r\n                    majorDelta++;\r\n                }\r\n                else if (i === minorPieceIndexes[0] + colorDelta + majorDelta || i === minorPieceIndexes[1] + colorDelta + majorDelta) {\r\n                    position.minorPieces[i] = true;\r\n                }\r\n                else {\r\n                    position[edgeSet ? royalSet ? \"edgePieces\" : \"royalPiece\" : \"edgePieces\"][i] = true;\r\n                    royalSet = edgeSet;\r\n                    edgeSet = true;\r\n                }\r\n            }\r\n            return position;\r\n        };\r\n        for (const intersection of intersections) {\r\n            if (intersection.length === 0)\r\n                return null;\r\n            let calcTempNr = calcNr;\r\n            let cycles = 0;\r\n            while (cycles < 2) {\r\n                if (intersection.includes(calcTempNr)) {\r\n                    positions.push(generatePositionIndexes(calcTempNr));\r\n                    break;\r\n                }\r\n                else if (intersection.includes(Chess960.twins[calcTempNr - 1])) {\r\n                    positions.push(generatePositionIndexes(Chess960.twins[calcTempNr - 1]));\r\n                    break;\r\n                }\r\n                calcTempNr++;\r\n                if (calcTempNr === 960)\r\n                    calcTempNr = 0, cycles++;\r\n            }\r\n            if (cycles === 2)\r\n                intersections.push([]);\r\n        }\r\n        const fenData = this.decorator.data;\r\n        const royalPieces = fenData.fenOptions.royal;\r\n        const royalOnCorrectRank = royalPieces.map((r, i) => r !== null ? r[i % 2 === 0 ? 0 : 1] === ranks[i] ? r[i % 2 === 0 ? 1 : 0] : -1 : -1);\r\n        const replaceRow = (player) => {\r\n            const pieces = Chess960.createBaseChess960mappings();\r\n            const royal = fenData.fenOptions.royal[player];\r\n            if (!royal)\r\n                return;\r\n            const r = royal[player % 2 === 0 ? 1 : 0];\r\n            const supermajorOverRoyal = royalOnCorrectRank[player] ? r <= 6 : false;\r\n            for (let i = Chess960.displacement[0]; i < Chess960.displacement[1]; i++) {\r\n                let k;\r\n                for (k in pieces) {\r\n                    if (!Object.prototype.hasOwnProperty.call(pieces, k) || !positions[player][k][i - 3])\r\n                        continue;\r\n                    if (royalOnCorrectRank[player] !== -1 && k === 'royalPiece' && r !== i) {\r\n                        royal[player % 2 === 0 ? 1 : 0] = i;\r\n                    }\r\n                    const mI = supermajorOverRoyal ? intersections[player].length === 960 ? boardDimension - 1 - i : i : i;\r\n                    const piece = pieces[k].shift();\r\n                    if (piece !== undefined) {\r\n                        boardSquares[player % 2 === 0 ? ranks[player] : mI][player % 2 === 0 ? mI : ranks[player]] =\r\n                            pieceArrays[player][piece];\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        for (let i = 0; i < totalPlayers; i++)\r\n            replaceRow(i);\r\n        this.wrappingDecorator?.initDecoratorSettings?.();\r\n    }\r\n}\r\n","import { Board } from \"../../../Board/Board\";\r\nimport { boardDimension } from \"../../../GameInformation/GameData\";\r\nimport { VariantRule } from \"../../VariantRuleInterface\";\r\nimport { pieceControlConfigSettings } from \"@moveGeneration/PieceControl/PieceControlInterface\";\r\nimport { FiftyMoveRule } from \"../FENDataDecorators/FiftyMoveRule\";\r\nconst tag = \"crazyhouse\";\r\nexport class Crazyhouse extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(Crazyhouse);\r\n    }\r\n    dependencies = new Map([[FiftyMoveRule, [Infinity]]]);\r\n    getDecoratorType() { return Board; }\r\n    getParameterValue() { return true; }\r\n    matchesPGNDeclaration(match) {\r\n        return /^Crazyhouse$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"Crazyhouse\";\r\n    }\r\n    getInformation() {\r\n        return { name: \"Crazyhouse\", description: \"You can drop pieces from banks\", tag };\r\n    }\r\n    initDecoratorSettings() {\r\n        this.decorator.data.fenOptions.areBanksEnabled = [true, true, true, true];\r\n        this.wrappingDecorator?.initDecoratorSettings?.();\r\n    }\r\n    getDroppingMoves(piece, color = this.decorator.data.sideToMove) {\r\n        if (piece.color !== color)\r\n            return [];\r\n        const royal = this.decorator.data.fenOptions.royal[color];\r\n        if (royal && this.decorator.preGeneratedAttacks.hoppingPieces[royal[0]][royal[1]])\r\n            return [];\r\n        const isPawn = pieceControlConfigSettings[piece.piece].moveGenerationSettings.isPawn;\r\n        const resultingMoveDrops = [];\r\n        const isRY = color % 2 === 0;\r\n        const pawnPromotionRank = this.decorator.variantData.promotionRank === false ? -1 : this.decorator.variantData.promotionRank;\r\n        const pawnBaseRank = this.decorator.data.fenOptions.pawnBaseRank;\r\n        for (let i = 0; i < boardDimension; i++) {\r\n            if (isPawn && isRY && (pawnPromotionRank === i || pawnBaseRank === i)) {\r\n                continue;\r\n            }\r\n            for (let j = 0; j < boardDimension; j++) {\r\n                if (isPawn && !isRY && (pawnPromotionRank === j || pawnBaseRank === j)) {\r\n                    continue;\r\n                }\r\n                const square = this.decorator.board[i][j];\r\n                if (!square.isEmpty())\r\n                    continue;\r\n                resultingMoveDrops.push({ piece, endCoordinates: [i, j] });\r\n            }\r\n        }\r\n        if (this.decorator.isKingInCheck(color)) {\r\n            return resultingMoveDrops.filter(moveDrop => {\r\n                const snapshot = this.decorator.createSnapshot();\r\n                const { checks, checkmates } = this.decorator.makeMove([moveDrop], true);\r\n                let isKingInCheck = checks[color] || checkmates[color];\r\n                if (!isKingInCheck) {\r\n                    this.decorator.pregenerateAttacks(color);\r\n                    isKingInCheck = this.decorator.isKingInCheck(color);\r\n                }\r\n                this.decorator.loadSnapshot(snapshot);\r\n                return !isKingInCheck;\r\n            }); // TODO legal moves\r\n        }\r\n        else {\r\n            return resultingMoveDrops;\r\n        }\r\n    }\r\n}\r\n","import { Board } from \"../../../Board/Board\";\r\nimport { VariantRule } from \"../../VariantRuleInterface\";\r\nimport { CaptureTheKing } from \"./CaptureTheKing\";\r\nimport { getLatestChainedMoves } from \"../../../MoveTree/MoveTree\";\r\nimport { duckPieceString, nonPlayablePieces } from \"../../../GameInformation/GameUnits/PieceString\";\r\nimport { boardDimension } from \"../../../GameInformation/GameData\";\r\nconst tag = \"duckChess\";\r\nexport class DuckChess extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(DuckChess);\r\n    }\r\n    dependencies = new Map([[CaptureTheKing, []]]);\r\n    getDecoratorType() { return Board; }\r\n    getParameterValue() { return true; }\r\n    matchesPGNDeclaration(match) {\r\n        return /^DuckChess$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"DuckChess\";\r\n    }\r\n    getInformation() {\r\n        return {\r\n            name: \"Duck Chess\",\r\n            description: \"The duck must be moved to an empty square after every move\",\r\n            tag\r\n        };\r\n    }\r\n    getLegalMoves(i, j, baseColor = this.decorator.data.sideToMove, isSeirawanDrop = false) {\r\n        const moves = this.wrappingDecorator?.getLegalMoves\r\n            ? this.wrappingDecorator.getLegalMoves(i, j, baseColor, isSeirawanDrop)\r\n            : Board.prototype.getLegalMoves.call(this.decorator, i, j, baseColor, isSeirawanDrop);\r\n        const latestMoves = getLatestChainedMoves(moves);\r\n        const ducks = [], emptySquares = [];\r\n        for (let i = 0; i < boardDimension; i++) {\r\n            for (let j = 0; j < boardDimension; j++) {\r\n                const pieceString = this.decorator.board[i][j];\r\n                if (pieceString.isWall() && pieceString.piece === nonPlayablePieces.duck) {\r\n                    ducks.push([i, j]);\r\n                }\r\n                else if (pieceString.isEmpty()) {\r\n                    emptySquares.push([i, j]);\r\n                }\r\n            }\r\n        }\r\n        const droppingChainedMoves = [];\r\n        const duckChainedMoves = [];\r\n        if (ducks.length === 0) {\r\n            for (const emptySquare of emptySquares) {\r\n                droppingChainedMoves.push({ piece: duckPieceString, endCoordinates: emptySquare });\r\n            }\r\n            droppingChainedMoves.push({ piece: duckPieceString, endCoordinates: [i, j] });\r\n        }\r\n        else {\r\n            for (const duck of ducks) {\r\n                for (const emptySquare of emptySquares) {\r\n                    duckChainedMoves.push({ startCoordinates: duck, endCoordinates: emptySquare });\r\n                }\r\n                duckChainedMoves.push({ startCoordinates: duck, endCoordinates: [i, j] });\r\n            }\r\n        }\r\n        for (const move of latestMoves) {\r\n            move.nextChainedMoves = droppingChainedMoves.length > 0 ? droppingChainedMoves : duckChainedMoves;\r\n        }\r\n        return moves;\r\n    }\r\n}\r\n","import { createTupleFromCallback } from \"../../../../../baseTypes\";\r\nimport { initializeBoardSquares } from \"../../../../BaseInterfaces\";\r\nimport { Board } from \"../../../Board/Board\";\r\nimport { stringifyCoordinate } from \"../../../Board/BoardInterface\";\r\nimport { boardDimension } from \"../../../GameInformation/GameData\";\r\nimport { VariantRule } from \"../../VariantRuleInterface\";\r\nimport { CaptureTheKing } from \"./CaptureTheKing\";\r\nconst tag = \"fogOfWar\";\r\nexport class FogOfWar extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(FogOfWar);\r\n    }\r\n    dependencies = new Map([[CaptureTheKing, []]]);\r\n    currentPlayerMoves = initializeBoardSquares(() => false);\r\n    getDecoratorType() { return Board; }\r\n    getParameterValue() { return true; }\r\n    matchesPGNDeclaration(match) {\r\n        return /^FogOfWar$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"FogOfWar\";\r\n    }\r\n    getInformation() {\r\n        return { name: \"Fog of War\", description: \"Players can only see their pieces and the squares they can legally move to\", tag };\r\n    }\r\n    pregenerateAttacks(sideToMove = this.decorator.data.sideToMove) {\r\n        if (this.wrappingDecorator?.pregenerateAttacks) {\r\n            this.wrappingDecorator.pregenerateAttacks(sideToMove);\r\n        }\r\n        else {\r\n            Board.prototype.pregenerateAttacks.call(this.decorator, sideToMove);\r\n        }\r\n        this.currentPlayerMoves = initializeBoardSquares(() => false);\r\n        for (const piece of this.decorator.getPlayerPieces()[sideToMove]) {\r\n            this.currentPlayerMoves[piece[0]][piece[1]] = true;\r\n            const moves = this.decorator.preGeneratedAttacks.pieceMovements.get(stringifyCoordinate(piece));\r\n            if (moves) {\r\n                for (const { move: coordinate } of moves) {\r\n                    this.currentPlayerMoves[coordinate[0]][coordinate[1]] = true;\r\n                }\r\n            }\r\n        }\r\n        for (const move of [...this.decorator.preGeneratedAttacks.pieceDrops.pawn,\r\n            ...this.decorator.preGeneratedAttacks.pieceDrops.piece]) {\r\n            this.currentPlayerMoves[move.endCoordinates[0]][move.endCoordinates[1]] = true;\r\n        }\r\n    }\r\n    getSquareVisibility() {\r\n        if (this.wrappingDecorator?.getSquareVisibility) {\r\n            return this.wrappingDecorator.getSquareVisibility().map((r, i) => r.map((v, j) => {\r\n                if (this.decorator.board[i][j].isWall() || this.currentPlayerMoves[i][j]) {\r\n                    return v;\r\n                }\r\n                else {\r\n                    return [...v, 1 /* DisplaySettings.Fogged */];\r\n                }\r\n            }));\r\n        }\r\n        else {\r\n            return createTupleFromCallback((_, i) => createTupleFromCallback((_, j) => {\r\n                if (this.decorator.board[i][j].isWall() || this.currentPlayerMoves[i][j]) {\r\n                    return [];\r\n                }\r\n                else {\r\n                    return [1 /* DisplaySettings.Fogged */];\r\n                }\r\n            }, boardDimension), boardDimension);\r\n        }\r\n    }\r\n}\r\n","import { Board } from \"../../../Board/Board\";\r\nimport { stringifyCoordinate } from \"../../../Board/BoardInterface\";\r\nimport { VariantRule } from \"../../VariantRuleInterface\";\r\nconst tag = \"forcedCapture\";\r\nexport class ForcedCapture extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(ForcedCapture);\r\n    }\r\n    hasCaptures = false;\r\n    getDecoratorType() { return Board; }\r\n    getParameterValue() { return true; }\r\n    matchesPGNDeclaration(match) {\r\n        return /^ForcedCapture$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"ForcedCapture\";\r\n    }\r\n    getInformation() {\r\n        return { name: \"Forced Capture\", description: \"Capturing is always compulsory\", tag };\r\n    }\r\n    pregenerateAttacks(sideToMove = this.decorator.data.sideToMove) {\r\n        if (this.wrappingDecorator?.pregenerateAttacks) {\r\n            this.wrappingDecorator.pregenerateAttacks(sideToMove);\r\n        }\r\n        else {\r\n            Board.prototype.pregenerateAttacks.call(this.decorator, sideToMove);\r\n        }\r\n        this.hasCaptures = false;\r\n        for (const piece of this.decorator.getPlayerPieces()[sideToMove]) {\r\n            const moves = this.decorator.preGeneratedAttacks.pieceMovements.get(stringifyCoordinate(piece));\r\n            if (moves) {\r\n                for (const { move: coordinate } of moves) {\r\n                    if (this.decorator.board[coordinate[0]][coordinate[1]].isPiece()) {\r\n                        this.hasCaptures = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    isTheMoveLegal(color, moveData) {\r\n        const isCapturing = this.decorator.data.getCapturedPieces(moveData).length > 0;\r\n        if (!isCapturing && this.hasCaptures)\r\n            return false;\r\n        if (this.wrappingDecorator?.isTheMoveLegal) {\r\n            return this.wrappingDecorator.isTheMoveLegal(color, moveData);\r\n        }\r\n        else {\r\n            return Board.prototype.isTheMoveLegal.call(this.decorator, color, moveData);\r\n        }\r\n    }\r\n}\r\n","import { shuffleArray } from \"../../../../utils/ArrayUtils\";\r\nimport { Board } from \"../../../Board/Board\";\r\nimport { totalPlayers } from \"../../../GameInformation/GameData\";\r\nimport { verifyNumericColor } from \"../../../GameInformation/GameUnits/GameUnits\";\r\nimport { VariantRule } from \"../../VariantRuleInterface\";\r\nconst tag = \"anonymous\";\r\nexport class Anonymous extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(Anonymous);\r\n    }\r\n    getDecoratorType() { return Board; }\r\n    getParameterValue() { return true; }\r\n    matchesPGNDeclaration(match) {\r\n        return /^Anonymous$/i.test(match);\r\n    }\r\n    getInformation() {\r\n        return { name: \"Anonymous\", description: \"Players' names and ratings are hidden\", tag };\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"Anonymous\";\r\n    }\r\n    initDecoratorSettings() {\r\n        for (let i = 0; i < totalPlayers; i++) {\r\n            this.decorator.gameData.players[i].name = \"Anonymous\";\r\n            this.decorator.gameData.players[i].elo = undefined;\r\n        }\r\n        this.wrappingDecorator?.initDecoratorSettings?.();\r\n    }\r\n}\r\nconst semiAnonTag = \"semiAnonymous\";\r\nexport class SemiAnonymous extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(Anonymous);\r\n    }\r\n    getDecoratorType() { return Board; }\r\n    getParameterValue() { return true; }\r\n    matchesPGNDeclaration(match) {\r\n        return /^Semi-Anonymous$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"Semi-Anonymous\";\r\n    }\r\n    getInformation() {\r\n        return { name: \"Semi-Anonymous\", description: \"Players's colors are hidden\", tag: semiAnonTag };\r\n    }\r\n    initDecoratorSettings() {\r\n        shuffleArray(this.decorator.gameData.players);\r\n        this.wrappingDecorator?.initDecoratorSettings?.();\r\n    }\r\n}\r\nconst spTag = \"selfPartner\";\r\nexport class SelfPartner extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(SelfPartner);\r\n    }\r\n    getDecoratorType() { return Board; }\r\n    getParameterValue() { return true; }\r\n    matchesPGNDeclaration(match) {\r\n        return /^SelfPartner$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"SelfPartner\";\r\n    }\r\n    getInformation() {\r\n        return { name: \"Self-Partner\", description: \"Both sides of the team were played by one player\", tag: spTag };\r\n    }\r\n    initDecoratorSettings() {\r\n        this.wrappingDecorator?.initDecoratorSettings?.();\r\n        const gameType = this.decorator.gameType;\r\n        const firstTeamPlayer = gameType.teamSettings.firstTeamColors.indexOf(true), secondTeamPlayer = gameType.teamSettings.secondTeamColors.indexOf(true);\r\n        if (verifyNumericColor(firstTeamPlayer)) {\r\n            this.decorator.gameData.players[gameType.getTeammateColor(firstTeamPlayer)].name\r\n                = this.decorator.gameData.players[firstTeamPlayer].name;\r\n        }\r\n        if (verifyNumericColor(secondTeamPlayer)) {\r\n            this.decorator.gameData.players[gameType.getTeammateColor(secondTeamPlayer)].name\r\n                = this.decorator.gameData.players[secondTeamPlayer].name;\r\n        }\r\n    }\r\n}\r\n","import { initializeBoardSquares } from \"../../../../BaseInterfaces\";\r\nimport { Board } from \"../../../Board/Board\";\r\nimport { VariantRule } from \"../../VariantRuleInterface\";\r\nconst tag = \"ghostboard\";\r\nexport class Ghostboard extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(Ghostboard);\r\n    }\r\n    getDecoratorType() { return Board; }\r\n    getParameterValue() { return true; }\r\n    matchesPGNDeclaration(match) {\r\n        return /^Ghostboard$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"Ghostboard\";\r\n    }\r\n    getInformation() {\r\n        return { name: \"Ghostboard\", description: \"Board, clocks and players are invisible\", tag };\r\n    }\r\n    getSquareVisibility() {\r\n        if (this.wrappingDecorator?.getSquareVisibility) {\r\n            return this.wrappingDecorator.getSquareVisibility().map(r => r.map(v => [...v, 2 /* DisplaySettings.Ghosted */]));\r\n        }\r\n        else {\r\n            return initializeBoardSquares(() => [2 /* DisplaySettings.Ghosted */]);\r\n        }\r\n    }\r\n}\r\n","import { Board } from \"../../../Board/Board\";\r\nimport { VariantRule } from \"../../VariantRuleInterface\";\r\nconst tag = \"paradigmChess30\";\r\nexport class ParadigmChess30 extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(ParadigmChess30);\r\n    }\r\n    static paradigmRanges = [...Array.from({ length: 14 }, (_, i) => [30 * (i + 1) + 1, 30 + 30 * (i + 1)])];\r\n    // 0 = color bound, 1 = minor, 2 = major\r\n    static permutations = [[0, 0, 1, 1, 2], [0, 0, 1, 2, 1], [0, 0, 2, 1, 1], [0, 1, 0, 1, 2], [0, 1, 0, 2, 1], [0, 1, 1, 0, 2],\r\n        [0, 1, 1, 2, 0], [0, 1, 2, 0, 1], [0, 1, 2, 1, 0], [0, 2, 0, 1, 1], [0, 2, 1, 0, 1], [0, 2, 1, 1, 0],\r\n        [1, 0, 0, 1, 2], [1, 0, 0, 2, 1], [1, 0, 1, 0, 2], [1, 0, 1, 2, 0], [1, 0, 2, 0, 1], [1, 0, 2, 1, 0],\r\n        [1, 1, 0, 0, 2], [1, 1, 0, 2, 0], [1, 1, 2, 0, 0], [1, 2, 0, 0, 1], [1, 2, 0, 1, 0], [1, 2, 1, 0, 0],\r\n        [2, 0, 0, 1, 1], [2, 0, 1, 0, 1], [2, 0, 1, 1, 0], [2, 1, 0, 0, 1], [2, 1, 0, 1, 0], [2, 1, 1, 0, 0]];\r\n    static legacy = {\r\n        twoPlayerRank: 3,\r\n        twoPlayerAdjustment: 30 * 4\r\n    };\r\n    preMethodExecution = false;\r\n    positionId;\r\n    constructor(positionId) {\r\n        super();\r\n        if (typeof positionId === \"number\") {\r\n            this.positionId = positionId;\r\n        }\r\n        else {\r\n            this.positionId = -1;\r\n        }\r\n    }\r\n    getParameterValue() { return this.positionId; }\r\n    getDecoratorType() { return Board; }\r\n    matchesPGNDeclaration(match) {\r\n        const matchArray = match.match(/^ParadigmChess30=((\\d{1,3}))$/i);\r\n        if (matchArray) {\r\n            const newID = Number(matchArray[1]);\r\n            if (newID < 0 || newID > 450)\r\n                return false;\r\n            this.positionId = newID;\r\n            return true;\r\n        }\r\n        else\r\n            return false;\r\n    }\r\n    serializeToParsingForm() {\r\n        return `ParadigmChess30=${this.positionId}`;\r\n    }\r\n    getInformation() {\r\n        return { name: \"Paradigm Chess30\", description: \"Paradigm Chess30: Dragon bishops combine the movement of bishop and xiangqi horse. 30 semi-random starting positions\", tag };\r\n    }\r\n    initDecoratorSettings() {\r\n        if (this.positionId === -1)\r\n            throw new Error(\"Position ID for Paradigm Chess30 is not defined\");\r\n        let nr = this.positionId;\r\n        const boardSquares = this.decorator.board;\r\n        const data = this.decorator.data;\r\n        let rank = ParadigmChess30.paradigmRanges.findIndex((r) => nr >= r[0] && nr <= r[1]);\r\n        if (rank === -1) {\r\n            rank = ParadigmChess30.legacy.twoPlayerRank;\r\n            nr += ParadigmChess30.legacy.twoPlayerAdjustment;\r\n        }\r\n        const calcNr = nr - ParadigmChess30.paradigmRanges[rank][0];\r\n        const ranks = [13 - rank, rank, rank, 13 - rank];\r\n        const pieceArrays = [[], [], [], []];\r\n        pieceArrays[0] = boardSquares[ranks[0]].slice(4, 10);\r\n        pieceArrays[1] = boardSquares.map((row) => row[ranks[1]]).slice(4, 10);\r\n        pieceArrays[2] = boardSquares[ranks[2]].slice(4, 10);\r\n        pieceArrays[3] = boardSquares.map((row) => row[ranks[3]]).slice(4, 10);\r\n        const replaceRow = (player) => {\r\n            const royalPieces = data.fenOptions.royal;\r\n            const r = royalPieces[player]?.[player % 2 === 0 ? 1 : 0];\r\n            const pieceCoordinates = [[5, 8], [4, 9], [r === undefined || r >= 7 ? 6 : 7]];\r\n            const moveCoordinate = (i, iter) => {\r\n                if (data.fenOptions.dead[player])\r\n                    return;\r\n                const coordinateA = player % 2 === 0 ? ranks[player] : iter;\r\n                const coordinateB = player % 2 === 0 ? iter : ranks[player];\r\n                if (pieceArrays[player][pieceCoordinates[i][0] - 4].isWall()\r\n                    || boardSquares[coordinateA][coordinateB].isWall())\r\n                    return;\r\n                royalPieces.some((r) => {\r\n                    if (r && r[0] === coordinateA && r[1] === coordinateB) {\r\n                        r[0] = coordinateB, r[1] = coordinateA;\r\n                        return true;\r\n                    }\r\n                    return false;\r\n                });\r\n                boardSquares[coordinateA][coordinateB] = pieceArrays[player][(pieceCoordinates[i].shift() ?? 4) - 4];\r\n            };\r\n            let c = 0;\r\n            const rp = r === undefined || r >= 7 ? 7 : 6;\r\n            const permutations = rp === 6 ? ParadigmChess30.permutations[calcNr].slice().reverse() : ParadigmChess30.permutations[calcNr];\r\n            for (let i = 4; i < 10; i++) {\r\n                if (i === rp)\r\n                    continue;\r\n                moveCoordinate(permutations[c++], i);\r\n            }\r\n        };\r\n        for (let i = 0; i < 4; i++)\r\n            replaceRow(i);\r\n        this.wrappingDecorator?.initDecoratorSettings?.();\r\n    }\r\n}\r\n","import { createTupleFromCallback } from \"../../../../../baseTypes\";\r\nimport { Board } from \"../../../Board/Board\";\r\nimport { boardDimension } from \"../../../GameInformation/GameData\";\r\nimport { VariantRule } from \"../../VariantRuleInterface\";\r\nconst tag = \"piecesFaceCenter\";\r\nexport class PiecesFaceCenter extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(PiecesFaceCenter);\r\n    }\r\n    getDecoratorType() { return Board; }\r\n    getParameterValue() { return true; }\r\n    matchesPGNDeclaration(match) {\r\n        return /^PiecesFaceCenter$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"PiecesFaceCenter\";\r\n    }\r\n    getInformation() {\r\n        return { name: \"Pieces Face Center\", description: \"Pieces are rotated to face center\", tag };\r\n    }\r\n    getSquareVisibility() {\r\n        if (this.wrappingDecorator?.getSquareVisibility) {\r\n            return this.wrappingDecorator.getSquareVisibility().map((r, i) => r.map((v, j) => {\r\n                if (!this.decorator.board[i][j].isPiece()) {\r\n                    return v;\r\n                }\r\n                else {\r\n                    return [...v, 4 /* DisplaySettings.PieceFacesCenter */];\r\n                }\r\n            }));\r\n        }\r\n        else {\r\n            return createTupleFromCallback((_, i) => createTupleFromCallback((_, j) => {\r\n                if (!this.decorator.board[i][j].isPiece()) {\r\n                    return [];\r\n                }\r\n                else {\r\n                    return [4 /* DisplaySettings.PieceFacesCenter */];\r\n                }\r\n            }, boardDimension), boardDimension);\r\n        }\r\n    }\r\n}\r\n","import { Board } from \"../../../Board/Board\";\r\nimport { stringifyCoordinate } from \"../../../Board/BoardInterface\";\r\nimport { colors } from \"../../../GameInformation/GameData\";\r\nimport { verifyStandardMove } from \"../../../MoveTree/MoveTree\";\r\nimport { VariantRule } from \"../../VariantRuleInterface\";\r\nconst tag = \"seirawanSetup\";\r\nexport class SeirawanSetup extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(SeirawanSetup);\r\n    }\r\n    isDisabled = [false, false, false, false];\r\n    getDecoratorType() { return Board; }\r\n    getParameterValue() { return true; }\r\n    matchesPGNDeclaration(match) {\r\n        return /^SeirawanSetup$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"SeirawanSetup\";\r\n    }\r\n    getInformation() {\r\n        return {\r\n            name: \"Seirawan Setup\",\r\n            description: \"When moving a piece for the first time, a piece from the bank can be placed on the vacated square, as part of the move\",\r\n            tag\r\n        };\r\n    }\r\n    initDecoratorSettings() {\r\n        const { areBanksEnabled, dead, bank, seirawanDrops } = this.decorator.data.fenOptions;\r\n        for (const color of colors) {\r\n            if (!dead[color] && seirawanDrops[color].size > 0 && bank[color].size > 0) {\r\n                areBanksEnabled[color] = true;\r\n            }\r\n        }\r\n        if (this.wrappingDecorator?.initDecoratorSettings) {\r\n            this.wrappingDecorator.initDecoratorSettings();\r\n        }\r\n    }\r\n    makeMove(move, ignoreNextMoves) {\r\n        const { fenOptions: { seirawanDrops, bank, areBanksEnabled }, sideToMove } = this.decorator.data;\r\n        let disabledIndex = false;\r\n        if (verifyStandardMove(move[0])) {\r\n            seirawanDrops[sideToMove].delete(stringifyCoordinate(move[0].startCoordinates));\r\n            if (seirawanDrops[sideToMove].size === 0 || bank[sideToMove].size === 0) {\r\n                disabledIndex = true;\r\n            }\r\n        }\r\n        const returnValue = this.wrappingDecorator?.makeMove\r\n            ? this.wrappingDecorator.makeMove(move, ignoreNextMoves)\r\n            : Board.prototype.makeMove.call(this.decorator, move, ignoreNextMoves);\r\n        if (disabledIndex) {\r\n            this.isDisabled[sideToMove] = true;\r\n            seirawanDrops[sideToMove].clear();\r\n            bank[sideToMove].clear();\r\n            areBanksEnabled[sideToMove] = false;\r\n        }\r\n        return returnValue;\r\n    }\r\n    getLegalMoves(i, j, baseColor = this.decorator.data.sideToMove) {\r\n        const { sideToMove, fenOptions: { seirawanDrops: seirawanDrops, bank } } = this.decorator.data;\r\n        const startCoordinates = [i, j];\r\n        const stringifiedCoordinate = stringifyCoordinate(startCoordinates);\r\n        const coordinate = [...seirawanDrops[sideToMove]].find(c => c === stringifiedCoordinate);\r\n        const validateWithDrops = bank[sideToMove].size !== 0 && coordinate !== undefined;\r\n        const moves = this.wrappingDecorator?.getLegalMoves\r\n            ? this.wrappingDecorator.getLegalMoves(i, j, baseColor, validateWithDrops)\r\n            : Board.prototype.getLegalMoves.call(this.decorator, i, j, baseColor, validateWithDrops);\r\n        const continuations = [];\r\n        for (const piece of bank[sideToMove].keys()) {\r\n            continuations.push({ piece, endCoordinates: startCoordinates });\r\n        }\r\n        if (validateWithDrops) {\r\n            for (const move of moves) {\r\n                move.nextChainedMoves = continuations;\r\n            }\r\n        }\r\n        return moves;\r\n    }\r\n}\r\n","import { Board } from \"../../../Board/Board\";\r\nimport { compareCoordinates, stringifyCoordinate } from \"../../../Board/BoardInterface\";\r\nimport { VariantRule } from \"../../VariantRuleInterface\";\r\nconst tag = \"selfCheck\";\r\nexport class SelfCheck extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(SelfCheck);\r\n    }\r\n    getDecoratorType() { return Board; }\r\n    getParameterValue() { return true; }\r\n    matchesPGNDeclaration(match) {\r\n        return /^SelfCheck$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"SelfCheck\";\r\n    }\r\n    getInformation() {\r\n        return {\r\n            name: \"Self-checks cost lives\",\r\n            description: \"Self-checks cost lives. Checkmate yourself to earn points\",\r\n            tag\r\n        };\r\n    }\r\n    getCurrentChecks(sideToMove = this.decorator.data.sideToMove) {\r\n        const baseChecks = this.wrappingDecorator?.getCurrentChecks\r\n            ? this.wrappingDecorator.getCurrentChecks()\r\n            : Board.prototype.getCurrentChecks.call(this.decorator, sideToMove);\r\n        const royal = this.decorator.data.fenOptions.royal[sideToMove];\r\n        const newCoordinates = [];\r\n        if (royal) {\r\n            for (const [attackingPiece, attackCoordinates] of this.decorator.preGeneratedAttacks.hoppingPieceLines) {\r\n                if (compareCoordinates(attackCoordinates, royal)) {\r\n                    newCoordinates.push(stringifyCoordinate(attackingPiece));\r\n                }\r\n            }\r\n            for (const [attackingPiece, attackLine] of this.decorator.preGeneratedAttacks.slidingPiecesLines) {\r\n                for (const attackCoordinates of attackLine) {\r\n                    if (compareCoordinates(attackCoordinates, royal)) {\r\n                        newCoordinates.push(stringifyCoordinate(attackingPiece));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        baseChecks[sideToMove] = newCoordinates;\r\n        return baseChecks;\r\n    }\r\n}\r\n","import { pieceControlConfigSettings } from \"@moveGeneration/PieceControl/PieceControlInterface\";\r\nimport { createTupleFromCallback } from \"../../../../../baseTypes\";\r\nimport { Board } from \"../../../Board/Board\";\r\nimport { boardDimension, colors } from \"../../../GameInformation/GameData\";\r\nimport { verifyDroppingMove } from \"../../../MoveTree/MoveTree\";\r\nimport { InternalMoveSignature } from \"../../../MoveTree/MoveTreeInterface\";\r\nimport { VariantRule } from \"../../VariantRuleInterface\";\r\nconst tag = \"setupChess\";\r\nexport class SetupChess extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(SetupChess);\r\n    }\r\n    isDisabled = false;\r\n    setupPoints;\r\n    wereBanksEnabled = [false, false, false, false];\r\n    permutationCoordinates = [[], [], [], []];\r\n    pawnPermutationCoordinates = [[], [], [], []];\r\n    constructor(setupPoints) {\r\n        super();\r\n        if (typeof setupPoints === \"number\") {\r\n            this.setupPoints = setupPoints;\r\n        }\r\n        else {\r\n            this.setupPoints = 39;\r\n        }\r\n    }\r\n    getDecoratorType() { return Board; }\r\n    getParameterValue() { return this.setupPoints; }\r\n    matchesPGNDeclaration(match) {\r\n        const matchArray = match.match(/^Setup=(\\d+)$/);\r\n        if (matchArray) {\r\n            this.setupPoints = Number(matchArray[1]);\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    serializeToParsingForm() {\r\n        return `Setup=${this.setupPoints}`;\r\n    }\r\n    getInformation() {\r\n        return {\r\n            name: `Setup ${this.setupPoints}`, description: `Set up ${this.setupPoints} points before the game starts`, tag\r\n        };\r\n    }\r\n    initDecoratorSettings() {\r\n        const { areBanksEnabled, setupComplete, setupPoints, dead } = this.decorator.data.fenOptions;\r\n        const areSetupPointsUnset = setupPoints === null;\r\n        const modifyDisplacements = (i, j, color) => {\r\n            const baseDisplacements = [[13 - i, j], [j, i], [i, j], [13 - j, i]];\r\n            return baseDisplacements[color];\r\n        };\r\n        for (const color of colors) {\r\n            let bankEnabled = false;\r\n            if (areBanksEnabled[color]) {\r\n                this.wereBanksEnabled[color] = true;\r\n                bankEnabled = true;\r\n            }\r\n            else if (!setupComplete[color]) {\r\n                areBanksEnabled[color] = true;\r\n                bankEnabled = true;\r\n            }\r\n            if (bankEnabled) {\r\n                const files = createTupleFromCallback((_, i) => i, boardDimension);\r\n                const startingPawnRank = this.decorator.data.fenOptions.pawnBaseRank;\r\n                const pawnRanks = [startingPawnRank, startingPawnRank + 1].filter(rank => rank >= 0 && rank <= 13);\r\n                const ranks = [startingPawnRank - 1, ...pawnRanks];\r\n                this.permutationCoordinates[color] = files.flatMap(file => ranks.map((rank) => modifyDisplacements(rank, file, color)));\r\n                this.pawnPermutationCoordinates[color] = files.flatMap(file => pawnRanks.map((rank) => modifyDisplacements(rank, file, color)));\r\n            }\r\n            if (!areSetupPointsUnset && !dead[color]) {\r\n                setupPoints[color] = this.setupPoints;\r\n            }\r\n            if (!this.decorator.data.fenOptions.royal[color]) {\r\n                this.decorator.data.fenOptions.castleKingside[color] = false;\r\n                this.decorator.data.fenOptions.castleQueenside[color] = false;\r\n            }\r\n        }\r\n        if (this.wrappingDecorator?.initDecoratorSettings) {\r\n            this.wrappingDecorator.initDecoratorSettings();\r\n        }\r\n    }\r\n    getLegalMoves(i, j, baseColor = this.decorator.data.sideToMove) {\r\n        if (!this.isDisabled)\r\n            return [];\r\n        if (this.wrappingDecorator?.getLegalMoves) {\r\n            return this.wrappingDecorator.getLegalMoves(i, j, baseColor);\r\n        }\r\n        else {\r\n            return Board.prototype.getLegalMoves.call(this.decorator, i, j, baseColor);\r\n        }\r\n    }\r\n    getCoordinateList(piece) {\r\n        return pieceControlConfigSettings[piece.piece].moveGenerationSettings.isPawn\r\n            ? this.pawnPermutationCoordinates\r\n            : this.permutationCoordinates;\r\n    }\r\n    getDroppingMoves(piece, color = this.decorator.data.sideToMove) {\r\n        if (piece.color !== color)\r\n            return [];\r\n        if (!this.isDisabled && !this.decorator.data.fenOptions.setupComplete[color]) {\r\n            const coordinateList = this.getCoordinateList(piece);\r\n            const resultingMoveDrops = [];\r\n            for (const coordinate of coordinateList[color]) {\r\n                if (this.decorator.board[coordinate[0]][coordinate[1]].isEmpty()) {\r\n                    resultingMoveDrops.push({ piece, endCoordinates: coordinate });\r\n                }\r\n            }\r\n            return resultingMoveDrops;\r\n        }\r\n        else {\r\n            if (this.wrappingDecorator?.getDroppingMoves) {\r\n                return this.wrappingDecorator.getDroppingMoves(piece);\r\n            }\r\n            else {\r\n                return Board.prototype.getDroppingMoves.call(this.decorator, piece);\r\n            }\r\n        }\r\n    }\r\n    makeMove(move, ignoreNextMoves = false) {\r\n        const color = this.decorator.data.sideToMove;\r\n        const moveData = move[0];\r\n        let results;\r\n        if (this.wrappingDecorator?.makeMove) {\r\n            results = this.wrappingDecorator.makeMove([moveData], ignoreNextMoves);\r\n        }\r\n        else {\r\n            results = Board.prototype.makeMove.call(this.decorator, [moveData], ignoreNextMoves);\r\n        }\r\n        if (!this.isDisabled && !this.decorator.data.fenOptions.setupComplete[color] && verifyDroppingMove(moveData)\r\n            && this.decorator.data.fenOptions.setupPoints) {\r\n            const pointValue = pieceControlConfigSettings[moveData.piece.piece].points.singlesPoints;\r\n            if (moveData.piece.piece === \"K\") {\r\n                this.decorator.data.fenOptions.bank[color].delete(moveData.piece);\r\n                this.decorator.data.fenOptions.royal[color] = moveData.endCoordinates;\r\n            }\r\n            else {\r\n                this.decorator.data.fenOptions.setupPoints[color] -= pointValue;\r\n            }\r\n            const setupPoints = this.decorator.data.fenOptions.setupPoints[color];\r\n            for (const [piece] of this.decorator.data.fenOptions.bank[color]) {\r\n                if (piece.piece !== \"K\" && pointValue > setupPoints) {\r\n                    this.decorator.data.fenOptions.bank[color].delete(piece);\r\n                }\r\n            }\r\n            if (this.decorator.data.fenOptions.bank[color].size === 0) {\r\n                this.decorator.data.fenOptions.setupComplete[color] = true;\r\n            }\r\n            else {\r\n                const coordinateList = this.getCoordinateList(moveData.piece);\r\n                let anyDrop = false;\r\n                for (const coordinate of coordinateList[color]) {\r\n                    if (this.decorator.board[coordinate[0]][coordinate[1]].isEmpty()) {\r\n                        anyDrop = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!anyDrop) {\r\n                    this.decorator.data.fenOptions.setupComplete[color] = true;\r\n                }\r\n            }\r\n        }\r\n        if (this.decorator.data.fenOptions.setupComplete.every((v, i) => v || this.decorator.data.fenOptions.dead[i])) {\r\n            this.isDisabled = true;\r\n            for (const color of colors) {\r\n                if (!this.wereBanksEnabled[color]) {\r\n                    this.decorator.data.fenOptions.areBanksEnabled[color] = false;\r\n                    this.decorator.data.fenOptions.bank[color].clear();\r\n                }\r\n            }\r\n        }\r\n        if (!this.isDisabled && !ignoreNextMoves && this.decorator.data.fenOptions.setupComplete[this.decorator.data.sideToMove]) {\r\n            Board.prototype.makeMove.call(this.decorator, [{ type: InternalMoveSignature.Pass }]);\r\n        }\r\n        return results;\r\n    }\r\n}\r\n","import { Board } from \"../../../Board/Board\";\r\nimport { colors } from \"../../../GameInformation/GameData\";\r\nimport { VariantRule } from \"../../VariantRuleInterface\";\r\nconst tag = \"taboo\";\r\nexport class Taboo extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(Taboo);\r\n    }\r\n    getDecoratorType() { return Board; }\r\n    getParameterValue() { return true; }\r\n    matchesPGNDeclaration(match) {\r\n        return /^Taboo$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"Taboo\";\r\n    }\r\n    getInformation() {\r\n        return { name: \"Taboo\", description: \"Giving check is forbidden\", tag };\r\n    }\r\n    isSetupComplex() { return true; }\r\n    isTheMoveLegal(_, moveData) {\r\n        const initialDead = this.decorator.data.fenOptions.dead;\r\n        const snapshot = this.decorator.createSnapshot();\r\n        try {\r\n            this.decorator.makeMove([moveData], true);\r\n            const newDead = this.decorator.data.fenOptions.dead.slice();\r\n            for (const color of colors) {\r\n                if (!initialDead[color] && newDead[color])\r\n                    return false;\r\n                this.decorator.pregenerateAttacks(color);\r\n                if (this.decorator.isKingInCheck(color)) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        finally {\r\n            this.decorator.loadSnapshot(snapshot);\r\n        }\r\n    }\r\n}\r\n","import { compareCoordinates, stringifyCoordinate } from \"@moveGeneration/Board/BoardInterface\";\r\nimport { pieceControlConfigSettings, verifyPieceLetter } from \"@moveGeneration/PieceControl/PieceControlInterface\";\r\nimport { createTuple, createTupleFromCallback } from \"@client/javascript/baseTypes\";\r\nimport { initializeBoardSquares } from \"@client/javascript/logic/BaseInterfaces\";\r\nimport { bitCount } from \"@client/javascript/logic/utils/NumberUtils\";\r\nimport { boardDimension, colors, totalPlayers } from \"../../../../GameInformation/GameData\";\r\nimport { createPieceFromData, emptyPieceString } from \"../../../../GameInformation/GameUnits/PieceString\";\r\nimport { stalemateOptionsValues } from \"../../FENDataDecorators/StalemateOptions\";\r\nimport { disabledRank } from \"../../PieceControlDecorators/PromotionRank\";\r\nconst binaryMasks = Array(boardDimension).fill(1).map((v, i) => v << boardDimension | v << (boardDimension - 1 - i));\r\nconst oneBitMask = 1 << boardDimension;\r\nconst maxSafeCheckingPieces = 9;\r\nexport function countBitsOnBoard(board) {\r\n    let setBits = 0;\r\n    for (let x = 0; x < boardDimension; x++) {\r\n        setBits += bitCount(board[x] ^ oneBitMask);\r\n    }\r\n    return setBits;\r\n}\r\nfunction findMinimumOnBoardSquares(board) {\r\n    let minimum = Infinity;\r\n    for (let i = 0; i < boardDimension; i++) {\r\n        for (let j = 0; j < boardDimension; j++) {\r\n            const setBits = countBitsOnBoard(board[i][j]);\r\n            if (setBits !== 0 && setBits < minimum) {\r\n                minimum = setBits;\r\n            }\r\n        }\r\n    }\r\n    return minimum;\r\n}\r\nfunction optimizePieceSet(possiblePieces, maximumTarget) {\r\n    const optimalRoyalMoveSets = [\r\n        [\"\", \"W\", \"R\", \"E\", \"M\", \"Q\", \"D\", \"A\"],\r\n        [\"\", \"F\", \"B\", \"H\", \"M\", \"Q\", \"D\", \"A\", \"\"],\r\n        [\"Y\", \"Z\"], [\"I\", \"J\"], [\"S\", \"T\"], [\"S\", \"Y\"], [\"I\", \"Y\"],\r\n        [\"U\", \"N\", \"O\"], [\"H\", \"A\"], [\"E\", \"A\"], [\"\", \"H\"], [\"C\", \"L\"], [\"C\", \"V\"]\r\n    ];\r\n    const moveSet = new Set();\r\n    for (const optimalMoveSet of optimalRoyalMoveSets) {\r\n        const detractionSet = maximumTarget ? optimalMoveSet.slice().reverse() : optimalMoveSet;\r\n        for (const piece of possiblePieces) {\r\n            if (detractionSet.includes(piece)) {\r\n                const target = detractionSet.slice(0, -detractionSet.indexOf(piece));\r\n                target.forEach(t => { if (possiblePieces.includes(t) && verifyPieceLetter(t))\r\n                    moveSet.add(t); });\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    if (moveSet.size === 0) {\r\n        possiblePieces.forEach(p => { if (verifyPieceLetter(p))\r\n            moveSet.add(p); });\r\n    }\r\n    return moveSet;\r\n}\r\nfunction generateInsufficientMatingPieces(baseBoard) {\r\n    const board = baseBoard.createClone();\r\n    // Step 1. Initialize the royals, get the optimal royal piece configuration.\r\n    performance.mark(\"insufficientMaterialStart\");\r\n    const possibleRoyals = [[], [], [], []];\r\n    const boardSquares = board.board, options = board.data, controls = board.controls;\r\n    const promotionPieces = board.variantData.promotionPieces || [];\r\n    const promotionRank = board.variantData.promotionRank || disabledRank;\r\n    options.fenOptions.royal.forEach((r, i) => {\r\n        if (r) {\r\n            const coordinate = boardSquares[r[0]][r[1]];\r\n            if (pieceControlConfigSettings[coordinate.piece].moveGenerationSettings.isPawn) {\r\n                possibleRoyals[i] = [coordinate.piece, ...promotionPieces];\r\n            }\r\n            else\r\n                possibleRoyals[i] = [coordinate.piece];\r\n        }\r\n        else if (promotionPieces.includes(\"K\")) {\r\n            possibleRoyals[i] = [\"K\"];\r\n        }\r\n    });\r\n    const royalPieceSets = Array.from({ length: 4 }, () => new Set());\r\n    for (let i = 0; i < possibleRoyals.length; i++) {\r\n        if (possibleRoyals[i].length > 1) {\r\n            royalPieceSets[i] = optimizePieceSet(possibleRoyals[i], false);\r\n        }\r\n        else if (possibleRoyals[i].length === 1) {\r\n            royalPieceSets[i].add(possibleRoyals[i][0]);\r\n        }\r\n    }\r\n    // Step 2. Get all coordinates individual pieces can reach, for swift move generation.\r\n    const boardDestinations = new Map();\r\n    const emptyBoard = boardSquares.map(row => row.map(square => square.isWall() ? square : emptyPieceString));\r\n    const walls = emptyBoard.map(row => row.map(square => square.isWall() ? true : false));\r\n    const pieceMoveRegistry = {};\r\n    const baseImmune = [false, false, false, false];\r\n    const getAllSquaresRecursively = (x, y, piece) => {\r\n        const currentSquares = new Set(), unvisitedSquares = new Set();\r\n        if (!piece.isPiece())\r\n            throw new TypeError(`Wrong piece signature detected at ${piece.value}`);\r\n        const baseBuilder = controls[piece.piece]().setColor(piece.color).setBoard(emptyBoard).setBaseImmunePieces(baseImmune);\r\n        const registryResult = initializeBoardSquares(() => new Uint16Array(boardDimension).fill(oneBitMask));\r\n        const recurse = (x, y) => {\r\n            const control = baseBuilder.setCoordinates(x, y).constructPieceControl();\r\n            const moves = control.getPseudoLegalMoves();\r\n            const moveLength = moves.length;\r\n            if (moveLength === 0)\r\n                return;\r\n            for (let i = 0; i < moveLength; i++) {\r\n                const move = moves[i].move;\r\n                const moveString = stringifyCoordinate(move);\r\n                registryResult[x][y][move[0]] |= binaryMasks[move[1]];\r\n                if (!currentSquares.has(moveString)) {\r\n                    unvisitedSquares.add(moveString);\r\n                }\r\n            }\r\n            for (const value of unvisitedSquares) {\r\n                const [x, y] = value.split(\":\");\r\n                if (!currentSquares.has(value)) {\r\n                    currentSquares.add(value);\r\n                    recurse(parseInt(x, 10), parseInt(y, 10));\r\n                }\r\n            }\r\n        };\r\n        recurse(x, y);\r\n        if (!(piece.piece in pieceMoveRegistry))\r\n            pieceMoveRegistry[piece.piece] = {};\r\n        pieceMoveRegistry[piece.piece][Symbol()] = registryResult;\r\n        const permutations = new Uint16Array(14).fill(oneBitMask);\r\n        currentSquares.forEach(value => {\r\n            const valueArr = value.split(\":\");\r\n            permutations[parseInt(valueArr[0], 10)] |= binaryMasks[parseInt(valueArr[1], 10)];\r\n        });\r\n        unvisitedSquares.forEach(value => {\r\n            const valueArr = value.split(\":\");\r\n            permutations[parseInt(valueArr[0], 10)] |= binaryMasks[parseInt(valueArr[1], 10)];\r\n        });\r\n        return permutations;\r\n    };\r\n    function addToBoardDestinations(i, j, piece) {\r\n        const permutations = getAllSquaresRecursively(i, j, piece);\r\n        const boardPiece = boardDestinations.get(piece.piece);\r\n        if (boardPiece) {\r\n            boardDestinations.set(piece.piece, boardPiece.concat(permutations));\r\n        }\r\n        else {\r\n            boardDestinations.set(piece.piece, [permutations]);\r\n        }\r\n    }\r\n    for (let i = 0; i < boardDimension; i++) {\r\n        for (let j = 0; j < boardDimension; j++) {\r\n            if (boardSquares[i][j].isPiece())\r\n                addToBoardDestinations(i, j, boardSquares[i][j]);\r\n        }\r\n    }\r\n    const hasPromotion = promotionRank !== disabledRank && promotionPieces.some(p => verifyPieceLetter(p));\r\n    const promotionRanks = [boardDimension - promotionRank,\r\n        promotionRank - 1, promotionRank - 1, boardDimension - promotionRank];\r\n    const optimizedPieces = optimizePieceSet(promotionPieces, true);\r\n    if (hasPromotion) {\r\n        for (const color of colors) {\r\n            for (let x = 0; x < boardDimension; x++) {\r\n                const [i, j] = [color % 2 === 0 ? promotionRanks[color] : x, color % 2 !== 0 ? promotionRanks[color] : x];\r\n                if (walls[i][j])\r\n                    continue;\r\n                for (const piece of optimizedPieces) {\r\n                    addToBoardDestinations(i, j, createPieceFromData(0, piece));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    const backwardsPieceRegistry = {};\r\n    const entries = boardDestinations.entries();\r\n    for (const [entry, uintArray] of entries) {\r\n        if (/[PG]/.test(entry) || !verifyPieceLetter(entry))\r\n            continue;\r\n        let isAlwaysIntersecting = true;\r\n        const permutationArray = [];\r\n        for (const permutationEntry of uintArray) {\r\n            if (permutationArray.length === 0) {\r\n                permutationArray.push(permutationEntry);\r\n            }\r\n            else {\r\n                const index = permutationArray.findIndex(uintArr => {\r\n                    if (uintArr instanceof Uint16Array) {\r\n                        return uintArr.every((n, j) => n === permutationEntry[j]);\r\n                    }\r\n                });\r\n                if (index > -1) {\r\n                    permutationArray.push(index);\r\n                }\r\n                else {\r\n                    permutationArray.push(permutationEntry);\r\n                    isAlwaysIntersecting = false;\r\n                }\r\n            }\r\n        }\r\n        if (isAlwaysIntersecting) {\r\n            pieceMoveRegistry[entry] = {\r\n                [Symbol()]: pieceMoveRegistry[entry][Object.getOwnPropertySymbols(pieceMoveRegistry[entry])[0]]\r\n            };\r\n        }\r\n        else {\r\n            if (!(entry in backwardsPieceRegistry)) {\r\n                backwardsPieceRegistry[entry] = initializeBoardSquares(() => null);\r\n            }\r\n            const remappedSymbols = [];\r\n            for (const squares of permutationArray) {\r\n                let remappedSymbol;\r\n                if (typeof squares === 'number') {\r\n                    remappedSymbols.push(squares);\r\n                    continue;\r\n                }\r\n                for (let i = 0; i < boardDimension; i++) {\r\n                    for (let j = 0; j < boardDimension; j++) {\r\n                        if (squares[i] & binaryMasks[j] ^ oneBitMask) {\r\n                            if (!remappedSymbol) {\r\n                                remappedSymbol = Symbol();\r\n                                remappedSymbols.push(remappedSymbol);\r\n                            }\r\n                            backwardsPieceRegistry[entry][i][j] ??= remappedSymbol;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            const uintValues = Object.getOwnPropertySymbols(pieceMoveRegistry[entry]).map(sym => pieceMoveRegistry[entry][sym]);\r\n            pieceMoveRegistry[entry] = {};\r\n            for (let i = 0; i < uintValues.length; i++) {\r\n                const remapped = remappedSymbols[i];\r\n                if (typeof remapped === 'number')\r\n                    continue;\r\n                if (typeof remapped === 'undefined')\r\n                    break;\r\n                pieceMoveRegistry[entry][remapped] = uintValues[i];\r\n            }\r\n        }\r\n    }\r\n    // Step 3. Generate the opposition squares for the royal pieces, since royal cannot attack each other.\r\n    const royalMoves = createTuple(initializeBoardSquares(() => new Uint16Array(boardDimension).fill(oneBitMask)), totalPlayers);\r\n    const royalMoveMedians = createTuple(0, totalPlayers);\r\n    const oppositionDiagonalRowEchelon = createTuple(undefined, totalPlayers);\r\n    options.fenOptions.royal.forEach((r, x) => {\r\n        if (r) {\r\n            const royalPiece = boardSquares[r[0]][r[1]];\r\n            const controlBuilder = controls[royalPiece.piece];\r\n            const builder = controlBuilder().setColor(0).setBaseImmunePieces(baseImmune).setBoard(emptyBoard);\r\n            const finalArray = Array.from({ length: 14 }, () => Array.from({ length: 14 }, () => new Uint16Array(14).fill(oneBitMask)));\r\n            for (let i = 0; i < boardSquares.length; i++) {\r\n                for (let j = 0; j < boardSquares[0].length; j++) {\r\n                    if (emptyBoard[i][j].isWall())\r\n                        continue;\r\n                    const control = builder.setCoordinates(i, j).constructPieceControl();\r\n                    const moves = control.getPseudoLegalMoves();\r\n                    const permutationArray = new Uint16Array(14).fill(oneBitMask);\r\n                    for (const { move } of moves) {\r\n                        permutationArray[move[0]] |= binaryMasks[move[1]];\r\n                    }\r\n                    finalArray[i][j] = permutationArray;\r\n                    royalMoves[x][i][j] = permutationArray;\r\n                }\r\n            }\r\n            oppositionDiagonalRowEchelon[x] = finalArray;\r\n        }\r\n    });\r\n    const oppositionMedians = createTupleFromCallback(() => createTuple(0, totalPlayers), totalPlayers);\r\n    for (let i = 0; i < totalPlayers; i++) {\r\n        for (let j = 0; j < totalPlayers; j++) {\r\n            if (i === j || oppositionDiagonalRowEchelon[i] === undefined)\r\n                continue;\r\n            const royalPieceA = options.fenOptions.royal[i], royalPieceB = options.fenOptions.royal[j];\r\n            if (!royalPieceA || !royalPieceB)\r\n                continue;\r\n            const finalArray = Array.from({ length: 14 }, () => Array.from({ length: 14 }, () => 0));\r\n            for (let i2 = 0; i2 < boardDimension; i2++) {\r\n                for (let j2 = 0; j2 < boardDimension; j2++) {\r\n                    if (emptyBoard[i2][j2].isWall())\r\n                        continue;\r\n                    const jjIndex = oppositionDiagonalRowEchelon[j];\r\n                    const iiIndex = oppositionDiagonalRowEchelon[i];\r\n                    if (!jjIndex || !iiIndex)\r\n                        throw new Error(`Central opposition matrix indexes are undefined: ${jjIndex?.toString() ?? \"undefined\"}  ${iiIndex?.toString() ?? \"undefined\"}`);\r\n                    if (jjIndex[i2][j2][royalPieceA[1]] & binaryMasks[royalPieceA[0]] ^ oneBitMask\r\n                        && iiIndex[i2][j2][royalPieceB[1]] & binaryMasks[royalPieceB[0]] ^ oneBitMask) {\r\n                        continue;\r\n                    }\r\n                    const uintArray = jjIndex[i2][j2].map((e, x) => e & iiIndex[i2][j2][x]);\r\n                    let newResultingSquares = 0;\r\n                    for (let dimSquare = 0; dimSquare < boardDimension; dimSquare++) {\r\n                        newResultingSquares += bitCount(uintArray[dimSquare]) - 1;\r\n                    }\r\n                    finalArray[i2][j2] = newResultingSquares;\r\n                }\r\n            }\r\n            let minimum = Infinity;\r\n            for (let i2 = 0; i2 < boardDimension; i2++) {\r\n                for (let j2 = 0; j2 < boardDimension; j2++) {\r\n                    if (finalArray[i2][j2] !== 0 && finalArray[i2][j2] < minimum) {\r\n                        minimum = finalArray[i2][j2];\r\n                    }\r\n                }\r\n            }\r\n            oppositionMedians[i][j] = minimum - 1;\r\n        }\r\n    }\r\n    for (const color of colors) {\r\n        royalMoveMedians[color] = findMinimumOnBoardSquares(royalMoves[color]);\r\n    }\r\n    // Step 4. Finally, generate all squares pieces can cover from default royal moves for each player.\r\n    const nonIndexedPieceSymbol = Symbol();\r\n    const pieceSquareMedians = {\r\n        [\"G\"]: { [nonIndexedPieceSymbol]: [2, 2, 2, 2] }\r\n    };\r\n    let currentMessages = 0, requiredMessages = 0;\r\n    for (const pieceLetter in pieceMoveRegistry) {\r\n        if (!verifyPieceLetter(pieceLetter) || !Object.prototype.hasOwnProperty.call(pieceMoveRegistry, pieceLetter))\r\n            continue;\r\n        if (pieceLetter in pieceSquareMedians)\r\n            continue;\r\n        pieceSquareMedians[pieceLetter] = {};\r\n        const registeredSymbols = Object.getOwnPropertySymbols(pieceMoveRegistry[pieceLetter]);\r\n        for (const registeredSymbol of registeredSymbols) {\r\n            const pieceMedianCounter = new Worker(new URL(\"./PieceMedianCounter.ts\", import.meta.url));\r\n            pieceMedianCounter.postMessage({\r\n                walls,\r\n                moveRegistryArray: pieceMoveRegistry[pieceLetter][registeredSymbol].map(r => r.map(uint => uint.buffer)),\r\n                royalMoves: royalMoves.map(board => board.map(r => r.map(uint => uint.buffer))),\r\n                royalPieceSet: royalPieceSets.map(s => [...s])\r\n            });\r\n            requiredMessages++;\r\n            pieceMedianCounter.onmessage = (e) => {\r\n                pieceSquareMedians[pieceLetter][registeredSymbol] = e.data;\r\n                currentMessages++;\r\n            };\r\n        }\r\n    }\r\n    const obtainPieceSymbolFromCoordinate = (board, coordinate) => {\r\n        const piece = board.board[coordinate[0]][coordinate[1]];\r\n        if (pieceControlConfigSettings[piece.piece].moveGenerationSettings.isPawn && hasPromotion) {\r\n            const availableSymbols = [...optimizedPieces]\r\n                .filter(p => verifyPieceLetter(p)\r\n                && !pieceControlConfigSettings[p].moveGenerationSettings.isPawn).map(p => pieceSquareMedians[p]);\r\n            if (availableSymbols.length === 0) {\r\n                return { selectedSymbol: nonIndexedPieceSymbol, piece };\r\n            }\r\n            else {\r\n                const candidates = availableSymbols.map(s => {\r\n                    return s[Object.getOwnPropertySymbols(s)[0]].reduce((p, n) => p + (n ?? 0), 0);\r\n                });\r\n                const candidateIndex = candidates.indexOf(Math.max(...candidates));\r\n                const symbol = Object.getOwnPropertySymbols(availableSymbols[candidateIndex])[0];\r\n                return {\r\n                    selectedSymbol: symbol,\r\n                    piece\r\n                };\r\n            }\r\n        }\r\n        else {\r\n            const availableSymbols = Object.getOwnPropertySymbols(pieceSquareMedians[piece.piece]);\r\n            const selectedSymbol = availableSymbols.length === 1\r\n                ? availableSymbols[0]\r\n                : backwardsPieceRegistry[piece.piece][coordinate[0]][coordinate[1]];\r\n            if (selectedSymbol === null)\r\n                throw new Error(\"Accessor symbol is unexpectedly null\");\r\n            return { selectedSymbol, piece };\r\n        }\r\n    };\r\n    const noRoyalsToMate = board.variantData.forcedCapture\r\n        || board.variantData.captureTheKing || board.variantData.barePieceRule\r\n        || board.variantData.nCheck;\r\n    return (board) => {\r\n        const pieces = board.getPlayerPieces();\r\n        const resultingInsufficientPieces = createTuple(false, totalPlayers);\r\n        if (board.variantData.kingOfTheHill || currentMessages !== requiredMessages\r\n            || board.data.fenOptions.areBanksEnabled.some((b, i) => !board.data.fenOptions.dead[i] && b)) {\r\n            return resultingInsufficientPieces;\r\n        }\r\n        const extraWalls = board.board.reduce((accumulator, row, i) => {\r\n            return accumulator + row.reduce((accumulator, square, j) => {\r\n                if (square.isWall() && !walls[i][j]) {\r\n                    return accumulator + 1;\r\n                }\r\n                else\r\n                    return accumulator;\r\n            }, 0);\r\n        }, 0);\r\n        const royalPieceMedians = royalMoveMedians.map((median, i) => {\r\n            if (!board.data.fenOptions.royal[i])\r\n                return;\r\n            let minimumMedian;\r\n            if (board.variantData.stalemateOptions === stalemateOptionsValues.stalemateLoses) {\r\n                minimumMedian = 1;\r\n                median--;\r\n            }\r\n            else {\r\n                median++;\r\n                minimumMedian = 2;\r\n            }\r\n            median -= extraWalls;\r\n            if (median < minimumMedian)\r\n                median = minimumMedian;\r\n            return median;\r\n        });\r\n        const squaresPlayerCanOutrange = createTupleFromCallback(() => createTuple(0, totalPlayers), totalPlayers);\r\n        for (const color of colors) {\r\n            const army = pieces[color];\r\n            if (army.length > maxSafeCheckingPieces || board.data.fenOptions.dead[color])\r\n                continue;\r\n            for (const royalColor of colors) {\r\n                if (pieces[royalColor].length > maxSafeCheckingPieces\r\n                    || color === royalColor || board.data.fenOptions.dead[royalColor])\r\n                    continue;\r\n                if (!board.data.fenOptions.royal[royalColor] || noRoyalsToMate) {\r\n                    intersectionCheckLoop: for (const coordinate of army) {\r\n                        const { piece, selectedSymbol } = obtainPieceSymbolFromCoordinate(board, coordinate);\r\n                        const symbolsLength = Object.getOwnPropertySymbols(pieceSquareMedians[piece.piece]).length;\r\n                        if (symbolsLength > 1 || pieceControlConfigSettings[piece.piece].moveGenerationSettings.isColorBound) {\r\n                            for (const enemyCoordinate of pieces[royalColor]) {\r\n                                const { selectedSymbol: enemySymbol } = obtainPieceSymbolFromCoordinate(board, enemyCoordinate);\r\n                                if (selectedSymbol === enemySymbol) {\r\n                                    squaresPlayerCanOutrange[royalColor][color] = Infinity;\r\n                                    break intersectionCheckLoop;\r\n                                }\r\n                            }\r\n                        }\r\n                        else {\r\n                            squaresPlayerCanOutrange[royalColor][color] = Infinity;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (squaresPlayerCanOutrange[royalColor][color] !== Infinity) {\r\n                        squaresPlayerCanOutrange[royalColor][color] = -1;\r\n                    }\r\n                }\r\n                else {\r\n                    const royalSquares = royalPieceMedians[royalColor];\r\n                    if (royalSquares === undefined)\r\n                        continue;\r\n                    const fenRoyal = board.data.fenOptions.royal[color];\r\n                    const currentColorBounds = [];\r\n                    for (const coordinate of army) {\r\n                        if (fenRoyal && compareCoordinates(coordinate, fenRoyal)) {\r\n                            if (board.variantData.royalsCannotCapture) {\r\n                                squaresPlayerCanOutrange[color][royalColor]++;\r\n                            }\r\n                            else {\r\n                                squaresPlayerCanOutrange[color][royalColor] += oppositionMedians[color][royalColor];\r\n                            }\r\n                        }\r\n                        else {\r\n                            const { piece, selectedSymbol } = obtainPieceSymbolFromCoordinate(board, coordinate);\r\n                            if (hasPromotion && pieceControlConfigSettings[piece.piece].moveGenerationSettings.isPawn) {\r\n                                const medians = promotionPieces.map(piece => {\r\n                                    const subSymbol = Object.getOwnPropertySymbols(pieceSquareMedians[piece])[0];\r\n                                    return pieceSquareMedians[piece][subSymbol][royalColor] ?? 0;\r\n                                });\r\n                                squaresPlayerCanOutrange[color][royalColor] += Math.max(...medians);\r\n                            }\r\n                            else {\r\n                                if (pieceControlConfigSettings[piece.piece].moveGenerationSettings.isColorBound) {\r\n                                    if (currentColorBounds.includes(selectedSymbol))\r\n                                        continue;\r\n                                    currentColorBounds.push(selectedSymbol);\r\n                                }\r\n                                squaresPlayerCanOutrange[color][royalColor] += pieceSquareMedians[piece.piece][selectedSymbol][royalColor] ?? 0;\r\n                            }\r\n                        }\r\n                    }\r\n                    squaresPlayerCanOutrange[color][royalColor] += pieces[royalColor].length - 1;\r\n                }\r\n            }\r\n        }\r\n        for (const color of colors) {\r\n            if (board.data.fenOptions.dead[color])\r\n                continue;\r\n            let sum = 0;\r\n            for (let i = 0; i < totalPlayers; i++) {\r\n                if (i === color)\r\n                    continue;\r\n                sum += squaresPlayerCanOutrange[i][color];\r\n            }\r\n            const royal = royalPieceMedians[color];\r\n            if ((royal !== undefined && sum <= royal && pieces[color].length <= maxSafeCheckingPieces)\r\n                || sum < 0) {\r\n                resultingInsufficientPieces[color] = true;\r\n            }\r\n        }\r\n        return resultingInsufficientPieces;\r\n    };\r\n}\r\nexport { generateInsufficientMatingPieces };\r\n","import { createTupleFromCallback } from \"@client/javascript/baseTypes\";\r\nimport { initializeBoardSquares } from \"@client/javascript/logic/BaseInterfaces\";\r\nimport { boardDimension, colors, totalPlayers } from \"@moveGeneration/GameInformation/GameData\";\r\nimport { verifyPieceLetter } from \"@moveGeneration/PieceControl/PieceControlInterface\";\r\nimport { countMinimumOf2DArrayExcludingZero } from \"@client/javascript/logic/utils/ArrayUtils\";\r\nimport { countBitsOnBoard } from \"./InsufficientMaterialGeneration\";\r\nself.onmessage = (e) => {\r\n    const { walls, royalPieceSet, royalMoves, moveRegistryArray } = e.data;\r\n    const resultingMedianArray = createTupleFromCallback(() => initializeBoardSquares(() => 0), totalPlayers);\r\n    for (let i = 0; i < boardDimension; i++) {\r\n        for (let j = 0; j < boardDimension; j++) {\r\n            if (walls[i][j])\r\n                continue;\r\n            const moves = new Uint16Array(moveRegistryArray[i][j]);\r\n            for (const color of colors) {\r\n                if (royalPieceSet[color].length === 0) {\r\n                    resultingMedianArray[color] = undefined;\r\n                    continue;\r\n                }\r\n                else {\r\n                    let resultingSquares = 0;\r\n                    for (const royal of royalPieceSet[color]) {\r\n                        if (!verifyPieceLetter(royal))\r\n                            continue;\r\n                        for (let royalI = 0; royalI < boardDimension; royalI++) {\r\n                            for (let royalJ = 0; royalJ < boardDimension; royalJ++) {\r\n                                const royalMoveSet = new Uint16Array(royalMoves[color][royalI][royalJ]);\r\n                                const result = moves.map((e, x) => e & royalMoveSet[x]);\r\n                                const newResultingSquares = countBitsOnBoard(result);\r\n                                if (newResultingSquares > resultingSquares) {\r\n                                    resultingSquares = newResultingSquares;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    const resultingMedian = resultingMedianArray[color];\r\n                    if (resultingMedian)\r\n                        resultingMedian[i][j] = resultingSquares;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    postMessage(resultingMedianArray.map(arr => {\r\n        if (arr) {\r\n            const minimum = countMinimumOf2DArrayExcludingZero(arr);\r\n            return minimum === Infinity ? 0 : minimum;\r\n        }\r\n        else\r\n            return arr;\r\n    }));\r\n};\r\n","import { boardDimension } from \"@moveGeneration/GameInformation/GameData\";\r\nimport { pieceControlConfigSettings } from \"@moveGeneration/PieceControl/PieceControlInterface\";\r\nimport { FENData } from \"../../../FENData/FENData\";\r\nimport { VariantRule } from \"../../VariantRuleInterface\";\r\nimport { RoyalsCannotCapture } from \"../PieceControlDecorators/RoyalsCannotCapture\";\r\nconst tag = \"atomic\";\r\nexport class Atomic extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(Atomic);\r\n    }\r\n    dependencies = new Map([[RoyalsCannotCapture, []]]);\r\n    getDecoratorType() { return FENData; }\r\n    getParameterValue() { return true; }\r\n    matchesPGNDeclaration(match) {\r\n        return /^Atomic$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"Atomic\";\r\n    }\r\n    getInformation() {\r\n        return { name: \"Atomic\", description: \"Captures cause all surrounding pieces except pawns to explode\", tag };\r\n    }\r\n    isComplexEvaluation() {\r\n        return true;\r\n    }\r\n    getCapturedPieces(moveData) {\r\n        const baseCoordinates = this.wrappingDecorator?.getCapturedPieces\r\n            ? this.wrappingDecorator.getCapturedPieces(moveData)\r\n            : FENData.prototype.getCapturedPieces.call(this.decorator, moveData);\r\n        const addCoordinate = (disI, disJ) => {\r\n            const coordinateI = moveData.endCoordinates[0] + disI;\r\n            const coordinateJ = moveData.endCoordinates[1] + disJ;\r\n            if (coordinateI >= 0 && coordinateI <= boardDimension\r\n                && coordinateJ >= 0 && coordinateJ <= boardDimension) {\r\n                const pieceString = this.decorator.board.board[coordinateI][coordinateJ];\r\n                if ((pieceString.isPiece() || pieceString.isDead())\r\n                    && !pieceControlConfigSettings[pieceString.piece].moveGenerationSettings.isPawn) {\r\n                    baseCoordinates.push([coordinateI, coordinateJ]);\r\n                }\r\n            }\r\n        };\r\n        if (baseCoordinates.length !== 0) {\r\n            addCoordinate(-1, -1);\r\n            addCoordinate(-1, 0);\r\n            addCoordinate(0, -1);\r\n            addCoordinate(-1, 1);\r\n            addCoordinate(1, -1);\r\n            addCoordinate(1, 0);\r\n            addCoordinate(0, 1);\r\n            addCoordinate(1, 1);\r\n            baseCoordinates.push([...moveData.startCoordinates]);\r\n        }\r\n        return baseCoordinates;\r\n    }\r\n}\r\n","import { SpecialMove } from \"../../../MoveTree/MoveTreeInterface\";\r\nimport { FENData } from \"../../../FENData/FENData\";\r\nimport { emptyPieceString, nonPlayablePieces } from \"../../../GameInformation/GameUnits/PieceString\";\r\nimport { VariantRule } from \"../../VariantRuleInterface\";\r\nimport { pieceControlConfigSettings } from \"@moveGeneration/PieceControl/PieceControlInterface\";\r\nconst tag = \"enPassant\";\r\nexport class EnPassant extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(EnPassant);\r\n    }\r\n    getDecoratorType() { return FENData; }\r\n    getParameterValue() { return true; }\r\n    matchesPGNDeclaration(match) {\r\n        return /^EnPassant$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"EnPassant\";\r\n    }\r\n    getInformation() {\r\n        return { name: \"En Passant\", description: \"Pawns can capture en passant\", tag };\r\n    }\r\n    processStandardMove(moveData) {\r\n        const { startCoordinates: [startI, startJ], endCoordinates: [endI, endJ] } = moveData;\r\n        if (moveData.specialType === SpecialMove.EnPassant) {\r\n            const eligibleEnPassants = [];\r\n            this.decorator.fenOptions.enPassant.forEach((e, i) => {\r\n                if (!e)\r\n                    return;\r\n                if (e[0][0] === endI && e[0][1] === endJ)\r\n                    eligibleEnPassants.push(i);\r\n            });\r\n            for (const enPassantCoordinate of eligibleEnPassants) {\r\n                const enPassant = this.decorator.fenOptions.enPassant[enPassantCoordinate];\r\n                if (!enPassant)\r\n                    throw new Error(\"En passant index is expected to be real, while it is equal to null\");\r\n                this.decorator.board.board[enPassant[1][0]][enPassant[1][1]] = emptyPieceString;\r\n                this.decorator.fenOptions.enPassant[enPassantCoordinate] = null;\r\n            }\r\n        }\r\n        else {\r\n            const pieceString = this.decorator.board.board[startI][startJ];\r\n            if (!pieceString.isEmpty() && pieceString.piece !== nonPlayablePieces.duck) {\r\n                this.decorator.fenOptions.enPassant[this.decorator.sideToMove] = null;\r\n                const setting = pieceControlConfigSettings[pieceString.piece];\r\n                if (setting.moveGenerationSettings.isPawn\r\n                    && Math.abs(this.decorator.sideToMove % 2 === 0 ? startI - endI : startJ - endJ) === 2) {\r\n                    const enPassantInfo = [\r\n                        [Math.ceil((startI + endI) / 2), Math.ceil((startJ + endJ) / 2)],\r\n                        [endI, endJ]\r\n                    ];\r\n                    this.decorator.fenOptions.enPassant[this.decorator.sideToMove] = enPassantInfo;\r\n                }\r\n            }\r\n        }\r\n        if (this.wrappingDecorator?.processStandardMove) {\r\n            return this.wrappingDecorator.processStandardMove(moveData);\r\n        }\r\n        else {\r\n            return FENData.prototype.processStandardMove.call(this.decorator, moveData);\r\n        }\r\n    }\r\n}\r\n","import { createTuple } from \"../../../../../baseTypes\";\r\nimport { verifyStandardMove } from \"../../../MoveTree/MoveTree\";\r\nimport { FENData } from \"../../../FENData/FENData\";\r\nimport { createDefaultFENEffectSettings } from \"../../../FENData/FENDataInterface\";\r\nimport { totalPlayers } from \"../../../GameInformation/GameData\";\r\nimport { createPieceFromData, deadColorIndex } from \"../../../GameInformation/GameUnits/PieceString\";\r\nimport { VariantRule } from \"../../VariantRuleInterface\";\r\nimport { RoyalsCannotCapture } from \"../PieceControlDecorators/RoyalsCannotCapture\";\r\nimport { pieceControlConfigSettings } from \"@moveGeneration/PieceControl/PieceControlInterface\";\r\nconst tag = \"fatalCapture\";\r\nexport class FatalCapture extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(FatalCapture);\r\n    }\r\n    dependencies = new Map([[RoyalsCannotCapture, []]]);\r\n    getDecoratorType() { return FENData; }\r\n    getParameterValue() { return true; }\r\n    matchesPGNDeclaration(match) {\r\n        return /^FatalCapture$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"FatalCapture\";\r\n    }\r\n    getInformation() {\r\n        return { name: \"Fatal Capture\", description: \"Pieces (but not pawns) die when they capture\", tag };\r\n    }\r\n    affectOptions(move, settings = createDefaultFENEffectSettings()) {\r\n        let endCaptureCoordinates = undefined;\r\n        if (verifyStandardMove(move)) {\r\n            const { startCoordinates: [startI, startJ], endCoordinates: [endI, endJ] } = move;\r\n            const isCapture = this.decorator.board.board[endI][endJ].isPiece();\r\n            const royal = this.decorator.fenOptions.royal[this.decorator.sideToMove];\r\n            if (royal && startI === royal[0] && startJ === royal[1] && isCapture) {\r\n                return {\r\n                    checkmates: this.decorator.board.gameType.getBaseColors(this.decorator.sideToMove),\r\n                    checks: createTuple(false, totalPlayers), stalemates: createTuple(false, totalPlayers)\r\n                };\r\n            }\r\n            endCaptureCoordinates = isCapture ? move.endCoordinates : undefined;\r\n        }\r\n        let returnType;\r\n        if (this.wrappingDecorator?.affectOptions) {\r\n            returnType = this.wrappingDecorator.affectOptions(move, settings);\r\n        }\r\n        else {\r\n            returnType = FENData.prototype.affectOptions.call(this.decorator, move, settings);\r\n        }\r\n        if (endCaptureCoordinates) {\r\n            const pieceString = this.decorator.board.board[endCaptureCoordinates[0]][endCaptureCoordinates[1]];\r\n            if (!pieceControlConfigSettings[pieceString.piece].moveGenerationSettings.isPawn) {\r\n                this.decorator.board.board[endCaptureCoordinates[0]][endCaptureCoordinates[1]] = createPieceFromData(deadColorIndex, this.decorator.board.board[endCaptureCoordinates[0]][endCaptureCoordinates[1]].piece);\r\n            }\r\n        }\r\n        return returnType;\r\n    }\r\n}\r\n","import { FENData } from \"../../../FENData/FENData\";\r\nimport { createDefaultFENEffectSettings } from \"../../../FENData/FENDataInterface\";\r\nimport { totalPlayers } from \"../../../GameInformation/GameData\";\r\nimport { VariantRule } from \"../../VariantRuleInterface\";\r\nconst tag = \"fiftyMoveRule\";\r\nexport class FiftyMoveRule extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(FiftyMoveRule);\r\n    }\r\n    totalFullMoves;\r\n    constructor(fullMoves) {\r\n        super();\r\n        if (typeof fullMoves === 'number' && fullMoves > 0) {\r\n            this.totalFullMoves = fullMoves;\r\n        }\r\n        else {\r\n            this.totalFullMoves = 50;\r\n        }\r\n    }\r\n    getDecoratorType() { return FENData; }\r\n    getParameterValue() { return this.totalFullMoves; }\r\n    matchesPGNDeclaration(match) {\r\n        const matchArray = match.match(/^FiftyMoveRule=((?:\\d+)|(?:Infinity))$/i);\r\n        if (matchArray) {\r\n            this.totalFullMoves = Number(matchArray[1]);\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    serializeToParsingForm() {\r\n        return `FiftyMoveRule=${this.totalFullMoves}`;\r\n    }\r\n    getInformation() {\r\n        const isDisabled = this.totalFullMoves === Infinity;\r\n        return {\r\n            name: isDisabled ? \"50 move rule disabled\" : `${this.totalFullMoves} move rule`,\r\n            textualForm: \"\",\r\n            description: isDisabled ? \"50 move rule disabled\" : `After ${this.totalFullMoves} full moves without captures or pawn pushes game is over`,\r\n            tag\r\n        };\r\n    }\r\n    processStandardMove(moveData) {\r\n        if (this.decorator.getCapturedPieces(moveData).length > 0) {\r\n            this.decorator.plyCount = 0;\r\n        }\r\n        return this.wrappingDecorator?.processStandardMove\r\n            ? this.wrappingDecorator.processStandardMove(moveData)\r\n            : FENData.prototype.processStandardMove.call(this.decorator, moveData);\r\n    }\r\n    affectOptions(move, settings = createDefaultFENEffectSettings()) {\r\n        const results = this.wrappingDecorator?.affectOptions\r\n            ? this.wrappingDecorator.affectOptions(move, settings)\r\n            : FENData.prototype.affectOptions.call(this.decorator, move, settings);\r\n        if (move.isIrreversible) {\r\n            this.decorator.plyCount = 0;\r\n        }\r\n        else {\r\n            this.decorator.plyCount++;\r\n        }\r\n        const alivePlayers = totalPlayers - this.decorator.fenOptions.dead.filter(Boolean).length;\r\n        if (alivePlayers > 0 && Math.floor(this.decorator.plyCount / alivePlayers) > this.totalFullMoves) {\r\n            this.decorator.assignGeneralTermination(\"50-move Rule\");\r\n            this.injectIntoBaseClass(function () {\r\n                this.spreadPointsBetweenPlayersEvenly();\r\n            })();\r\n        }\r\n        return results;\r\n    }\r\n}\r\n","import { FENData } from \"../../../FENData/FENData\";\r\nimport { createDefaultFENEffectSettings } from \"../../../FENData/FENDataInterface\";\r\nimport { totalPlayers } from \"../../../GameInformation/GameData\";\r\nimport { VariantRule } from \"../../VariantRuleInterface\";\r\nimport { ForcedCapture } from \"../BoardDecorators/ForcedCapture\";\r\nimport { StalemateOptions, stalemateOptionsValues } from \"./StalemateOptions\";\r\nconst tag = \"giveaway\";\r\nexport class Giveaway extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(Giveaway);\r\n    }\r\n    static pointsForPiece = 3;\r\n    static stalematePoints = {\r\n        [1]: 200, [2]: 400, [3]: 600\r\n    };\r\n    dependencies = new Map([[ForcedCapture, []], [StalemateOptions, [stalemateOptionsValues.stalemateWins]]]);\r\n    initiallyAliveColors = totalPlayers;\r\n    getDecoratorType() { return FENData; }\r\n    getParameterValue() { return true; }\r\n    matchesPGNDeclaration(match) {\r\n        return /^Giveaway$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"Giveaway\";\r\n    }\r\n    getInformation() {\r\n        return {\r\n            name: \"Giveaway\", description: \"First to lose all pieces or stalemate wins\", tag\r\n        };\r\n    }\r\n    initDecoratorSettings() {\r\n        this.decorator.fenOptions.royal = [null, null, null, null];\r\n        this.initiallyAliveColors = this.decorator.fenOptions.dead\r\n            .map((d, i) => d || this.decorator.fenOptions.resigned[i])\r\n            .filter(Boolean).length;\r\n        if (this.wrappingDecorator?.initDecoratorSettings) {\r\n            this.wrappingDecorator.initDecoratorSettings();\r\n        }\r\n    }\r\n    processStandardMove(moveData) {\r\n        const capturedPieces = this.decorator.getCapturedPieces(moveData);\r\n        const board = this.decorator.board.board;\r\n        for (const capturedPiece of capturedPieces) {\r\n            const pieceString = board[capturedPiece[0]][capturedPiece[1]];\r\n            if (pieceString.isPiece()) {\r\n                this.assignPoints(pieceString.color, Giveaway.pointsForPiece, true);\r\n            }\r\n        }\r\n        if (this.wrappingDecorator?.processStandardMove) {\r\n            this.wrappingDecorator.processStandardMove(moveData);\r\n        }\r\n        else {\r\n            FENData.prototype.processStandardMove.call(this.decorator, moveData);\r\n        }\r\n        return { endPiece: [] };\r\n    }\r\n    affectOptions(move, settings = createDefaultFENEffectSettings()) {\r\n        let returnType;\r\n        if (this.wrappingDecorator?.affectOptions) {\r\n            returnType = this.wrappingDecorator.affectOptions(move, settings);\r\n        }\r\n        else {\r\n            returnType = FENData.prototype.affectOptions.call(this.decorator, move, settings);\r\n        }\r\n        this.decorator.fenOptions.royal = [null, null, null, null];\r\n        return returnType;\r\n    }\r\n    obtainPointsForMate() {\r\n        const aliveColors = this.decorator.fenOptions.dead.filter(Boolean).length;\r\n        switch (aliveColors) {\r\n            case 1:\r\n                if (this.initiallyAliveColors === totalPlayers) {\r\n                    return Giveaway.stalematePoints[1];\r\n                }\r\n            // * Fallthrough\r\n            case 2:\r\n                if (this.initiallyAliveColors >= totalPlayers - 1) {\r\n                    return Giveaway.stalematePoints[2];\r\n                }\r\n            // * Fallthrough\r\n            case 3:\r\n                return Giveaway.stalematePoints[3];\r\n            default:\r\n                console.error(`Unexpected players length ${aliveColors}`);\r\n                return 0;\r\n        }\r\n    }\r\n    assignPoints(sideToMove, points, isGiveawayAssigned = false) {\r\n        if (isGiveawayAssigned) {\r\n            if (this.wrappingDecorator?.assignPoints) {\r\n                this.wrappingDecorator.assignPoints(sideToMove, points);\r\n            }\r\n            else {\r\n                FENData.prototype.assignPoints.call(this.decorator, sideToMove, points);\r\n            }\r\n        }\r\n    }\r\n}\r\n","import { compareArrays } from \"@client/javascript/logic/utils/ArrayUtils\";\r\nimport { parseSingleCoordinate } from \"@client/javascript/logic/utils/Parsers/PGNParser\";\r\nimport { compareCoordinates } from \"../../../Board/BoardInterface\";\r\nimport { FENData } from \"../../../FENData/FENData\";\r\nimport { createDefaultFENEffectSettings } from \"../../../FENData/FENDataInterface\";\r\nimport { colors, convertCoordinateToPGN4, getPlayerNameFromColor } from \"../../../GameInformation/GameData\";\r\nimport { InternalMoveSignature } from \"../../../MoveTree/MoveTreeInterface\";\r\nimport { VariantRule } from \"../../VariantRuleInterface\";\r\nconst tag = \"kingOfTheHill\";\r\nexport class KingOfTheHill extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(KingOfTheHill);\r\n    }\r\n    static defaultCoordinates = [[7, 7], [7, 6], [6, 7], [6, 6]];\r\n    static defaultRoyal = \"K\";\r\n    hillSquares;\r\n    constructor(hillSquares) {\r\n        super();\r\n        if (Array.isArray(hillSquares) && hillSquares.every((c) => Array.isArray(c) && c.length === 2 && c.every(n => typeof n === 'number'))) {\r\n            this.hillSquares = hillSquares;\r\n        }\r\n        else {\r\n            this.hillSquares = KingOfTheHill.defaultCoordinates;\r\n        }\r\n    }\r\n    getDecoratorType() { return FENData; }\r\n    getParameterValue() { return this.hillSquares; }\r\n    matchesPGNDeclaration(match) {\r\n        const matchArray = match.toLowerCase().match(/^KotH(?:=(.+))?$/i);\r\n        if (matchArray) {\r\n            if (matchArray[1]) {\r\n                const coordinatesArray = [];\r\n                const presumedOption = matchArray[1].split(\",\");\r\n                for (const coordinate of presumedOption) {\r\n                    const parsedCoordinate = parseSingleCoordinate(coordinate);\r\n                    if (parsedCoordinate) {\r\n                        coordinatesArray.push(parsedCoordinate);\r\n                    }\r\n                }\r\n                if (coordinatesArray.length > 0) {\r\n                    this.hillSquares = coordinatesArray;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    serializeToParsingForm() {\r\n        if (compareArrays(this.hillSquares, KingOfTheHill.defaultCoordinates)) {\r\n            return \"KotH\";\r\n        }\r\n        else {\r\n            return `KotH=${this.hillSquares.map(c => convertCoordinateToPGN4(c)).join(\",\")}`;\r\n        }\r\n    }\r\n    getInformation() {\r\n        return {\r\n            name: \"King of the Hill\",\r\n            description: \"A king reaching the hill will checkmate all opponents\",\r\n            tag\r\n        };\r\n    }\r\n    affectOptions(move, settings = createDefaultFENEffectSettings()) {\r\n        const { board, sideToMove, fenOptions } = this.decorator;\r\n        const returnValues = this.wrappingDecorator?.affectOptions\r\n            ? this.wrappingDecorator.affectOptions(move, settings)\r\n            : FENData.prototype.affectOptions.call(this.decorator, move, settings);\r\n        const royal = fenOptions.royal[sideToMove];\r\n        if (board.variantData.giveaway && this.hillSquares.some(c => {\r\n            const pieceString = board.board[c[0]][c[1]];\r\n            return pieceString.isPiece() && pieceString.piece === KingOfTheHill.defaultRoyal;\r\n        })) {\r\n            this.decorator.processInternalMove({ type: InternalMoveSignature.Stalemate });\r\n            returnValues.stalemates[sideToMove] = true;\r\n        }\r\n        else if (royal && this.hillSquares.some(c => compareCoordinates(c, royal))) {\r\n            const pointsForMate = this.decorator.obtainPointsForMate();\r\n            for (const color of colors) {\r\n                if (color === sideToMove)\r\n                    continue;\r\n                if (!fenOptions.dead[color]) {\r\n                    fenOptions.dead[color] = true;\r\n                    this.decorator.assignPoints(sideToMove, pointsForMate);\r\n                }\r\n            }\r\n            if (this.decorator.board.variantData.taboo) {\r\n                this.decorator.gameOver = `${getPlayerNameFromColor(sideToMove, this.decorator.fenOptions.wb).toUpperCase()} WON THE RACE!`;\r\n            }\r\n            else {\r\n                this.decorator.assignGeneralTermination(\"King of the Hill\");\r\n            }\r\n        }\r\n        return returnValues;\r\n    }\r\n}\r\n","import { createTuple, verifyTupleType } from \"@client/javascript/baseTypes\";\r\nimport { compareCoordinates } from \"../../../Board/BoardInterface\";\r\nimport { FENData } from \"../../../FENData/FENData\";\r\nimport { createDefaultFENEffectSettings } from \"../../../FENData/FENDataInterface\";\r\nimport { colors, totalPlayers } from \"../../../GameInformation/GameData\";\r\nimport { verifyStandardMove } from \"../../../MoveTree/MoveTree\";\r\nimport { VariantRule } from \"../../VariantRuleInterface\";\r\nconst tag = \"nCheck\";\r\nexport class NCheck extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(NCheck);\r\n    }\r\n    defaultChecks;\r\n    constructor(defaultChecks) {\r\n        super();\r\n        if (Array.isArray(defaultChecks) && verifyTupleType(defaultChecks, totalPlayers)\r\n            && defaultChecks.every((check) => typeof check === 'number')) {\r\n            this.defaultChecks = defaultChecks;\r\n        }\r\n        else {\r\n            this.defaultChecks = createTuple(3, totalPlayers);\r\n        }\r\n    }\r\n    getDecoratorType() { return FENData; }\r\n    getParameterValue() { return this.defaultChecks; }\r\n    matchesPGNDeclaration(match) {\r\n        const matchArray = match.toLowerCase().match(/^(\\d\\d?\\d?(?:-\\d\\d?\\d?){0,3})-check$/i);\r\n        if (matchArray) {\r\n            const checks = matchArray[1].split(\"-\");\r\n            for (let i = 0; i <= checks.length; i++) {\r\n                if (checks[i]) {\r\n                    this.defaultChecks[i] = Number(checks[i]);\r\n                }\r\n                else {\r\n                    while (i !== totalPlayers) {\r\n                        this.defaultChecks[i] = this.defaultChecks[i - 1];\r\n                        i++;\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    serializeToParsingForm() {\r\n        return `${this.defaultChecks.join(\"-\")}-check`;\r\n    }\r\n    getInformation() {\r\n        const checks = this.defaultChecks.filter(Boolean).reduce((p, n, i, arr) => p + (arr[i - 1] === arr[i] ? \"\" : `-${n}`), \"\").slice(1);\r\n        return {\r\n            name: `${checks}-Check`,\r\n            textualForm: `${checks}+`,\r\n            description: `Checking a king ${checks} times is checkmate`,\r\n            tag\r\n        };\r\n    }\r\n    initDecoratorSettings() {\r\n        const lives = this.decorator.fenOptions.lives;\r\n        for (const color of colors) {\r\n            if (lives[color] === null) {\r\n                lives[color] = this.defaultChecks[color];\r\n            }\r\n        }\r\n        if (this.wrappingDecorator?.initDecoratorSettings) {\r\n            this.wrappingDecorator.initDecoratorSettings();\r\n        }\r\n    }\r\n    affectOptions(move, settings = createDefaultFENEffectSettings()) {\r\n        const { board, sideToMove } = this.decorator;\r\n        const currentChecks = board.getCurrentChecks().map(arr => new Set(arr));\r\n        const isNCheckValidated = !settings.ignoreCheckmateChecks && !settings.ignoreNextTurn;\r\n        const results = this.wrappingDecorator?.affectOptions\r\n            ? this.wrappingDecorator.affectOptions(move, settings)\r\n            : FENData.prototype.affectOptions.call(this.decorator, move, settings);\r\n        const isStandardMove = verifyStandardMove(move);\r\n        if (isNCheckValidated) {\r\n            board.pregenerateAttacks(sideToMove);\r\n            const updatedChecks = board.getCurrentChecks(sideToMove);\r\n            const playerChecks = createTuple(0, totalPlayers);\r\n            for (const color of colors) {\r\n                for (const coordinate of updatedChecks[color]) {\r\n                    const royalPiece = this.decorator.fenOptions.royal[color];\r\n                    if (!currentChecks[color].has(coordinate)\r\n                        || (royalPiece && isStandardMove\r\n                            && compareCoordinates(move.endCoordinates, royalPiece))) {\r\n                        playerChecks[color]++;\r\n                    }\r\n                }\r\n            }\r\n            if (this.decorator.fenOptions.lives.every((live) => live !== null)) {\r\n                for (const color of colors) {\r\n                    this.decorator.fenOptions.lives[color] -= playerChecks[color];\r\n                    if (this.decorator.fenOptions.lives[color] <= 0) {\r\n                        this.decorator.assignPoints(sideToMove, this.decorator.obtainPointsForMate());\r\n                        this.decorator.turnPiecesDead(color);\r\n                        this.decorator.fenOptions.lives[color] = 0;\r\n                    }\r\n                }\r\n            }\r\n            if (this.decorator.getRealPlayers() > 1) {\r\n                this.decorator.sideToMove = this.decorator.nextTurn(sideToMove);\r\n                board.pregenerateAttacks();\r\n            }\r\n        }\r\n        return results;\r\n    }\r\n}\r\n","import { FENData } from \"../../../FENData/FENData\";\r\nimport { getOppositePlacedColor, totalPlayers } from \"../../../GameInformation/GameData\";\r\nimport { pieceControlConfigSettings } from \"../../../PieceControl/PieceControlInterface\";\r\nimport { VariantRule } from \"../../VariantRuleInterface\";\r\nconst tag = \"oppositeMultiplier\";\r\nexport class OppositeMultiplier extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(OppositeMultiplier);\r\n    }\r\n    oppositeMultiplierValue = 2;\r\n    getDecoratorType() { return FENData; }\r\n    getParameterValue() { return this.oppositeMultiplierValue; }\r\n    matchesPGNDeclaration(match) {\r\n        const matchArray = match.toLowerCase().match(/^OppX=(2|3|4|5|6)$/i);\r\n        if (matchArray) {\r\n            this.oppositeMultiplierValue = Number(matchArray[1]);\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    serializeToParsingForm() {\r\n        return `OppX=${this.oppositeMultiplierValue}`;\r\n    }\r\n    getInformation() {\r\n        return {\r\n            name: \"Opposite's piece value\",\r\n            textualForm: `Ox${this.oppositeMultiplierValue}`,\r\n            description: `Opposite's pieces are worth ${this.oppositeMultiplierValue} times their normal points value until one player is eliminated`,\r\n            tag\r\n        };\r\n    }\r\n    getPointsForPiece(pieceString) {\r\n        const aliveColors = this.decorator.fenOptions.dead\r\n            .map((d, i) => d || this.decorator.fenOptions.resigned[i])\r\n            .filter(Boolean).length;\r\n        if (aliveColors === totalPlayers && pieceString.isPiece()\r\n            && pieceString.color === getOppositePlacedColor(this.decorator.sideToMove)) {\r\n            return pieceControlConfigSettings[pieceString.piece].points.singlesPoints * this.oppositeMultiplierValue;\r\n        }\r\n        else {\r\n            return this.wrappingDecorator?.getPointsForPiece\r\n                ? this.wrappingDecorator.getPointsForPiece(pieceString)\r\n                : FENData.prototype.getPointsForPiece.call(this.decorator, pieceString);\r\n        }\r\n    }\r\n}\r\n","import { SpecialMove } from \"../../../MoveTree/MoveTreeInterface\";\r\nimport { FENData } from \"../../../FENData/FENData\";\r\nimport { VariantRule } from \"../../VariantRuleInterface\";\r\nimport { getOppositePlacedColor } from \"../../../GameInformation/GameData\";\r\nconst tag = \"oppositeSideCastling\";\r\nexport class OppositeSideCastling extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(OppositeSideCastling);\r\n    }\r\n    getDecoratorType() { return FENData; }\r\n    getParameterValue() { return true; }\r\n    matchesPGNDeclaration(match) {\r\n        return /^OppositeSideCastling$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"OppositeSideCastling\";\r\n    }\r\n    getInformation() {\r\n        return { name: \"Opposite-side Castling\", description: \"Once your opponent has castled, you can only castle to the opposite side\", tag };\r\n    }\r\n    processStandardMove(moveData) {\r\n        let result;\r\n        if (this.wrappingDecorator?.processStandardMove) {\r\n            result = this.wrappingDecorator.processStandardMove(moveData);\r\n        }\r\n        else {\r\n            result = FENData.prototype.processStandardMove.call(this.decorator, moveData);\r\n        }\r\n        if (\"specialType\" in moveData) {\r\n            let castlingDataReference;\r\n            if (moveData.specialType === SpecialMove.CastlingKingside) {\r\n                castlingDataReference = this.decorator.fenOptions.castleKingside;\r\n            }\r\n            else if (moveData.specialType === SpecialMove.CastlingQueenside) {\r\n                castlingDataReference = this.decorator.fenOptions.castleQueenside;\r\n            }\r\n            if (castlingDataReference) {\r\n                castlingDataReference[getOppositePlacedColor(this.decorator.sideToMove)] = false;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n","import { verifyInternalMove, verifyStandardMove } from \"../../../MoveTree/MoveTree\";\r\nimport { FENData } from \"../../../FENData/FENData\";\r\nimport { createDefaultFENEffectSettings } from \"../../../FENData/FENDataInterface\";\r\nimport { createPieceFromData } from \"../../../GameInformation/GameUnits/PieceString\";\r\nimport { VariantRule } from \"../../VariantRuleInterface\";\r\nconst tag = \"piecesGoToBanks\";\r\nexport class PiecesGoToBanks extends VariantRule {\r\n    getDecoratorType() { return FENData; }\r\n    getParameterValue() { return true; }\r\n    matchesPGNDeclaration(match) {\r\n        return /^Crazy(?:house|wan)$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"\";\r\n    }\r\n    getInformation() {\r\n        return { name: \"Bank Captures\", description: \"Captured pieces go to banks\", tag };\r\n    }\r\n    affectOptions(move, settings = createDefaultFENEffectSettings()) {\r\n        if (this.decorator.fenOptions.areBanksEnabled[this.decorator.sideToMove]) {\r\n            if (!verifyInternalMove(move)) {\r\n                if (verifyStandardMove(move)) {\r\n                    const captures = this.decorator.getCapturedPieces(move);\r\n                    const bank = this.decorator.fenOptions.bank, sideToMove = this.decorator.sideToMove;\r\n                    const addPieceToBank = (piece) => {\r\n                        for (const [key, value] of bank[sideToMove]) {\r\n                            if (key.piece === piece && key.color === sideToMove) {\r\n                                bank[sideToMove].set(key, value + 1);\r\n                                return;\r\n                            }\r\n                        }\r\n                        bank[sideToMove].set(createPieceFromData(sideToMove, piece), 1);\r\n                    };\r\n                    captures.forEach(c => {\r\n                        for (const [key, value] of this.decorator.fenOptions.promotedFrom) {\r\n                            if (key[0] === c[0] && key[1] === c[1]) {\r\n                                this.decorator.fenOptions.promotedFrom.delete(key);\r\n                                addPieceToBank(value);\r\n                                return;\r\n                            }\r\n                        }\r\n                        addPieceToBank(this.decorator.board.board[c[0]][c[1]].piece);\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        if (this.wrappingDecorator?.affectOptions) {\r\n            return this.wrappingDecorator.affectOptions(move, settings);\r\n        }\r\n        else {\r\n            return FENData.prototype.affectOptions.call(this.decorator, move, settings);\r\n        }\r\n    }\r\n}\r\n","import { FENData } from \"../../../FENData/FENData\";\r\nimport { totalPlayers } from \"../../../GameInformation/GameData\";\r\nimport { VariantRule } from \"../../VariantRuleInterface\";\r\nconst tag = \"playForMate\";\r\nexport class PlayForMate extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(PlayForMate);\r\n    }\r\n    initiallyAliveColors = totalPlayers;\r\n    static checkmatePoints = {\r\n        [1]: 24, [2]: 32, [3]: 48\r\n    };\r\n    getDecoratorType() { return FENData; }\r\n    getParameterValue() { return true; }\r\n    matchesPGNDeclaration(match) {\r\n        return /^Play4Mate$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"Play4Mate\";\r\n    }\r\n    getInformation() {\r\n        return {\r\n            name: \"Play for mate\",\r\n            description: \"No points for pieces, only checkmates matter\",\r\n            tag\r\n        };\r\n    }\r\n    initDecoratorSettings() {\r\n        this.initiallyAliveColors = this.decorator.fenOptions.dead\r\n            .map((d, i) => d || this.decorator.fenOptions.resigned[i])\r\n            .filter(Boolean).length;\r\n        if (this.wrappingDecorator?.initDecoratorSettings) {\r\n            this.wrappingDecorator.initDecoratorSettings();\r\n        }\r\n    }\r\n    obtainPointsForMate() {\r\n        const aliveColors = this.decorator.fenOptions.dead.filter(Boolean).length;\r\n        switch (aliveColors) {\r\n            case 1:\r\n                if (this.initiallyAliveColors === totalPlayers) {\r\n                    return PlayForMate.checkmatePoints[1];\r\n                }\r\n            // * Fallthrough\r\n            case 2:\r\n                if (this.initiallyAliveColors >= totalPlayers - 1) {\r\n                    return PlayForMate.checkmatePoints[2];\r\n                }\r\n            // * Fallthrough\r\n            case 3:\r\n                return PlayForMate.checkmatePoints[3];\r\n            default:\r\n                console.error(`Unexpected players length ${aliveColors}`);\r\n                return 0;\r\n        }\r\n    }\r\n    getPointsForPiece() {\r\n        return 0;\r\n    }\r\n}\r\n","import { FENData } from \"../../../FENData/FENData\";\r\nimport { VariantRule } from \"../../VariantRuleInterface\";\r\nconst tag = \"pointsForMate\";\r\nexport class PointsForMate extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(PointsForMate);\r\n    }\r\n    pointsForMate;\r\n    constructor(pointsForMate) {\r\n        super();\r\n        if (typeof pointsForMate === \"number\") {\r\n            this.pointsForMate = pointsForMate;\r\n        }\r\n        else {\r\n            this.pointsForMate = 20;\r\n        }\r\n    }\r\n    getDecoratorType() { return FENData; }\r\n    getParameterValue() { return this.pointsForMate; }\r\n    matchesPGNDeclaration(match) {\r\n        const matchArray = match.match(/^PointsForMate=(3|5|10|40)$/i);\r\n        if (matchArray) {\r\n            this.pointsForMate = Number(matchArray[1]);\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    serializeToParsingForm() {\r\n        return `PointsForMate=${this.pointsForMate}`;\r\n    }\r\n    getInformation() {\r\n        return {\r\n            name: `${this.pointsForMate}-point checkmate`,\r\n            textualForm: `+${this.pointsForMate}`,\r\n            description: `Checkmates & king captures are worth ${this.pointsForMate} points`,\r\n            tag\r\n        };\r\n    }\r\n    obtainPointsForMate() {\r\n        return this.pointsForMate;\r\n    }\r\n}\r\n","import { throwOnNever } from \"@client/javascript/baseTypes\";\r\nimport { FENData } from \"../../../FENData/FENData\";\r\nimport { InternalMoveSignature } from \"../../../MoveTree/MoveTreeInterface\";\r\nimport { VariantRule } from \"../../VariantRuleInterface\";\r\nconst tag = \"stalemateOptions\";\r\nexport const stalemateOptionsValues = {\r\n    stalemateLoses: \"loss\",\r\n    stalemateWins: \"win\",\r\n    stalemateDraws: \"draw\"\r\n};\r\nexport const verifyCustomStalemateValue = (v) => Object.values(stalemateOptionsValues).includes(v);\r\nexport class StalemateOptions extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(StalemateOptions);\r\n    }\r\n    type;\r\n    isFFA = false;\r\n    constructor(type) {\r\n        super();\r\n        if (typeof type === 'string' && verifyCustomStalemateValue(type)) {\r\n            this.type = type;\r\n        }\r\n        else {\r\n            this.type = false;\r\n        }\r\n    }\r\n    getDecoratorType() { return FENData; }\r\n    getParameterValue() { return this.type; }\r\n    matchesPGNDeclaration(match) {\r\n        const matchArray = match.toLowerCase().match(/^Stalemate=(.+)$/i);\r\n        if (matchArray) {\r\n            const presumedOption = matchArray[1];\r\n            if (verifyCustomStalemateValue(presumedOption)) {\r\n                this.type = presumedOption;\r\n            }\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    serializeToParsingForm() {\r\n        return `Stalemate=${this.type || \"draw\"}`;\r\n    }\r\n    getInformation() {\r\n        const description = this.type === \"draw\"\r\n            ? `Stalemate is a draw`\r\n            : this.isFFA\r\n                ? `The remaining players share the points`\r\n                : `The stalemated player ${this.type === \"loss\" ? \"loses\" : \"wins\"}`;\r\n        return { name: description, description, tag };\r\n    }\r\n    initDecoratorSettings() {\r\n        if (this.type === false) {\r\n            if (this.decorator.board.gameType.isFFA()\r\n                && this.decorator.fenOptions.dead.filter(Boolean).length > 2) {\r\n                this.type = \"win\";\r\n                this.isFFA = true;\r\n            }\r\n            else {\r\n                this.type = \"draw\";\r\n                this.isFFA = false;\r\n            }\r\n        }\r\n        if (this.wrappingDecorator?.initDecoratorSettings) {\r\n            this.wrappingDecorator.initDecoratorSettings();\r\n        }\r\n    }\r\n    processInternalMove(internalMove) {\r\n        const currentTurn = this.decorator.sideToMove;\r\n        const returnValues = this.wrappingDecorator?.processInternalMove\r\n            ? this.wrappingDecorator.processInternalMove(internalMove)\r\n            : FENData.prototype.processInternalMove.call(this.decorator, internalMove);\r\n        if (internalMove.type === InternalMoveSignature.Stalemate) {\r\n            const pointsForMate = this.decorator.obtainPointsForMate();\r\n            switch (this.type) {\r\n                case \"loss\":\r\n                    if (!this.isFFA) {\r\n                        this.decorator.points[currentTurn] += pointsForMate;\r\n                        break;\r\n                    }\r\n                // * Fallthrough\r\n                case \"draw\":\r\n                    this.injectIntoBaseClass(function () {\r\n                        this.spreadPointsBetweenPlayersEvenly();\r\n                    })();\r\n                    break;\r\n                case \"win\":\r\n                    this.decorator.points[this.decorator.sideToMove] += pointsForMate;\r\n                    break;\r\n                case false:\r\n                    break;\r\n                default:\r\n                    throwOnNever(this.type);\r\n            }\r\n            if (this.decorator.getRealPlayers() === 1) {\r\n                this.decorator.assignGeneralTermination(\"Stalemate\", currentTurn);\r\n            }\r\n        }\r\n        return returnValues;\r\n    }\r\n}\r\n","import { compareCoordinates } from \"../../../Board/BoardInterface\";\r\nimport { FENData } from \"../../../FENData/FENData\";\r\nimport { createDefaultFENEffectSettings } from \"../../../FENData/FENDataInterface\";\r\nimport { colors, totalPlayers } from \"../../../GameInformation/GameData\";\r\nimport { verifyNumericColor } from \"../../../GameInformation/GameUnits/GameUnits\";\r\nimport { createPieceFromData, deadColorIndex } from \"../../../GameInformation/GameUnits/PieceString\";\r\nimport { InternalMoveSignature } from \"../../../MoveTree/MoveTreeInterface\";\r\nimport { pieceControlConfigSettings } from \"../../../PieceControl/PieceControlInterface\";\r\nimport { VariantRule } from \"../../VariantRuleInterface\";\r\nconst tag = \"takeover\";\r\nexport class Takeover extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(Takeover);\r\n    }\r\n    getDecoratorType() { return FENData; }\r\n    getParameterValue() { return true; }\r\n    matchesPGNDeclaration(match) {\r\n        return /^Takeover$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"Takeover\";\r\n    }\r\n    getInformation() {\r\n        return {\r\n            name: \"Takeover\",\r\n            description: \"Checkmate players to take control of their pieces. Resigned armies move randomly\",\r\n            tag\r\n        };\r\n    }\r\n    processInternalMove(internalMove) {\r\n        if (internalMove.type === InternalMoveSignature.Resign\r\n            || internalMove.type === InternalMoveSignature.ClaimWin\r\n            || internalMove.type === InternalMoveSignature.Timeout) {\r\n            const { sideToMove, fenOptions, board } = this.decorator;\r\n            fenOptions.resigned[sideToMove] = true;\r\n            fenOptions.dead[sideToMove] = true;\r\n            for (const coordinate of board.getPlayerPieces()[sideToMove]) {\r\n                const piece = board.board[coordinate[0]][coordinate[1]].piece;\r\n                if (pieceControlConfigSettings[piece].moveGenerationSettings.isPawn) {\r\n                    board.board[coordinate[0]][coordinate[1]] = createPieceFromData(deadColorIndex, piece);\r\n                }\r\n            }\r\n            const deadPlayers = fenOptions.dead.map((d, i) => d || fenOptions.resigned[i]).filter(Boolean);\r\n            if (deadPlayers.length === totalPlayers - 1) {\r\n                const alivePlayer = deadPlayers.findIndex(d => !d);\r\n                if (verifyNumericColor(alivePlayer)) {\r\n                    this.decorator.assignPoints(alivePlayer, this.decorator.countTotalPointsOnBoard()\r\n                        .reduce((p, n, i) => p + (i === alivePlayer ? n : 0), 0));\r\n                }\r\n            }\r\n            return { stalemates: [false, false, false, false] };\r\n        }\r\n        else {\r\n            return this.wrappingDecorator?.processInternalMove\r\n                ? this.wrappingDecorator.processInternalMove(internalMove)\r\n                : FENData.prototype.processInternalMove.call(this.decorator, internalMove);\r\n        }\r\n    }\r\n    affectOptions(move, settings = createDefaultFENEffectSettings()) {\r\n        const sideToMove = this.decorator.sideToMove, detectedPieces = this.decorator.board.getPlayerPieces();\r\n        const results = this.wrappingDecorator?.affectOptions\r\n            ? this.wrappingDecorator.affectOptions(move, settings)\r\n            : FENData.prototype.affectOptions.call(this.decorator, move, settings);\r\n        for (const color of colors) {\r\n            if (!results.checkmates[color])\r\n                continue;\r\n            for (const piece of detectedPieces[sideToMove]) {\r\n                const pieceString = this.decorator.board.board[piece[0]][piece[1]];\r\n                if (!pieceString.isDead() || pieceControlConfigSettings[pieceString.piece].moveGenerationSettings.isPawn)\r\n                    continue;\r\n                this.decorator.board.board[piece[0]][piece[1]] = createPieceFromData(sideToMove, pieceString.piece);\r\n            }\r\n        }\r\n        return results;\r\n    }\r\n    countTotalPointsOnBoard() {\r\n        const resultingPoints = [0, 0, 0, 0];\r\n        this.decorator.board.getPlayerPieces().forEach((army, color) => {\r\n            if (this.decorator.fenOptions.zombieImmune[color])\r\n                return;\r\n            const royal = this.decorator.fenOptions.royal[color];\r\n            for (const coordinate of army) {\r\n                if (royal && compareCoordinates(coordinate, royal)) {\r\n                    resultingPoints[color] += this.decorator.obtainPointsForMate();\r\n                }\r\n                else {\r\n                    const piece = this.decorator.board.board[coordinate[0]][coordinate[1]].piece;\r\n                    resultingPoints[color] += pieceControlConfigSettings[piece].points.singlesPoints;\r\n                }\r\n            }\r\n        });\r\n        return resultingPoints;\r\n    }\r\n}\r\n","import { FENData } from \"../../../FENData/FENData\";\r\nimport { createDefaultFENEffectSettings } from \"../../../FENData/FENDataInterface\";\r\nimport { VariantRule } from \"../../VariantRuleInterface\";\r\nconst tag = \"threefoldRepetition\";\r\nexport class ThreefoldRepetition extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(ThreefoldRepetition);\r\n    }\r\n    totalRepetitionsRequired;\r\n    constructor(totalRepetitions) {\r\n        super();\r\n        if (typeof totalRepetitions === 'number' && totalRepetitions > 0) {\r\n            this.totalRepetitionsRequired = totalRepetitions;\r\n        }\r\n        else {\r\n            this.totalRepetitionsRequired = 3;\r\n        }\r\n    }\r\n    getDecoratorType() { return FENData; }\r\n    getParameterValue() { return this.totalRepetitionsRequired; }\r\n    matchesPGNDeclaration(match) {\r\n        const matchArray = match.match(/^ThreefoldRepetition=((?:\\d+)|(?:Infinity))$/i);\r\n        if (matchArray) {\r\n            this.totalRepetitionsRequired = Number(matchArray[1]);\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    serializeToParsingForm() {\r\n        return `ThreefoldRepetition=${this.totalRepetitionsRequired}`;\r\n    }\r\n    getInformation() {\r\n        const isDisabled = this.totalRepetitionsRequired === Infinity;\r\n        return {\r\n            name: isDisabled ? \"3-fold repetition disabled\" : `${this.totalRepetitionsRequired}-fold repetition`,\r\n            textualForm: \"\",\r\n            description: isDisabled ? \"3-fold repetition disabled\" : `After position repeats ${this.totalRepetitionsRequired} times game is over`,\r\n            tag\r\n        };\r\n    }\r\n    affectOptions(move, settings = createDefaultFENEffectSettings()) {\r\n        const results = this.wrappingDecorator?.affectOptions\r\n            ? this.wrappingDecorator.affectOptions(move, settings)\r\n            : FENData.prototype.affectOptions.call(this.decorator, move, settings);\r\n        const repetitions = this.decorator.board.moves.getHash(this.decorator.constructPreliminaryHashString());\r\n        if (repetitions + 1 >= this.totalRepetitionsRequired) {\r\n            this.decorator.assignGeneralTermination(\"Threefold Repetition\");\r\n            this.injectIntoBaseClass(function () {\r\n                this.spreadPointsBetweenPlayersEvenly();\r\n            })();\r\n        }\r\n        return results;\r\n    }\r\n}\r\n","import { createTuple } from \"../../../../../baseTypes\";\r\nimport { totalPlayers } from \"../../../GameInformation/GameData\";\r\nimport { PieceControl } from \"../../../PieceControl/PieceControl\";\r\nimport { VariantRule } from \"../../VariantRuleInterface\";\r\nconst tag = \"anyCapture\";\r\nexport class AnyCapture extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(AnyCapture);\r\n    }\r\n    getDecoratorType() { return PieceControl; }\r\n    getParameterValue() { return true; }\r\n    matchesPGNDeclaration(match) {\r\n        return /^AnyCapture$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"AnyCapture\";\r\n    }\r\n    getInformation() {\r\n        return { name: \"Any Capture\", description: \"You can capture your own pieces\", tag };\r\n    }\r\n    configure(configuration) {\r\n        const modifiedConfiguration = {\r\n            ...configuration,\r\n            immunePieces: createTuple(false, totalPlayers),\r\n        };\r\n        if (this.wrappingDecorator?.configure) {\r\n            this.wrappingDecorator.configure(modifiedConfiguration);\r\n        }\r\n        else {\r\n            PieceControl.prototype.configure.call(this.decorator, modifiedConfiguration);\r\n        }\r\n    }\r\n}\r\n","import { verifyPieceLetter, pieceControlConfigSettings } from \"@moveGeneration/PieceControl/PieceControlInterface\";\r\nimport { compileEnumeration, prefixWithIndefiniteArticle } from \"../../../../utils/StringFormatUtils\";\r\nimport { PieceControl } from \"../../../PieceControl/PieceControl\";\r\nimport { VariantRule } from \"../../VariantRuleInterface\";\r\nconst tag = \"promotionPieces\";\r\nexport class PromoteTo extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(PromoteTo);\r\n    }\r\n    promotionPieces;\r\n    constructor(promotionPieces) {\r\n        super();\r\n        this.promotionPieces = Array.isArray(promotionPieces)\r\n            && promotionPieces.every((p) => typeof p === 'string' && verifyPieceLetter(p))\r\n            ? promotionPieces : [\"Q\", \"R\", \"B\", \"N\"];\r\n    }\r\n    getDecoratorType() { return PieceControl; }\r\n    getParameterValue() { return this.promotionPieces; }\r\n    matchesPGNDeclaration(match) {\r\n        const matchArray = match.match(/^PromoteTo=([A-Zx]+)$/i);\r\n        if (matchArray) {\r\n            this.promotionPieces = matchArray[1].split(\"\");\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    serializeToParsingForm() {\r\n        return `PromoteTo=${this.promotionPieces.join(\"\")}`;\r\n    }\r\n    getInformation() {\r\n        const pieceNames = this.promotionPieces.reduce((p, c) => {\r\n            const pieceName = pieceControlConfigSettings[c].naming.name;\r\n            return [...p, pieceName];\r\n        }, []);\r\n        return {\r\n            name: \"Promotion Pieces\",\r\n            description: `Pawns promote to ${prefixWithIndefiniteArticle(compileEnumeration(pieceNames))}`,\r\n            tag\r\n        };\r\n    }\r\n    initDecoratorSettings() {\r\n        if (this.decorator.hooks.usePawnLogic) {\r\n            this.decorator.hooks.usePawnLogic.promotionPieces = this.promotionPieces;\r\n        }\r\n        if (this.wrappingDecorator?.initDecoratorSettings) {\r\n            this.wrappingDecorator.initDecoratorSettings();\r\n        }\r\n    }\r\n}\r\n","import { formatOrdinalNumber } from \"../../../../utils/StringFormatUtils\";\r\nimport { boardDimension } from \"../../../GameInformation/GameData\";\r\nimport { PieceControl } from \"../../../PieceControl/PieceControl\";\r\nimport { VariantRule } from \"../../VariantRuleInterface\";\r\nconst tag = \"promotionRank\";\r\nexport const disabledRank = 99;\r\nexport class PromotionRank extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(PromotionRank);\r\n    }\r\n    promotionRank;\r\n    constructor(promotionRank) {\r\n        super();\r\n        this.promotionRank = typeof promotionRank === 'number' ? promotionRank : 8;\r\n    }\r\n    getDecoratorType() { return PieceControl; }\r\n    getParameterValue() { return this.promotionRank; }\r\n    matchesPGNDeclaration(match) {\r\n        const matchArray = match.match(/^Prom=(\\d\\d?)$/i);\r\n        if (matchArray) {\r\n            this.promotionRank = Number(matchArray[1]);\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    serializeToParsingForm() {\r\n        return `Prom=${this.promotionRank}`;\r\n    }\r\n    getInformation() {\r\n        return {\r\n            name: \"Promotion Rank\",\r\n            description: `on the ${this.promotionRank}${formatOrdinalNumber(this.promotionRank)} rank`,\r\n            tag\r\n        };\r\n    }\r\n    initDecoratorSettings() {\r\n        if (this.decorator.hooks.usePawnLogic) {\r\n            this.decorator.hooks.usePawnLogic.promotionRanks = [boardDimension - this.promotionRank,\r\n                this.promotionRank - 1, this.promotionRank - 1, boardDimension - this.promotionRank];\r\n        }\r\n        if (this.wrappingDecorator?.initDecoratorSettings) {\r\n            this.wrappingDecorator.initDecoratorSettings();\r\n        }\r\n    }\r\n}\r\n","import { PieceControl } from \"../../../PieceControl/PieceControl\";\r\nimport { VariantRule } from \"../../VariantRuleInterface\";\r\nconst tag = \"royalsCannotCapture\";\r\nexport class RoyalsCannotCapture extends VariantRule {\r\n    getDecoratorType() { return PieceControl; }\r\n    getParameterValue() { return true; }\r\n    matchesPGNDeclaration() {\r\n        return false;\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"\";\r\n    }\r\n    getInformation() {\r\n        return { name: \"Royals Cannot Capture\", description: \"Royal pieces cannot capture pieces.\", tag };\r\n    }\r\n    getMovePossibility(configuration) {\r\n        const royal = this.decorator.fenData.fenOptions.royal[this.decorator.color];\r\n        if (royal && royal[0] === this.decorator.i && royal[1] === this.decorator.j) {\r\n            configuration.special = 1 /* AttackType.MoveOnly */;\r\n        }\r\n        if (this.wrappingDecorator?.getMovePossibility) {\r\n            return this.wrappingDecorator.getMovePossibility(configuration);\r\n        }\r\n        else {\r\n            return PieceControl.prototype.getMovePossibility.call(this.decorator, configuration);\r\n        }\r\n    }\r\n}\r\n","import { PieceControl } from \"../../../PieceControl/PieceControl\";\r\nimport { VariantRule } from \"../../VariantRuleInterface\";\r\nconst tag = \"sideways\";\r\nexport class Sideways extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(Sideways);\r\n    }\r\n    getDecoratorType() { return PieceControl; }\r\n    getParameterValue() { return true; }\r\n    matchesPGNDeclaration(match) {\r\n        return /^Sideways$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"Sideways\";\r\n    }\r\n    getInformation() {\r\n        return { name: \"Sideways\", description: \"Pawns can also move one square sideways\", tag };\r\n    }\r\n    getPossibleCells() {\r\n        if (this.decorator.hooks.usePawnLogic) {\r\n            this.injectIntoBaseClass(function () {\r\n                this.generateJumpAttack({ displacement: [0, -1], special: 1 /* AttackType.MoveOnly */ });\r\n                this.generateJumpAttack({ displacement: [0, 1], special: 1 /* AttackType.MoveOnly */ });\r\n            })();\r\n        }\r\n        if (this.wrappingDecorator?.getPossibleCells) {\r\n            this.wrappingDecorator.getPossibleCells();\r\n        }\r\n        else {\r\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\r\n            const prototype = Object.getPrototypeOf(this.decorator);\r\n            prototype.getPossibleCells.call(this.decorator);\r\n        }\r\n    }\r\n}\r\n","import { PieceControl } from \"../../../PieceControl/PieceControl\";\r\nimport { VariantRule } from \"../../VariantRuleInterface\";\r\nconst tag = \"stonewall\";\r\nexport class Stonewall extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(Stonewall);\r\n    }\r\n    getDecoratorType() { return PieceControl; }\r\n    getParameterValue() { return true; }\r\n    matchesPGNDeclaration(match) {\r\n        return /^Deadwall$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"Deadwall\";\r\n    }\r\n    getInformation() {\r\n        return { name: \"Stonewall\", description: \"Dead pieces cannot be captured\", tag };\r\n    }\r\n    getMovePossibility(configuration) {\r\n        const { displacement: [i, j], special } = configuration;\r\n        let modifiedConfiguration = configuration;\r\n        if ((special === 2 /* AttackType.AttackOnly */ || special === 0 /* AttackType.Normal */\r\n            || special === 3 /* AttackType.RayGen */) && this.decorator.board[i] && this.decorator.board[i][j]\r\n            && this.decorator.board[i][j].isDead()) {\r\n            modifiedConfiguration = {\r\n                ...configuration,\r\n                special: 1 /* AttackType.MoveOnly */\r\n            };\r\n        }\r\n        if (this.wrappingDecorator?.getMovePossibility) {\r\n            return this.wrappingDecorator.getMovePossibility(modifiedConfiguration);\r\n        }\r\n        else {\r\n            return PieceControl.prototype.getMovePossibility.call(this.decorator, modifiedConfiguration);\r\n        }\r\n    }\r\n}\r\n","import { PieceControl } from \"../../../PieceControl/PieceControl\";\r\nimport { VariantRule } from \"../../VariantRuleInterface\";\r\nconst tag = \"torpedo\";\r\nexport class Torpedo extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(Torpedo);\r\n    }\r\n    getDecoratorType() { return PieceControl; }\r\n    getParameterValue() { return true; }\r\n    matchesPGNDeclaration(match) {\r\n        return /^Torpedo$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"Torpedo\";\r\n    }\r\n    getInformation() {\r\n        return { name: \"Torpedo\", description: \"Pawns can always jump two squares\", tag };\r\n    }\r\n    configure(configuration) {\r\n        const modifiedConfiguration = {\r\n            ...configuration,\r\n            baseRank: true\r\n        };\r\n        if (this.wrappingDecorator?.configure) {\r\n            this.wrappingDecorator.configure(modifiedConfiguration);\r\n        }\r\n        else {\r\n            PieceControl.prototype.configure.call(this.decorator, modifiedConfiguration);\r\n        }\r\n    }\r\n}\r\n","import { verifyFunctionType, importAll } from \"../../../baseTypes\";\r\nexport class VariantRule {\r\n    dependencies = new Map();\r\n    static variantRuleList = [];\r\n    static initVariantRule(rv) {\r\n        VariantRule.variantRuleList.push(rv);\r\n    }\r\n    decorator;\r\n    wrappingDecorator;\r\n    initializeBaseDecorator(decorator) {\r\n        this.decorator = decorator;\r\n    }\r\n    initializeWrappingDecorator(decorator) {\r\n        this.wrappingDecorator = decorator;\r\n    }\r\n    injectIntoBaseClass(callback) {\r\n        return callback.bind(this.decorator);\r\n    }\r\n}\r\nconst objectPrototype = new Set(Reflect.ownKeys(Reflect.getPrototypeOf({}) ?? []));\r\nexport const decorateClassWithVariants = (baseClass, variants) => {\r\n    if (variants.length === 0) {\r\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\r\n        return baseClass;\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-argument\r\n    const decoratorProperties = Object.assign(Object.create(Object.getPrototypeOf(baseClass)), {});\r\n    const methods = new Set();\r\n    decoratorProperties.initDecoratorSettings = () => {\r\n        // Do nothing, this method only exists for the purpose of being overridden\r\n    };\r\n    methods.add(\"initDecoratorSettings\");\r\n    const lastInheritedMethods = new Set();\r\n    let basePrototype = null;\r\n    const verifyKeyInDecoratorProperties = (k) => typeof k !== 'number' && k in decoratorProperties && !objectPrototype.has(k) && !lastInheritedMethods.has(k);\r\n    while ((basePrototype = Reflect.getPrototypeOf(basePrototype ?? baseClass))) {\r\n        Reflect.ownKeys(basePrototype).forEach((k) => {\r\n            if (verifyKeyInDecoratorProperties(k)) {\r\n                decoratorProperties[k] = baseClass[k];\r\n                methods.add(k);\r\n                lastInheritedMethods.add(k);\r\n            }\r\n        });\r\n    }\r\n    let property;\r\n    for (property of Object.getOwnPropertyNames(baseClass)) {\r\n        const localProperty = property;\r\n        Object.defineProperty(decoratorProperties, property, {\r\n            get: function () {\r\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-return\r\n                return baseClass[localProperty];\r\n            },\r\n            set: function (v) {\r\n                baseClass[localProperty] = v;\r\n            }\r\n        });\r\n    }\r\n    decoratorProperties.__baseClass = baseClass;\r\n    for (const method of methods) {\r\n        const variantRuleChain = variants.filter(rv => method in rv);\r\n        if (variantRuleChain.length === 0)\r\n            continue;\r\n        variantRuleChain[0].initializeBaseDecorator(decoratorProperties);\r\n        const variantDecorator = variantRuleChain.reduce((p, c) => {\r\n            c.initializeBaseDecorator(decoratorProperties);\r\n            c.initializeWrappingDecorator(p);\r\n            return c;\r\n        });\r\n        if (method in decoratorProperties) {\r\n            const variant = Reflect.get(variantDecorator, method);\r\n            if (typeof variant === 'function') {\r\n                const variantFunc = variant;\r\n                if (verifyFunctionType(decoratorProperties[method])) {\r\n                    decoratorProperties[method] = (...args) => {\r\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-call\r\n                        return variantFunc.bind(variantDecorator)(...args);\r\n                    };\r\n                }\r\n            }\r\n        }\r\n    }\r\n    decoratorProperties.initDecoratorSettings();\r\n    // decoratorProperties act as a wrapper for the class, and as long as the base class extends\r\n    // DecoratorTarget<T>, one can safely verify that they are interchangeable in their interface\r\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\r\n    return decoratorProperties;\r\n};\r\nimportAll(require.context(\"./VariantRuleDefinitions\", true, /\\.ts$/));\r\n","import { Board } from \"../Board/Board\";\r\nimport { FENData } from \"../FENData/FENData\";\r\nimport { PieceControl } from \"../PieceControl/PieceControl\";\r\nimport { ForcedCapture } from \"./VariantRuleDefinitions/BoardDecorators/ForcedCapture\";\r\nimport { SeirawanSetup } from \"./VariantRuleDefinitions/BoardDecorators/SeirawanSetup\";\r\nimport { SetupChess } from \"./VariantRuleDefinitions/BoardDecorators/SetupChess\";\r\nimport { Taboo } from \"./VariantRuleDefinitions/BoardDecorators/Taboo\";\r\nimport { FiftyMoveRule } from \"./VariantRuleDefinitions/FENDataDecorators/FiftyMoveRule\";\r\nimport { Giveaway } from \"./VariantRuleDefinitions/FENDataDecorators/Giveaway\";\r\nimport { StalemateOptions } from \"./VariantRuleDefinitions/FENDataDecorators/StalemateOptions\";\r\nimport { ThreefoldRepetition } from \"./VariantRuleDefinitions/FENDataDecorators/ThreefoldRepetition\";\r\nimport { PromoteTo } from \"./VariantRuleDefinitions/PieceControlDecorators/PromoteTo\";\r\nimport { PromotionRank } from \"./VariantRuleDefinitions/PieceControlDecorators/PromotionRank\";\r\nimport { VariantRule } from \"./VariantRuleInterface\";\r\nexport const createBaseParsingTypes = () => ({\r\n    boardDecorators: [], pieceControlDecorators: [], fenDataDecorators: []\r\n});\r\nconst variantRulePriorities = [\r\n    SetupChess, ForcedCapture, Taboo, SeirawanSetup,\r\n    PromoteTo, PromotionRank,\r\n    Giveaway\r\n].reverse();\r\nconst differentiateDecoratorMethods = (variant, methods) => {\r\n    const verifyDecorator = (rv, type) => rv.getDecoratorType() === type;\r\n    if (verifyDecorator(variant, Board)) {\r\n        methods.boardDecorators(variant);\r\n    }\r\n    else if (verifyDecorator(variant, PieceControl)) {\r\n        methods.pieceControlDecorators(variant);\r\n    }\r\n    else if (verifyDecorator(variant, FENData)) {\r\n        methods.fenDataDecorators(variant);\r\n    }\r\n};\r\nexport const parseVariantRules = (rules) => {\r\n    const variantClasses = new Set();\r\n    const variantRuleList = new Set();\r\n    const forcedRules = [PromotionRank, PromoteTo, StalemateOptions, FiftyMoveRule, ThreefoldRepetition];\r\n    for (const variantRule of VariantRule.variantRuleList) {\r\n        const rv = new variantRule();\r\n        variantRuleList.add(rv);\r\n        variantClasses.add(variantRule);\r\n    }\r\n    const finalList = {\r\n        boardDecorators: [], pieceControlDecorators: [], fenDataDecorators: []\r\n    };\r\n    const rulesStrings = rules.split(/\\s+/);\r\n    const insertVariantRule = (variant) => {\r\n        differentiateDecoratorMethods(variant, {\r\n            boardDecorators: (variant) => {\r\n                finalList.boardDecorators.push(variant);\r\n            },\r\n            pieceControlDecorators: (variant) => {\r\n                finalList.pieceControlDecorators.push(variant);\r\n            },\r\n            fenDataDecorators: (variant) => {\r\n                finalList.fenDataDecorators.push(variant);\r\n            }\r\n        });\r\n        for (const [dependency, dependencyArgs] of variant.dependencies) {\r\n            if (!Object.values(finalList).some((decorators) => decorators.some(rv => rv instanceof dependency))) {\r\n                insertVariantRule(new dependency(...dependencyArgs));\r\n            }\r\n        }\r\n    };\r\n    for (const variant of variantRuleList) {\r\n        for (const ruleString of rulesStrings) {\r\n            if (variant.matchesPGNDeclaration(ruleString)) {\r\n                insertVariantRule(variant);\r\n                variantRuleList.delete(variant);\r\n            }\r\n        }\r\n    }\r\n    for (const forcedRule of forcedRules) {\r\n        const variant = new forcedRule();\r\n        differentiateDecoratorMethods(variant, {\r\n            boardDecorators: (variant) => {\r\n                if (!finalList.boardDecorators.some(rule => rule instanceof forcedRule)) {\r\n                    finalList.boardDecorators.push(variant);\r\n                }\r\n            },\r\n            pieceControlDecorators: (variant) => {\r\n                if (!finalList.pieceControlDecorators.some(rule => rule instanceof forcedRule)) {\r\n                    finalList.pieceControlDecorators.push(variant);\r\n                }\r\n            },\r\n            fenDataDecorators: (variant) => {\r\n                if (!finalList.fenDataDecorators.some(rule => rule instanceof forcedRule)) {\r\n                    finalList.fenDataDecorators.push(variant);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    for (const rule of variantRulePriorities) {\r\n        const resultingRule = new rule();\r\n        differentiateDecoratorMethods(resultingRule, {\r\n            boardDecorators: () => {\r\n                const index = finalList.boardDecorators.findIndex(c => c instanceof rule);\r\n                if (index !== -1) {\r\n                    finalList.boardDecorators.unshift(finalList.boardDecorators.splice(index, 1)[0]);\r\n                }\r\n            },\r\n            pieceControlDecorators: () => {\r\n                const index = finalList.pieceControlDecorators.findIndex(c => c instanceof rule);\r\n                if (index !== -1) {\r\n                    finalList.pieceControlDecorators.unshift(finalList.pieceControlDecorators.splice(index, 1)[0]);\r\n                }\r\n            },\r\n            fenDataDecorators: () => {\r\n                const index = finalList.fenDataDecorators.findIndex(c => c instanceof rule);\r\n                if (index !== -1) {\r\n                    finalList.fenDataDecorators.unshift(finalList.fenDataDecorators.splice(index, 1)[0]);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    return finalList;\r\n};\r\nexport const compileVariantRuleData = (rules) => {\r\n    const finalObject = {};\r\n    const variantRuleList = VariantRule.variantRuleList.map(rv => new rv());\r\n    for (const rule of variantRuleList) {\r\n        finalObject[rule.getInformation().tag] = false;\r\n    }\r\n    const ruleArray = [...rules.boardDecorators, ...rules.fenDataDecorators, ...rules.pieceControlDecorators];\r\n    for (const rule of ruleArray) {\r\n        // Safe type cast, the rule is enforced through VariantRule interface\r\n        finalObject[rule.getInformation().tag] = rule.getParameterValue();\r\n    }\r\n    return finalObject; // Safe type cast\r\n};\r\nexport const copyVariantRules = (rvs) => {\r\n    return rvs.map(rv => {\r\n        const parameterValue = rv.getParameterValue();\r\n        const parameterArray = parameterValue !== false ? [parameterValue] : [];\r\n        return Reflect.construct(rv.constructor, parameterArray);\r\n    });\r\n};\r\n","export const shuffleArray = (array) => {\r\n    let i = array.length;\r\n    let r = 0;\r\n    while (i !== 0) {\r\n        r = Math.floor(Math.random() * i--);\r\n        [array[i], array[r]] = [array[r], array[i]];\r\n    }\r\n    return array;\r\n};\r\nexport const compareArrays = (arr1, arr2) => {\r\n    if (arr1 === arr2)\r\n        return true;\r\n    if (arr1.length !== arr2.length)\r\n        return false;\r\n    for (let i = 0; i < arr1.length; i++) {\r\n        const first = arr1[i], second = arr2[i];\r\n        if (Array.isArray(first) && Array.isArray(second)) {\r\n            if (!compareArrays(first, second))\r\n                return false;\r\n        }\r\n        else if (first !== second) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n};\r\nexport function countMinimumOf2DArrayExcludingZero(array) {\r\n    let minimum = Infinity;\r\n    for (const row of array) {\r\n        for (const number of row) {\r\n            if (number !== 0 && number < minimum) {\r\n                minimum = number;\r\n            }\r\n        }\r\n    }\r\n    return minimum;\r\n}\r\nexport function findLastIndex(array, callback) {\r\n    let i = array.length;\r\n    while (i--) {\r\n        if (callback(array[i], i, array))\r\n            return i;\r\n    }\r\n    return -1;\r\n}\r\n","export const truncateNumber = (number, digits) => {\r\n    const multiplier = Math.pow(10, digits);\r\n    const adjusted = number * multiplier;\r\n    if (adjusted < 0) {\r\n        return Math.ceil(adjusted / multiplier);\r\n    }\r\n    else {\r\n        return Math.floor(adjusted / multiplier);\r\n    }\r\n};\r\nexport const bitCount = (number) => {\r\n    number = number - ((number >> 1) & 0x55555555);\r\n    number = (number & 0x33333333) + ((number >> 2) & 0x33333333);\r\n    return ((number + (number >> 4) & 0xF0F0F0F) * 0x1010101) >> 24;\r\n};\r\n","export function copyClass(instance, baseClass) {\r\n    const prototype = Object.getPrototypeOf(instance);\r\n    if (typeof prototype !== 'object')\r\n        throw new Error(\"Expected prototype to be an object\");\r\n    const properties = Object.create(prototype);\r\n    if (typeof properties !== 'object' || properties === null)\r\n        throw new Error(\"Expected prototype to be an object\");\r\n    const copy = Object.assign(properties, instance);\r\n    if (!(copy instanceof baseClass))\r\n        throw new Error(\"Expected prototype to not be overridden\");\r\n    return copy;\r\n}\r\n","import { createTupleFromCallback } from \"../../../baseTypes\";\r\nimport { initializeBoardSquares } from \"../../BaseInterfaces\";\r\nimport { FENData } from \"../../movegen/FENData/FENData\";\r\nimport { totalPlayers, validateTerminationString, VariantType } from \"../../movegen/GameInformation/GameData\";\r\nimport { playerEnum, verifyPlayerEnumValue } from \"../../movegen/GameInformation/GameUnits/GameUnits\";\r\nimport { emptyPieceString, nonPlayablePieces } from \"../../movegen/GameInformation/GameUnits/PieceString\";\r\nimport { compileVariantRuleData, createBaseParsingTypes, parseVariantRules } from \"../../movegen/VariantRules/VariantRuleSetup\";\r\nimport { parseFENData } from \"./ParseFENData\";\r\nimport { parsePGN4Moves } from \"./ParsePGNMoves\";\r\nconst parseVariantType = (variantType) => {\r\n    for (const type of Object.values(VariantType)) {\r\n        if (variantType === type) {\r\n            return type;\r\n        }\r\n    }\r\n    console.warn(`Variant type ${variantType} doesn't exist`);\r\n    return VariantType.FFA;\r\n};\r\nconst tagNamesEqual = (baseTag, definedTag) => baseTag.toLowerCase().startsWith(`[${definedTag.toLowerCase()} \"`);\r\nconst unwrapTag = (baseTag, definedTag) => baseTag.replace(`[${definedTag} \"`, \"\").slice(0, -1);\r\nconst parseTimeControl = (timeControl) => {\r\n    const matchArray = timeControl.match(/^((?:0\\.\\d\\d?)?|(?:\\d\\d?s?))(?:(?:(?:\\+|\\|)(\\d\\d?)(D?))|(\\smin))$/)?.slice(1);\r\n    const defaultTC = { baseTime: 180, increment: 2, isDelay: false };\r\n    if (matchArray) {\r\n        const [minutesMatch, secondsMatch, delay] = matchArray;\r\n        if (!secondsMatch)\r\n            return defaultTC;\r\n        defaultTC.isDelay = delay ? true : false;\r\n        if (/\\smin/.test(secondsMatch)) {\r\n            defaultTC.increment = 0;\r\n        }\r\n        else {\r\n            defaultTC.increment = Number(secondsMatch);\r\n        }\r\n        if (minutesMatch.endsWith(\"s\")) {\r\n            defaultTC.baseTime = Math.round(Number(minutesMatch.slice(0, -1)));\r\n        }\r\n        else {\r\n            defaultTC.baseTime = Number(minutesMatch) * 60;\r\n        }\r\n    }\r\n    return defaultTC;\r\n};\r\nexport const parseSingleCoordinate = (coordinate) => {\r\n    if (coordinate.length === 0)\r\n        return;\r\n    const parsedCoordinate = [14 - Number(coordinate.slice(1)), coordinate.charCodeAt(0) - 97];\r\n    if (Number.isNaN(parsedCoordinate[0]) || Number.isNaN(parsedCoordinate[1]))\r\n        return;\r\n    if (parsedCoordinate[0] < 0 || parsedCoordinate[0] > 13 || parsedCoordinate[1] < 0 || parsedCoordinate[1] > 13)\r\n        return;\r\n    return parsedCoordinate;\r\n};\r\nexport const parseEnPassantCoordinates = (coordinates) => {\r\n    if (coordinates.length === 0)\r\n        return;\r\n    const coordinatesArray = coordinates.split(\":\");\r\n    return [[14 - Number(coordinatesArray[0].slice(1)), coordinatesArray[0].charCodeAt(0) - 97],\r\n        [14 - Number(coordinatesArray[1].slice(1)), coordinatesArray[1].charCodeAt(0) - 97]];\r\n};\r\nexport const parsePGN = (pgn4) => {\r\n    let pgn4Tags, pgn4Moves = \"\";\r\n    const match = pgn4.match(/(?=1\\.\\s*?[xA-Z-a-n0-9-])/);\r\n    if (match?.index) {\r\n        pgn4Moves = pgn4.substring(match.index);\r\n        pgn4Tags = pgn4.substring(0, match.index).split(\"]\").map(t => t.trim());\r\n    }\r\n    else {\r\n        pgn4Tags = pgn4.split(\"]\").map(t => t.trim());\r\n    }\r\n    const resultingTags = {\r\n        [\"Variant\" /* VariantTag.GameType */]: VariantType.FFA,\r\n        [\"RuleVariants\" /* VariantTag.VariantRules */]: createBaseParsingTypes(),\r\n        [\"StartFen4\" /* VariantTag.StartingPosition */]: {\r\n            board: initializeBoardSquares(() => emptyPieceString),\r\n            fenData: new FENData(),\r\n            pieceSet: new Set()\r\n        },\r\n        [\"Date\" /* VariantTag.Date */]: new Date(),\r\n        [\"GameNr\" /* VariantTag.GameID */]: 0,\r\n        [\"Site\" /* VariantTag.Site */]: window.location.href,\r\n        [\"Termination\" /* VariantTag.Termination */]: undefined,\r\n        [\"TimeControl\" /* VariantTag.TimeControl */]: \"3|2\"\r\n    };\r\n    const players = createTupleFromCallback(() => ({}), totalPlayers);\r\n    const moves = pgn4Moves.length ? parsePGN4Moves(pgn4Moves) : [];\r\n    for (const tag of pgn4Tags) {\r\n        if (tagNamesEqual(tag, \"Variant\" /* VariantTag.GameType */)) {\r\n            resultingTags[\"Variant\" /* VariantTag.GameType */] = parseVariantType(unwrapTag(tag, \"Variant\" /* VariantTag.GameType */));\r\n        }\r\n        else if (tagNamesEqual(tag, \"StartFen4\" /* VariantTag.StartingPosition */)) {\r\n            resultingTags[\"StartFen4\" /* VariantTag.StartingPosition */] = parseFENData(unwrapTag(tag, \"StartFen4\" /* VariantTag.StartingPosition */));\r\n        }\r\n        else if (tagNamesEqual(tag, \"RuleVariants\" /* VariantTag.VariantRules */)) {\r\n            resultingTags[\"RuleVariants\" /* VariantTag.VariantRules */] = parseVariantRules(unwrapTag(tag, \"RuleVariants\" /* VariantTag.VariantRules */));\r\n        }\r\n        else if (tagNamesEqual(tag, \"Date\" /* VariantTag.Date */)) {\r\n            resultingTags[\"Date\" /* VariantTag.Date */] = new Date(unwrapTag(tag, \"Date\" /* VariantTag.Date */));\r\n        }\r\n        else if (tagNamesEqual(tag, \"GameNr\" /* VariantTag.GameID */)) {\r\n            const unwrapped = Number(unwrapTag(tag, \"GameNr\" /* VariantTag.GameID */));\r\n            if (!isNaN(unwrapped))\r\n                resultingTags[\"GameNr\" /* VariantTag.GameID */] = unwrapped;\r\n        }\r\n        else if (tagNamesEqual(tag, \"Site\" /* VariantTag.Site */)) {\r\n            resultingTags[\"Site\" /* VariantTag.Site */] = unwrapTag(tag, \"Site\" /* VariantTag.Site */);\r\n        }\r\n        else if (tagNamesEqual(tag, \"TimeControl\" /* VariantTag.TimeControl */)) {\r\n            const unwrapped = unwrapTag(tag, \"TimeControl\" /* VariantTag.TimeControl */);\r\n            if (/(?:\\d{1,3}|0\\.\\d{1,2})\\+\\d{1,3}D?/.test(unwrapped)) {\r\n                resultingTags[\"TimeControl\" /* VariantTag.TimeControl */] = unwrapped;\r\n            }\r\n        }\r\n        else if (tagNamesEqual(tag, \"Termination\" /* VariantTag.Termination */)) {\r\n            const unwrapped = unwrapTag(tag, \"Termination\" /* VariantTag.Termination */).toUpperCase();\r\n            if (validateTerminationString(unwrapped)) {\r\n                resultingTags[\"Termination\" /* VariantTag.Termination */] = unwrapped;\r\n            }\r\n        }\r\n        else {\r\n            const playerTagMatch = tag.match(/\\[(Red|Blue|Yellow|Green)(Elo)?\\s*?\"/);\r\n            if (playerTagMatch) {\r\n                const [, color, elo] = playerTagMatch;\r\n                const content = tag.replace(playerTagMatch[0], \"\").slice(0, -1);\r\n                if (!verifyPlayerEnumValue(color) || !content.length)\r\n                    continue;\r\n                if (!isNaN(Number(elo))) {\r\n                    players[playerEnum[color]].elo = Number(elo);\r\n                }\r\n                else {\r\n                    players[playerEnum[color]].name = content;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    const gameData = {\r\n        site: resultingTags[\"Site\" /* VariantTag.Site */],\r\n        gameNumber: resultingTags[\"GameNr\" /* VariantTag.GameID */],\r\n        date: resultingTags[\"Date\" /* VariantTag.Date */],\r\n        timeControl: parseTimeControl(resultingTags[\"TimeControl\" /* VariantTag.TimeControl */]),\r\n        players,\r\n        termination: resultingTags[\"Termination\" /* VariantTag.Termination */],\r\n        result: undefined,\r\n    };\r\n    const variantRuleData = compileVariantRuleData(resultingTags[\"RuleVariants\" /* VariantTag.VariantRules */]);\r\n    const promotionPieces = Array.isArray(variantRuleData.promotionPieces) ? variantRuleData.promotionPieces : [];\r\n    return {\r\n        gameData,\r\n        gameType: resultingTags[\"Variant\" /* VariantTag.GameType */],\r\n        variantRules: resultingTags[\"RuleVariants\" /* VariantTag.VariantRules */],\r\n        variantRuleData,\r\n        board: resultingTags[\"StartFen4\" /* VariantTag.StartingPosition */].board,\r\n        fenData: resultingTags[\"StartFen4\" /* VariantTag.StartingPosition */].fenData,\r\n        pieceSet: new Set([...resultingTags[\"StartFen4\" /* VariantTag.StartingPosition */].pieceSet,\r\n            ...promotionPieces].filter(e => !Object.values(nonPlayablePieces).includes(e))),\r\n        moves\r\n    };\r\n};\r\n","import { pieceControlConfigSettings, verifyPieceLetter } from \"@moveGeneration/PieceControl/PieceControlInterface\";\r\nimport { createTuple, verifyTupleType } from \"../../../baseTypes\";\r\nimport { initializeBoardSquares } from \"../../BaseInterfaces\";\r\nimport { colorEnum } from \"../../movegen/Board/Board\";\r\nimport { stringifyCoordinate } from \"../../movegen/Board/BoardInterface\";\r\nimport { FENData } from \"../../movegen/FENData/FENData\";\r\nimport { totalPlayers, colors } from \"../../movegen/GameInformation/GameData\";\r\nimport { verifyColorEnumValue, verifyNumericColor } from \"../../movegen/GameInformation/GameUnits/GameUnits\";\r\nimport { createPieceFromString, emptyPieceString } from \"../../movegen/GameInformation/GameUnits/PieceString\";\r\nimport { verifyZombieType } from \"../../movegen/VariantRule/Zombies/ZombieInterface\";\r\nimport { PGN4_SYNTAX } from \"./ParsePGNMoves\";\r\nimport { parseEnPassantCoordinates, parseSingleCoordinate } from \"./PGNParser\";\r\nconst modifyFourBooleanParameter = (part, fenDataArrayRef) => {\r\n    const booleans = part.split(\",\").map(e => Boolean(Number(e)));\r\n    if (verifyTupleType(booleans, totalPlayers)) {\r\n        fenDataArrayRef.forEach((_, i, arr) => arr[i] = booleans[i]);\r\n    }\r\n    else {\r\n        console.error(\"Incorrect amount of arguments for the boolean parameter length in FENData: \" + part);\r\n        console.trace(`Expected ${totalPlayers} arguments, but got ${booleans.length}`);\r\n    }\r\n};\r\nconst verifyParameterType = (param, type) => {\r\n    return Array.isArray(param) && verifyTupleType(param, totalPlayers) && param.every(v => typeof v === type);\r\n};\r\nexport const parseFENData = (fenDataString) => {\r\n    const fenData = new FENData();\r\n    const board = initializeBoardSquares(() => emptyPieceString);\r\n    const pieceSet = new Set();\r\n    const parts = fenDataString.split(\"-\");\r\n    if (parts.length < 7 || parts[parts.length - 1].split(\"/\").length !== 14) {\r\n        console.warn(\"FEN has less than 7 parts: \" + fenDataString);\r\n    }\r\n    else {\r\n        const sideToMove = parts[0].charAt(0).toLowerCase();\r\n        if (verifyColorEnumValue(sideToMove)) {\r\n            fenData.sideToMove = colorEnum[sideToMove];\r\n        }\r\n        else {\r\n            console.warn(\"FEN option 1: side to move is not an alphabetic color: \" + sideToMove);\r\n        }\r\n        modifyFourBooleanParameter(parts[1], fenData.fenOptions.dead);\r\n        modifyFourBooleanParameter(parts[2], fenData.fenOptions.castleKingside);\r\n        modifyFourBooleanParameter(parts[3], fenData.fenOptions.castleQueenside);\r\n        const points = parts[4].split(\",\").map(e => Number(e));\r\n        if (verifyTupleType(points, totalPlayers)) {\r\n            fenData.points = points;\r\n        }\r\n        else {\r\n            console.warn(`FEN option 5: points is of incorrect length: ${points.join(\",\")}`);\r\n        }\r\n        fenData.plyCount = Number(parts[5]);\r\n        const royals = createTuple(null, totalPlayers);\r\n        if (parts[6].startsWith(\"{\")) {\r\n            const initialParsing = JSON.parse(parts[6].replaceAll(\"(\", '[').replaceAll(\")\", \"]\").replaceAll(\"'\", '\"'));\r\n            if (typeof initialParsing !== 'object' || initialParsing === null)\r\n                throw new Error(\"Unexpected object definition syntax for \" + String(initialParsing));\r\n            for (const [key, value] of Object.entries(initialParsing)) {\r\n                switch (key) {\r\n                    case \"wb\":\r\n                    case \"noCorners\":\r\n                        if (typeof value === 'boolean') {\r\n                            fenData.fenOptions[key] = value;\r\n                        }\r\n                        break;\r\n                    case \"enPassant\":\r\n                        if (verifyParameterType(value, \"string\")) {\r\n                            for (const color of colors) {\r\n                                fenData.fenOptions.enPassant[color] = parseEnPassantCoordinates(value[color]) ?? null;\r\n                            }\r\n                        }\r\n                        break;\r\n                    case \"zombieType\":\r\n                        if (Array.isArray(value) && verifyTupleType(value, totalPlayers)\r\n                            && value.every((v) => typeof v === 'string')) {\r\n                            for (const color of colors) {\r\n                                const type = value[color];\r\n                                if (verifyZombieType(type)) {\r\n                                    fenData.fenOptions.zombieType[color] = type;\r\n                                }\r\n                            }\r\n                        }\r\n                        break;\r\n                    case \"zombieImmune\":\r\n                        if (verifyParameterType(value, \"boolean\")) {\r\n                            fenData.fenOptions.zombieImmune = value;\r\n                        }\r\n                        break;\r\n                    case \"resigned\":\r\n                    case \"flagged\":\r\n                        if (verifyParameterType(value, \"boolean\")) {\r\n                            for (const color of colors) {\r\n                                if (value[color]) {\r\n                                    fenData.fenOptions.resigned[color] = true;\r\n                                }\r\n                            }\r\n                        }\r\n                        break;\r\n                    case \"stalemated\":\r\n                        if (verifyParameterType(value, \"boolean\")) {\r\n                            for (const color of colors) {\r\n                                if (value[color]) {\r\n                                    fenData.fenOptions.dead[color] = true;\r\n                                }\r\n                            }\r\n                        }\r\n                        break;\r\n                    case \"pawnBaseRank\":\r\n                        if (typeof value === 'number') {\r\n                            fenData.fenOptions.pawnBaseRank = value;\r\n                        }\r\n                        break;\r\n                    case \"boxOffset\":\r\n                        if (typeof value === 'number' && verifyNumericColor(value)) {\r\n                            fenData.fenOptions.boxOffset = value;\r\n                        }\r\n                        break;\r\n                    case \"castleWith\":\r\n                        if (typeof value === 'string') {\r\n                            fenData.fenOptions.castleWith = value;\r\n                        }\r\n                        break;\r\n                    case \"dim\":\r\n                        if (Array.isArray(value) && verifyTupleType(value, 2)\r\n                            && value.every((v) => typeof v === 'number')) {\r\n                            fenData.fenOptions.dim = value;\r\n                        }\r\n                        break;\r\n                    case \"royal\":\r\n                        if (verifyParameterType(value, \"string\")) {\r\n                            for (const color of colors) {\r\n                                royals[color] = parseSingleCoordinate(value[color]) ?? null;\r\n                            }\r\n                        }\r\n                        break;\r\n                    case \"bank\":\r\n                        if (Array.isArray(value) && verifyTupleType(value, totalPlayers)\r\n                            && value.every((v) => typeof v === 'string')) {\r\n                            for (const color of colors) {\r\n                                for (const pieceDefinition of value[color].split(\",\")) {\r\n                                    const [piece, count = 1] = pieceDefinition.split(\"x\").map((e, i) => i === 1 ? Number(e) : e);\r\n                                    if (/^(?:r|b|y|g).$/.test(piece) && piece.charAt(1) in pieceControlConfigSettings) {\r\n                                        fenData.fenOptions.bank[color].set(createPieceFromString(piece), count);\r\n                                        const pieceLetter = piece.charAt(1);\r\n                                        if (verifyPieceLetter(pieceLetter)) {\r\n                                            pieceSet.add(pieceLetter);\r\n                                        }\r\n                                    }\r\n                                    else {\r\n                                        console.error(\"Wrong piece signature provided: \" + piece);\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        break;\r\n                    case \"setupComplete\":\r\n                        if (Array.isArray(value) && verifyTupleType(value, totalPlayers)\r\n                            && value.every((v) => typeof v === 'boolean')) {\r\n                            fenData.fenOptions.setupComplete = value;\r\n                        }\r\n                        break;\r\n                    case \"lives\":\r\n                    case \"setupPoints\":\r\n                        if (Array.isArray(value) && verifyTupleType(value, totalPlayers)\r\n                            && value.every((v) => typeof v === 'number')) {\r\n                            fenData.fenOptions[key] = value;\r\n                        }\r\n                        break;\r\n                    case \"seirawanDrops\":\r\n                        if (Array.isArray(value) && (verifyTupleType(value, totalPlayers) || verifyTupleType(value, totalPlayers + 1))\r\n                            && value.every((v) => Array.isArray(v))) {\r\n                            for (const color of colors) {\r\n                                const seirawanDropsArray = value[color];\r\n                                if (!seirawanDropsArray.every((v) => typeof v === 'string'))\r\n                                    continue;\r\n                                for (const pieceDefinition of seirawanDropsArray) {\r\n                                    if (!PGN4_SYNTAX.COORDINATE_REGEX.test(pieceDefinition))\r\n                                        continue;\r\n                                    const coordinate = parseSingleCoordinate(pieceDefinition);\r\n                                    if (coordinate) {\r\n                                        fenData.fenOptions.seirawanDrops[color].add(stringifyCoordinate(coordinate));\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        break;\r\n                    default:\r\n                        console.warn(\"Unknown FEN4 parameter: \" + key);\r\n                }\r\n            }\r\n        }\r\n        const position = parts[parts.length - 1].split(\"/\");\r\n        position.forEach((line, i) => {\r\n            let j = 0;\r\n            line.split(\",\").forEach((pieceStr) => {\r\n                const validatedPieceStr = pieceStr.endsWith('\"') ? pieceStr.slice(0, -1) : pieceStr;\r\n                if (isNaN(Number(validatedPieceStr))) {\r\n                    try {\r\n                        const pieceString = createPieceFromString(validatedPieceStr);\r\n                        board[i][j] = pieceString;\r\n                        if (pieceString.isPiece()) {\r\n                            if (pieceString.piece === \"K\" && !royals[pieceString.color]) {\r\n                                royals[pieceString.color] = [i, j];\r\n                            }\r\n                            pieceSet.add(pieceString.piece);\r\n                        }\r\n                    }\r\n                    catch (e) {\r\n                        console.trace(e);\r\n                    }\r\n                    j++;\r\n                }\r\n                else {\r\n                    j += Number(validatedPieceStr);\r\n                }\r\n            });\r\n        });\r\n        fenData.fenOptions.royal = royals;\r\n    }\r\n    return { fenData, board, pieceSet };\r\n};\r\n","import { colorEnum, verifyColorEnumValue } from \"../../movegen/GameInformation/GameUnits/GameUnits\";\r\nimport { createPieceFromData, deadColorIndex, duckPieceString } from \"../../movegen/GameInformation/GameUnits/PieceString\";\r\nimport { verifyInternalMove } from \"../../movegen/MoveTree/MoveTree\";\r\nimport { SpecialMove, InternalMoveSignature, createDummyMoveMetadata, verifyMoveWrapperProperties, verifyRequiredMove } from \"../../movegen/MoveTree/MoveTreeInterface\";\r\nimport { verifyPieceLetter } from \"../../movegen/PieceControl/PieceControlInterface\";\r\nimport { parseSingleCoordinate } from \"./PGNParser\";\r\nexport const PGN4_SYNTAX = {\r\n    SPLIT: '.',\r\n    PIECE_REGEX: /[xA-Z-a-nrbyg0-9-=+#@]/,\r\n    PIECE_REGEX_SIMPLIFIED: /[A-Z-a-n0-9-]/,\r\n    MOVE_CAPTURING_REGEX: /^[A-Z-]?([a-n]\\d{1,2})(?:-|x[A-Z-]?)[A-Z-]?([a-n]\\d{1,2})/,\r\n    DUCK_MOVE_CAPTURING_REGEX: /([a-n]\\d{1,2})?-([a-n]\\d{1,2})/,\r\n    DROPPING_MOVE_CAPTURING_REGEX: /?@([a-z])([A-Z-])-([a-n]\\d{1,2})/,\r\n    BRACKETS: {\r\n        COMMENT_START: '{',\r\n        COMMENT_END: '}',\r\n        VARIATION_START: '(',\r\n        VARIATION_END: ')'\r\n    },\r\n    COORDINATE_REGEX: /[a-n](?:(?:1[0-4])|(?:[1-9]))/\r\n};\r\nfunction obtainDuckMove(move) {\r\n    const match = move.match(PGN4_SYNTAX.DUCK_MOVE_CAPTURING_REGEX);\r\n    if (match) {\r\n        if (match[1]) {\r\n            const startCoordinates = parseSingleCoordinate(match[1]);\r\n            const endCoordinates = parseSingleCoordinate(match[2]);\r\n            if (!startCoordinates || !endCoordinates)\r\n                return;\r\n            return { startCoordinates, endCoordinates };\r\n        }\r\n        else {\r\n            const endCoordinates = parseSingleCoordinate(match[2]);\r\n            if (!endCoordinates)\r\n                return;\r\n            return { piece: duckPieceString, endCoordinates };\r\n        }\r\n    }\r\n    else\r\n        return;\r\n}\r\nfunction obtainInternalType(type) {\r\n    let internalMove;\r\n    for (internalMove in InternalMoveSignature) {\r\n        if (Object.prototype.hasOwnProperty.call(InternalMoveSignature, internalMove)) {\r\n            if (InternalMoveSignature[internalMove] === type)\r\n                return { type: InternalMoveSignature[internalMove] };\r\n        }\r\n    }\r\n}\r\nfunction obtainDroppingMove(move) {\r\n    const match = move.match(PGN4_SYNTAX.DROPPING_MOVE_CAPTURING_REGEX);\r\n    if (match) {\r\n        const [, color, piece, coordinate] = match;\r\n        if (!verifyColorEnumValue(color) || !verifyPieceLetter(piece))\r\n            return;\r\n        const endCoordinates = parseSingleCoordinate(coordinate);\r\n        if (!endCoordinates)\r\n            return;\r\n        return {\r\n            piece: createPieceFromData(colorEnum[color], piece),\r\n            endCoordinates\r\n        };\r\n    }\r\n    else\r\n        return;\r\n}\r\nfunction obtainStandardMove(move) {\r\n    const moveData = {};\r\n    const promotionMatch = move.match(/.*?=([A-Zx])/);\r\n    if (promotionMatch?.[1]) {\r\n        moveData.promotion = [createPieceFromData(deadColorIndex, promotionMatch[1].charAt(0))];\r\n    }\r\n    const moveCoordinates = move.match(PGN4_SYNTAX.MOVE_CAPTURING_REGEX);\r\n    if (moveCoordinates) {\r\n        const startCoordinate = parseSingleCoordinate(moveCoordinates[1]);\r\n        const endCoordinate = parseSingleCoordinate(moveCoordinates[2]);\r\n        if (!startCoordinate || !endCoordinate) {\r\n            throw new Error(`Coordinates of the move are undefined: ${moveCoordinates.join(\",\")}`);\r\n        }\r\n        moveData.startCoordinates = startCoordinate;\r\n        moveData.endCoordinates = endCoordinate;\r\n        // Safe cast: start coordinates and end coordinates are most definitely assigned above, the rest is optional for MoveData\r\n        return moveData;\r\n    }\r\n    else {\r\n        if (/O-O-O.*/.test(move)) {\r\n            return { startCoordinates: [-1, -1], endCoordinates: [-1, -1], specialType: SpecialMove.CastlingQueenside };\r\n        }\r\n        else if (/O-O.*/.test(move)) {\r\n            return { startCoordinates: [-1, -1], endCoordinates: [-1, -1], specialType: SpecialMove.CastlingKingside };\r\n        }\r\n        return;\r\n    }\r\n}\r\nfunction cloneMoveData(move) {\r\n    if (!verifyInternalMove(move)) {\r\n        if (\"startCoordinates\" in move) {\r\n            const newMove = {\r\n                startCoordinates: [...move.startCoordinates],\r\n                endCoordinates: [...move.endCoordinates]\r\n            };\r\n            if (\"specialType\" in move) {\r\n                newMove.specialType = move.specialType;\r\n            }\r\n            if (\"promotion\" in move) {\r\n                newMove.promotion = move.promotion;\r\n            }\r\n            return newMove;\r\n        }\r\n        else {\r\n            return {\r\n                endCoordinates: move.endCoordinates,\r\n                piece: move.piece\r\n            };\r\n        }\r\n    }\r\n    else {\r\n        return { type: move.type };\r\n    }\r\n}\r\nexport const parsePGN4Moves = (moves) => {\r\n    const parseMoves = (selectedMove, path) => {\r\n        const moveList = [];\r\n        const currentPath = path;\r\n        function getMoveIndexes(mI) {\r\n            while (selectedMove[mI] && PGN4_SYNTAX.PIECE_REGEX.test(selectedMove[mI]))\r\n                mI++;\r\n            return mI;\r\n        }\r\n        function parseComment(mI) {\r\n            while (selectedMove[mI] && selectedMove[mI] !== PGN4_SYNTAX.BRACKETS.COMMENT_END)\r\n                mI++;\r\n            return mI;\r\n        }\r\n        function getEnumeratorIndex(mI) {\r\n            while (selectedMove[mI] && /\\d|\\./.test(selectedMove[mI]))\r\n                mI++;\r\n            return --mI;\r\n        }\r\n        function findBracketIndex(i) {\r\n            let depth = 0;\r\n            for (; i < selectedMove.length; i++) {\r\n                switch (selectedMove[i]) {\r\n                    case PGN4_SYNTAX.BRACKETS.COMMENT_START:\r\n                        i = parseComment(i);\r\n                        break;\r\n                    case PGN4_SYNTAX.BRACKETS.VARIATION_START:\r\n                        depth++;\r\n                        break;\r\n                    case PGN4_SYNTAX.BRACKETS.VARIATION_END:\r\n                        if (--depth === 0) {\r\n                            return i;\r\n                        }\r\n                        break;\r\n                    default:\r\n                }\r\n            }\r\n            throw new TypeError(\"No matching parentheses for input \" + selectedMove);\r\n        }\r\n        function processMoveDataInsertion() {\r\n            if (currentMoveData) {\r\n                currentPath.push(++increment);\r\n                currentMove.path = currentPath.slice();\r\n                currentPath.pop();\r\n                currentMove.moveData = currentMoveData.map(m => cloneMoveData(m));\r\n                currentMove.metadata = createDummyMoveMetadata();\r\n                if (verifyMoveWrapperProperties(currentMove)) {\r\n                    moveList.push(Object.assign({}, currentMove));\r\n                }\r\n                else {\r\n                    console.error(`Not all properties of move wrapper are filled out: ${JSON.stringify(currentMove)}`);\r\n                }\r\n                currentMove = {\r\n                    alternativeLines: [],\r\n                    comment: \"\"\r\n                };\r\n                currentMoveData = undefined;\r\n            }\r\n        }\r\n        function obtainMoveFromInfo(info) {\r\n            const currentMove = [];\r\n            const internalType = obtainInternalType(info[0]);\r\n            if (info.length === 1 && internalType !== undefined) {\r\n                return [internalType];\r\n            }\r\n            const standardMove = obtainStandardMove(info);\r\n            if (standardMove)\r\n                currentMove.push(standardMove);\r\n            const droppingMove = obtainDroppingMove(info);\r\n            if (droppingMove)\r\n                currentMove.push(droppingMove);\r\n            const duckMove = obtainDuckMove(info);\r\n            if (duckMove)\r\n                currentMove.push(duckMove);\r\n            if (verifyRequiredMove(currentMove)) {\r\n                return currentMove;\r\n            }\r\n            else\r\n                throw new Error(`Move length is 0 for string ${info}`);\r\n        }\r\n        let currentMoveData;\r\n        let currentMove = {\r\n            alternativeLines: [],\r\n            comment: \"\"\r\n        };\r\n        let increment = -1, variationIncrement = -1;\r\n        try {\r\n            for (let i = 0; i < selectedMove.length; i++) {\r\n                const isNumNaN = isNaN(Number(selectedMove[i]));\r\n                if (isNumNaN && !/\\s/.test(selectedMove[i]) && selectedMove[i] !== PGN4_SYNTAX.SPLIT) {\r\n                    if (PGN4_SYNTAX.PIECE_REGEX_SIMPLIFIED.test(selectedMove[i])) {\r\n                        const index = getMoveIndexes(i);\r\n                        currentMoveData = obtainMoveFromInfo(selectedMove.substring(i, index));\r\n                        i = index;\r\n                    }\r\n                    else if (moves[i] === PGN4_SYNTAX.BRACKETS.COMMENT_START) {\r\n                        const index = parseComment(i);\r\n                        currentMove.comment = moves.substring(i + 1, index);\r\n                        i = index;\r\n                    }\r\n                    else if (moves[i] === PGN4_SYNTAX.BRACKETS.VARIATION_START) {\r\n                        const index = findBracketIndex(i);\r\n                        currentPath.push(increment + 1, ++variationIncrement);\r\n                        currentMove.alternativeLines?.push([...parseMoves(moves.substring(i + 1, index), currentPath.slice())]);\r\n                        i = index;\r\n                    }\r\n                }\r\n                else if ((selectedMove[i] === PGN4_SYNTAX.SPLIT && moves[i + 1] && moves[i + 1] === PGN4_SYNTAX.SPLIT)\r\n                    || (moves[i].trim() && !isNumNaN) && moves[i + 1] && (moves[i + 1] === PGN4_SYNTAX.SPLIT || !isNaN(Number(moves[i + 1])))) {\r\n                    if (!isNumNaN)\r\n                        i = getEnumeratorIndex(i);\r\n                    if (currentMoveData) {\r\n                        processMoveDataInsertion();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        catch (e) {\r\n            console.trace(e);\r\n        }\r\n        finally {\r\n            processMoveDataInsertion();\r\n            currentPath.push(increment + 1);\r\n            currentMove.path = currentPath.slice();\r\n            if (verifyMoveWrapperProperties(currentMove)) {\r\n                moveList.push(Object.assign({}, currentMove));\r\n            }\r\n        }\r\n        return moveList;\r\n    };\r\n    return parseMoves(moves, []);\r\n};\r\n","export const formatOrdinalNumber = (num) => {\r\n    const lastTwoDigits = Number(String(num).slice(-2));\r\n    if (lastTwoDigits > 3 && lastTwoDigits < 21)\r\n        return 'th';\r\n    switch (lastTwoDigits % 10) {\r\n        case 1: return \"st\";\r\n        case 2: return \"nd\";\r\n        case 3: return \"rd\";\r\n        default: return \"th\";\r\n    }\r\n};\r\nexport const compileEnumeration = (list) => {\r\n    if (list.length === 0)\r\n        return \"\";\r\n    if (list.length === 1)\r\n        return list[0];\r\n    let result = \"\";\r\n    for (let i = 0; i < list.length; i++) {\r\n        if (i === list.length - 2) {\r\n            result += ` ${list[i]} or `;\r\n        }\r\n        else if (i === list.length - 1) {\r\n            result += list[i];\r\n        }\r\n        else {\r\n            result += list[i] + \", \";\r\n        }\r\n    }\r\n    return result;\r\n};\r\nexport const prefixWithIndefiniteArticle = (str) => {\r\n    const vowels = /[AEUIO]/i;\r\n    return vowels.test(str.charAt(0)) ? \"an \" + str : \"a \" + str;\r\n};\r\nexport const convertSecondsToFlexibleHoursMinutesSeconds = (seconds) => {\r\n    if (seconds >= 3600) {\r\n        return new Date(seconds * 1000).toISOString().substring(11, 16);\r\n    }\r\n    else {\r\n        return new Date(seconds * 1000).toISOString().substring(14, 19);\r\n    }\r\n};\r\nexport const convertCamelCaseToKebabCase = (baseString) => {\r\n    return baseString.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\r\n};\r\nexport const hashString = (string) => {\r\n    let hash = 0;\r\n    for (let i = 0; i < string.length; i++) {\r\n        const char = string.charCodeAt(i);\r\n        hash = ((hash << 5) - hash) + char;\r\n        hash |= 0;\r\n    }\r\n    return hash;\r\n};\r\n","var map = {\n\t\"./BoardDecorators/AllowPassing.ts\": \"./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/AllowPassing.ts\",\n\t\"./BoardDecorators/AlternativeTeams.ts\": \"./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/AlternativeTeams.ts\",\n\t\"./BoardDecorators/BarePieceRule.ts\": \"./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/BarePieceRule.ts\",\n\t\"./BoardDecorators/Blindfold.ts\": \"./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/Blindfold.ts\",\n\t\"./BoardDecorators/CaptureTheKing.ts\": \"./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/CaptureTheKing.ts\",\n\t\"./BoardDecorators/Chess960.ts\": \"./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/Chess960.ts\",\n\t\"./BoardDecorators/Crazyhouse.ts\": \"./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/Crazyhouse.ts\",\n\t\"./BoardDecorators/DuckChess.ts\": \"./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/DuckChess.ts\",\n\t\"./BoardDecorators/FogOfWar.ts\": \"./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/FogOfWar.ts\",\n\t\"./BoardDecorators/ForcedCapture.ts\": \"./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/ForcedCapture.ts\",\n\t\"./BoardDecorators/GameMetadataRules.ts\": \"./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/GameMetadataRules.ts\",\n\t\"./BoardDecorators/Ghostboard.ts\": \"./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/Ghostboard.ts\",\n\t\"./BoardDecorators/ParadigmChess30.ts\": \"./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/ParadigmChess30.ts\",\n\t\"./BoardDecorators/PiecesFaceCenter.ts\": \"./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/PiecesFaceCenter.ts\",\n\t\"./BoardDecorators/SeirawanSetup.ts\": \"./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/SeirawanSetup.ts\",\n\t\"./BoardDecorators/SelfCheck.ts\": \"./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/SelfCheck.ts\",\n\t\"./BoardDecorators/SetupChess.ts\": \"./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/SetupChess.ts\",\n\t\"./BoardDecorators/Taboo.ts\": \"./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/Taboo.ts\",\n\t\"./BoardVariantModules/InsufficientMaterial/InsufficientMaterialGeneration.ts\": \"./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/BoardVariantModules/InsufficientMaterial/InsufficientMaterialGeneration.ts\",\n\t\"./BoardVariantModules/InsufficientMaterial/PieceMedianCounter.ts\": \"./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/BoardVariantModules/InsufficientMaterial/PieceMedianCounter.ts\",\n\t\"./FENDataDecorators/Atomic.ts\": \"./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/Atomic.ts\",\n\t\"./FENDataDecorators/EnPassant.ts\": \"./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/EnPassant.ts\",\n\t\"./FENDataDecorators/FatalCapture.ts\": \"./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/FatalCapture.ts\",\n\t\"./FENDataDecorators/FiftyMoveRule.ts\": \"./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/FiftyMoveRule.ts\",\n\t\"./FENDataDecorators/Giveaway.ts\": \"./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/Giveaway.ts\",\n\t\"./FENDataDecorators/KingOfTheHill.ts\": \"./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/KingOfTheHill.ts\",\n\t\"./FENDataDecorators/NCheck.ts\": \"./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/NCheck.ts\",\n\t\"./FENDataDecorators/OppositeMultiplier.ts\": \"./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/OppositeMultiplier.ts\",\n\t\"./FENDataDecorators/OppositeSideCastling.ts\": \"./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/OppositeSideCastling.ts\",\n\t\"./FENDataDecorators/PiecesGoToBanks.ts\": \"./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/PiecesGoToBanks.ts\",\n\t\"./FENDataDecorators/PlayForMate.ts\": \"./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/PlayForMate.ts\",\n\t\"./FENDataDecorators/PointsForMate.ts\": \"./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/PointsForMate.ts\",\n\t\"./FENDataDecorators/StalemateOptions.ts\": \"./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/StalemateOptions.ts\",\n\t\"./FENDataDecorators/Takeover.ts\": \"./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/Takeover.ts\",\n\t\"./FENDataDecorators/ThreefoldRepetition.ts\": \"./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/ThreefoldRepetition.ts\",\n\t\"./PieceControlDecorators/AnyCapture.ts\": \"./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/PieceControlDecorators/AnyCapture.ts\",\n\t\"./PieceControlDecorators/PromoteTo.ts\": \"./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/PieceControlDecorators/PromoteTo.ts\",\n\t\"./PieceControlDecorators/PromotionRank.ts\": \"./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/PieceControlDecorators/PromotionRank.ts\",\n\t\"./PieceControlDecorators/RoyalsCannotCapture.ts\": \"./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/PieceControlDecorators/RoyalsCannotCapture.ts\",\n\t\"./PieceControlDecorators/Sideways.ts\": \"./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/PieceControlDecorators/Sideways.ts\",\n\t\"./PieceControlDecorators/Stonewall.ts\": \"./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/PieceControlDecorators/Stonewall.ts\",\n\t\"./PieceControlDecorators/Torpedo.ts\": \"./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/PieceControlDecorators/Torpedo.ts\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions sync recursive \\\\.ts$\";","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","// This function allow to reference async chunks\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".react-app.js\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) scriptUrl = scripts[scripts.length - 1].src\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","__webpack_require__.b = self.location + \"\";\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t\"src_main_client_javascript_logic_movegen_VariantRules_VariantRuleInterface_ts\": 1\n};\n\n// no chunk install function needed\n// no chunk loading\n\n// no HMR\n\n// no HMR manifest","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/main/client/javascript/logic/movegen/VariantRules/VariantRuleDefinitions/BoardVariantModules/InsufficientMaterial/PieceMedianCounter.ts\");\n",""],"names":[],"sourceRoot":""}