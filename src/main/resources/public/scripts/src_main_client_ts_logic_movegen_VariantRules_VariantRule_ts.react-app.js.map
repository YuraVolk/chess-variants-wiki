{"version":3,"file":"src_main_client_ts_logic_movegen_VariantRules_VariantRule_ts.react-app.js","mappings":";;;;;;;;;;;;;;;;;;;;AAAO;AACA,kDAAkD,QAAQ;AAC1D,8DAA8D,QAAQ;AACtE;AACA;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrB6D;AAC7D,wCAAwC,EAAE,EAAE,IAAI;AACzC;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,uFAAuF,MAAM;AAC7F;AACO,uCAAuC,gBAAgB;AACvD;AACA;AACP,gCAAgC,2DAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO,uCAAuC,UAAU,GAAG,iBAAiB,IAAI,gBAAgB;AACzF;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,wDAAY;AAC3B;AACA;AACO;AACP;AACA;;;;;;;;;;;;;;;;;;;;;AChGuD;AACa;AAC7D,8CAA8C,mEAAuB,OAAO,mEAAuB,YAAY,6EAAc,GAAG,6EAAc;AAC9I;AACA;AACP;AACA;AACA,kDAAkD,IAAI;AACtD;AACA;AACO;AACP;AACA;AACA,kDAAkD,IAAI;AACtD;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACf8F;AAChC;AACR;AACoD;AAC7D;AACsC;AACR;AACsD;AACvD;AACc;AACO;AACvB;AACkB;AAC0E;AAC3G;AACU;AACnE,oGAA4B;AACrB,oBAAoB,uDAAW,QAAQ,mEAAY;AACnD;AACP;AACA;AACA;AACA,0BAA0B,mEAAuB,CAAC,2EAA6B,EAAE,mEAAY;AAC7F;AACA,qBAAqB,kFAAgC;AACrD;AACA,eAAe,wEAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,6EAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qFAAyB,YAAY,qDAAO;AAChE;AACA,4BAA4B,qFAAoB;AAChD;AACA;AACA,qBAAqB,kEAAc;AACnC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB,EAAE;AACnB;AACA;AACA;AACA;AACA,4BAA4B,kFAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uEAAsB;AACrC;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wEAAS;AACpC,0DAA0D;AAC1D,sDAAsD;AACtD,2CAA2C,mEAAuB,CAAC,2EAA6B,EAAE,mEAAY;AAC9G;AACA,uBAAuB,qFAAyB,sBAAsB,iFAAgB;AACtF;AACA,4BAA4B,qFAAyB,oBAAoB,qDAAO,EAAE,iFAAgB;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,IAAI,qEAAc,EAAE;AAC5C,4BAA4B,IAAI,qEAAc,EAAE;AAChD;AACA;AACA;AACA;AACA,8BAA8B,kFAAc;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uDAAW,QAAQ,mEAAY;AAC1D,2BAA2B,uDAAW,QAAQ,mEAAY;AAC1D;AACA;AACA,4BAA4B,6DAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC,4BAA4B,QAAQ;AACpC;AACA,wCAAwC,4FAA0B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,mEAAuB,WAAW,mEAAY;AACnF;AACA;AACA,oCAAoC,6DAAM;AAC1C;AACA;AACA;AACA,iCAAiC,oEAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kFAAqB,GAAG,sBAAsB;AAChE;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA,4CAA4C,MAAM,6FAAoC,EAAE;AACxF;AACA;AACA,4CAA4C,MAAM,wFAA+B,EAAE;AACnF;AACA;AACA;AACA;AACA;AACA,mCAAmC,mEAAuB,CAAC,2EAA6B,EAAE,mEAAY;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,4FAA0B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,eAAe;AAChD,4CAA4C,6DAAM;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,6DAAM;AAClD;AACA;AACA;AACA,yCAAyC,kBAAkB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,4FAA0B;AAC1F;AACA,4CAA4C,6DAAM;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA,6CAA6C,oEAAkB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,qEAAmB;AAC1E;AACA,yEAAyE,2FAAmB,YAAY,wFAAsB;AAC9H,wEAAwE,2FAAmB,YAAY,yFAAqB;AAC5H,SAAS;AACT;AACA,uBAAuB;AACvB;AACA;AACA,gBAAgB,yEAAyE;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iCAAiC,OAAO,mFAAe,oCAAoC;AAC3F,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,6DAAM;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,oEAAkB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,oEAAkB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,qFAA4B;AAC7D,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iCAAiC,sFAA6B;AAC9D,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,gBAAgB,+BAA+B;AAC/C;AACA,YAAY,4FAA0B;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oEAAkB;AAC9C;AACA;AACA;AACA;AACA,iDAAiD,8EAAqB;AACtE;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,qEAAmB;AAC3G,YAAY,8DAAkB;AAC9B,wDAAwD,iDAAiD;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F,2FAAmB;AAC7G;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,8FAAqC;AACnE;AACA,yBAAyB,MAAM,qFAA4B,EAAE;AAC7D;AACA;AACA;AACA;AACA,8BAA8B,uFAA8B;AAC5D;AACA;AACA,8BAA8B,qFAA4B,EAAE,sFAA6B;AACzF;AACA,2CAA2C,MAAM;AACjD;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACxiB8E;AAChB;AACU;AACI;AACrE;AACP;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AAC3C;AACO,+CAA+C,cAAc,GAAG,cAAc;AAC9E;AACP;AACA,QAAQ,2DAAe;AACvB;AACA;AACA;AACA,8DAA8D,WAAW;AACzE;AACO;AACP,UAAU,sEAAe;AACzB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,mBAAmB,mEAAuB,wBAAwB,mEAAY;AAC9E;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,6BAA6B,sEAAe,kBAAkB,uEAAgB;AAC9E,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,wFAAkB;AACjC;AACA,CAAC;AACM;AACP;AACA;AACA,CAAC;AACM;AACP;AACA,uBAAuB,uEAAsB;AAC7C,uBAAuB,uEAAsB;AAC7C;AACA;AACA;AACA,yBAAyB,uEAAsB;AAC/C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACO;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/EoD;AACmE;AACiB;AAChF;AACgF;AAC9B;AACjB;AACnC;AACkC;AAC1C;AAC4B;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,8DAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAmB;AAC/B;AACA;AACA,YAAY,oEAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAA8E;AAC9F;AACA;AACA;AACA;AACA,2CAA2C,oFAAgB;AAC3D;AACA,gBAAgB,yEAAkB;AAClC,+CAA+C,oFAAgB;AAC/D;AACA,sBAAsB,yEAAkB;AACxC,iEAAiE,oFAAgB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qFAA4B;AACjD,yCAAyC,oEAAmB;AAC5D;AACA;AACA;AACA;AACA,2EAA2E,oFAAgB;AAC3F;AACA;AACA,qBAAqB,sFAA6B;AAClD,yCAAyC,oEAAmB;AAC5D;AACA;AACA;AACA;AACA,6EAA6E,oFAAgB;AAC7F;AACA;AACA;AACA,wDAAwD,oEAAW;AACnE,wEAAwE,aAAa;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,4BAA4B,6DAAM;AAClC;AACA;AACA;AACA,gBAAgB,yEAAkB;AAClC;AACA;AACA;AACA;AACA,qBAAqB,yEAAkB;AACvC;AACA;AACA;AACA,qBAAqB,yEAAkB;AACvC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,4BAA4B,6DAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iFAAsB;AACjD;AACA,iBAAiB,qFAA4B;AAC7C,mCAAmC,YAAY;AAC/C;AACA,iBAAiB,sFAA6B;AAC9C,mCAAmC,YAAY;AAC/C;AACA,iBAAiB,uFAA8B;AAC/C,mCAAmC,YAAY;AAC/C;AACA;AACA,gBAAgB,wDAAY;AAC5B;AACA;AACA;AACA;AACA,2BAA2B,uDAAW,QAAQ,mEAAY;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,iBAAiB,wFAA+B;AAChD;AACA;AACA;AACA,iBAAiB,qFAA4B;AAC7C,iBAAiB,sFAA6B;AAC9C;AACA;AACA;AACA;AACA,iBAAiB,uFAA8B;AAC/C;AACA,uDAAuD,GAAG,iFAA8B,6CAA6C;AACrI;AACA,+DAA+D,mEAAY;AAC3E;AACA;AACA;AACA,gDAAgD,mEAAY;AAC5D;AACA,wBAAwB,wFAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,8FAAqC;AACtD;AACA;AACA,iBAAiB,mFAA0B;AAC3C;AACA,iBAAiB,6FAAoC;AACrD,+CAA+C,wBAAwB;AACvE;AACA;AACA;AACA;AACA;AACA,gBAAgB,wDAAY;AAC5B;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,wFAAsB;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,iFAA8B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,yEAAkB;AAC1E;AACA;AACA,uCAAuC,0GAA0B;AACjE;AACA;AACA,gBAAgB,2FAAmB,CAAC,kFAAc;AAClD;AACA;AACA;AACA,6BAA6B,uDAAW,QAAQ,mEAAY;AAC5D,4BAA4B,6DAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,uDAAW,QAAQ,mEAAY;AAC3G,4BAA4B,6DAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iFAA8B;AACjE;AACA;AACA;AACA,YAAY,+EAAkB;AAC9B;AACA;AACA,iBAAiB,+EAAkB;AACnC;AACA;AACA,iBAAiB,+EAAkB;AACnC;AACA;AACA;AACA;AACA,gBAAgB,iCAAiC;AACjD,wBAAwB,uDAAW,QAAQ,mEAAY,WAAW,uDAAW,QAAQ,mEAAY,eAAe,uDAAW,QAAQ,mEAAY;AAC/I,UAAU;AACV;AACA,4BAA4B,IAAI,mEAAY,EAAE;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,uDAAW,IAAI,mEAAY;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,6DAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,6DAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF,mEAAY;AACrG;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,wBAAwB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,+FAAyB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6DAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2EAAwB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,mEAAY;AACzD,UAAU;AACV,YAAY,wFAAkB;AAC9B;AACA;AACA;AACA,yDAAyD,WAAW;AACpE;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0GAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,yEAAkB;AACpD;AACA;AACA;AACA;AACA,8CAA8C,0GAA0B;AACxE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,6DAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,6DAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,iFAAsB,4BAA4B;AAC7F;AACA;AACA;AACA,gBAAgB,mFAAwB;AACxC,mCAAmC,iCAAiC;AACpE;AACA,qBAAqB,mFAAwB;AAC7C,mCAAmC,iCAAiC;AACpE;AACA;AACA,gBAAgB,wDAAY;AAC5B;AACA;AACA;AACA,+BAA+B,kCAAkC,IAAI,wBAAwB;AAC7F;AACA;AACA;AAC+B;;;;;;;;;;;;;;;;;;;;AC7gB0D;AAC9B;AACpD;AACP;AACA,CAAC;AACM;AACP;AACA,CAAC;AACM;AACP;AACA;AACA,qCAAqC,mEAAY;AACjD,MAAM;AACN,QAAQ,uGAAkB;AAC1B;AACA;AACA;AACA,qDAAqD,WAAW;AAChE;;;;;;;;;;;;;;;;;;;;;;AClBmF;AAC+C;AACoB;AACvG;AACe;AACiC;AACxF;AACP,WAAW,8EAAoB;AAC/B,2BAA2B,6EAAuB,UAAU,qFAAqF,GAAG,mEAAY;AAChK,4BAA4B,6EAAuB,UAAU,qFAAqF,GAAG,mEAAY;AACjK;AACA;AACA,0BAA0B,sFAA4B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6DAAS;AACpC;AACA,0BAA0B,8EAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,8FAA6B;AAC9F,uEAAuE,8FAA6B;AACpG;AACA;AACA;AACA,wBAAwB,8BAA8B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8BAA8B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,4FAA2B;AACjE;AACA;AACA,gCAAgC,oFAAmB;AACnD,gCAAgC,oFAAmB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,4FAA2B;AACvF,QAAQ,wEAAkB;AAC1B,QAAQ,wEAAkB;AAC1B,4BAA4B,oFAAmB;AAC/C,4BAA4B,oFAAmB;AAC/C;AACA;AACA,+CAA+C;AAC/C,gDAAgD;AAChD,oDAAoD;AACpD,qDAAqD;AACrD,6CAA6C;AAC7C,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,wJAAiB,uEAAuE,2JAAoB;AACtI,QAAQ,wEAAkB;AAC1B;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpM6F;AACjC;AAC4B;AACuB;AAChC;AACK;AACP;AAC4E;AAC3E;AACuB;AACrG;AACA,mCAAmC,qEAAe,QAAQ,mEAAY;AACtE;AACO;AACP,YAAY,8BAA8B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,iBAAiB,0EAAa;AAC9B,2BAA2B,IAAI,KAAK,qBAAqB;AACzD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,mEAAmE,qEAAc;AACjF,KAAK;AACL;AACA,kFAAkF,WAAW;AAC7F,KAAK;AACL;AACA;AACA;AACA,CAAC;AACM;AACP,WAAW,iEAAW,OAAO,mEAAY;AACzC;AACA;AACA,kCAAkC,4FAAyB;AAC3D;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,mCAAmC;AACnC,oBAAoB,kFAAuB,SAAS,GAAG,kFAAuB,SAAS,qBAAqB;AAC5G;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA,8EAA8E,WAAW;AACzF,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACO;AACP;AACA;AACA,4CAA4C,wFAAkB;AAC9D,KAAK;AACL;AACA,4EAA4E,WAAW;AACvF,KAAK;AACL;AACA;AACA;AACA,CAAC;AACM;AACP,YAAY,8BAA8B;AAC1C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,iEAAiE,IAAI,IAAI,mBAAmB;AAC5F,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,uCAAuC,qEAAe;AACtD;AACA;AACA;AACA,aAAa;AACb,KAAK;AACL;AACA,YAAY,0EAAa;AACzB;AACA,yBAAyB,qBAAqB;AAC9C,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD,uBAAuB,iEAAW,CAAC,uJAAgB,EAAE,mEAAY;AAC1D;AACP;AACA;AACA,oCAAoC,qEAAe,QAAQ,mEAAY;AACvE;AACA;AACA,gCAAgC,6DAAM;AACtC;AACA,oBAAoB,2JAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,YAAY,0EAAa;AACzB;AACA,gCAAgC;AAChC,gEAAgE,EAAE,cAAc;AAChF,KAAK;AACL;AACA;AACA;AACA,CAAC;AACM;AACP,WAAW,iEAAW,OAAO,mEAAY;AACzC;AACA;AACA,kCAAkC,wFAAqB;AACvD;AACA;AACA;AACA,KAAK;AACL;AACA,2BAA2B,4BAA4B,kFAAuB,IAAI,qBAAqB;AACvG,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACM;AACP,WAAW,iEAAW,OAAO,mEAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,+BAA+B,mDAAmD;AAClF;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACM;AACP,WAAW,6EAAuB,gBAAgB,mEAAY;AAC9D;AACA;AACA;AACA,gCAAgC,6DAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sFAAiB;AACzC,gDAAgD,6FAAqB;AACrE;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,YAAY,GAAG,MAAM;AACtE;AACA;AACA,2BAA2B,2BAA2B;AACtD,aAAa,YAAY;AACzB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,wFAAqB;AAC1D;AACA,yEAAyE,sFAAiB;AAC1F;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,yCAAyC,kFAAuB,aAAa,KAAK,MAAM;AACxF;AACA,gCAAgC,EAAE,+BAA+B;AACjE,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,qCAAqC,qBAAqB;AAC1D;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACM;AACP,WAAW,6EAAuB,kBAAkB,mEAAY;AAChE;AACA,6BAA6B,6EAAuB,kBAAkB,mEAAY;AAClF,qCAAqC,qEAAe,QAAQ,mEAAY,KAAK,qEAAe,QAAQ,mEAAY;AAChH;AACA,gCAAgC,6DAAM;AACtC;AACA;AACA;AACA;AACA,yBAAyB,8GAAiC;AAC1D;AACA,uCAAuC,wFAAqB;AAC5D;AACA,gDAAgD,0EAAmB;AACnE;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,mCAAmC;AACnC,uBAAuB,kCAAkC,kFAAuB,CAAC,4EAAqB,SAAS,cAAc;AAC7H,SAAS,YAAY;AACrB,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;;;;;AC7WkD;AACW;AAC2P;AAClT;AACP;AACO;AACP;AACA,cAAc,sEAAqB,GAAG,2BAA2B,iEAAW,QAAQ,mEAAY,oBAAoB;AACpH,kBAAkB,sEAAqB,GAAG,+BAA+B,iEAAW,QAAQ,mEAAY,oBAAoB;AAC5H,sBAAsB,sEAAqB;AAC3C,mBAAmB,mEAAkB;AACrC,mBAAmB,mEAAkB;AACrC,YAAY,iEAAgB,GAAG,gDAAgD;AAC/E,aAAa,mEAAkB;AAC/B,mBAAmB,iEAAgB,GAAG,uDAAuD;AAC7F,wBAAwB,sEAAqB,GAAG,qCAAqC,iEAAW,OAAO,mEAAY,oBAAoB;AACvI,yBAAyB,sEAAqB,GAAG,sCAAsC,iEAAW,OAAO,mEAAY,oBAAoB;AACzI,oBAAoB,oEAAmB;AACvC,oBAAoB,iEAAgB;AACpC,sBAAsB,sEAAqB,GAAG,mCAAmC,iEAAW,QAAQ,mEAAY,oBAAoB;AACpI,eAAe,+DAAc;AAC7B,eAAe,+DAAc;AAC7B,cAAc,8DAAa;AAC3B,sBAAsB,sEAAqB;AAC3C,qBAAqB,qEAAoB;AACzC,uBAAuB,sEAAqB,GAAG,oCAAoC,iEAAW,OAAO,mEAAY,oBAAoB;AACrI,uBAAuB,uEAAsB;AAC7C,yBAAyB,sEAAqB,GAAG,sCAAsC,iEAAW,QAAQ,mEAAY,oBAAoB;AAC1I;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3CoD;AACA;AAC7C;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,8CAA8C,2BAA2B,UAAU,0BAA0B;AAC7G;AACA;AACA,gCAAgC,kEAAc,gCAAgC;AAC9E;AACA;AACA,6BAA6B,kEAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,+BAA+B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,kBAAkB,wCAAwC,EAAE,+BAA+B;AAC3F;AACA;AACA;AACA,kBAAkB,sDAAsD,EAAE,6CAA6C;AACvH;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kEAAY;AAC/B;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kEAAY;AAC/B;AACA;AACO;AACP;AACA,CAAC;AACM;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AACpC;AACP;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AAC5B;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC9JA;AACA;AACP;AACA;AACO;AACP;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACnBkJ;AACzF;AAClD;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,uDAAe;AACpF;AACA,eAAe;AACf,gBAAgB;AAChB,eAAe;AACf,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,QAAQ,qGAAiB;AACzB;AACA;AACA;AACA;AACO;AACP,wCAAwC,iDAAS;AACjD,8BAA8B,qGAAiB;AAC/C;AACA;AACA;AACA;AACA;AACA,aAAa,qGAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,iDAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,2FAAW;AAC3D;AACA;AACO;AACP,4DAA4D,+FAAe;AAC3E;AACA;AACO;AACP,iDAAiD,+FAAe;AAChE;AACA;AACO;AACP,4DAA4D,0FAAU;AACtE;AACA;AACO;;;;;;;;;;;;;;;;;;;;;;;;;ACzF6C;AACM;AACC;AACK;AACoC;AACT;AACmB;AAC9G;AACA;AACA,aAAa,4EAA4B;AACzC;AACA,aAAa,6EAA6B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,yFAAqB;AAC/D;AACA;AACA,YAAY,gCAAgC,iBAAiB,OAAO,yBAAyB,kBAAkB,cAAc;AAC7H,YAAY,eAAe;AAC3B,6BAA6B,yFAAqB;AAClD;AACA;AACA,iCAAiC,4EAAqB;AACtD;AACA;AACA;AACA;AACA,gCAAgC,gEAAa;AAC7C;AACA;AACA;AACA,kBAAkB,kFAAc;AAChC;AACA,kDAAkD,oEAAmB;AACrE;AACA,mDAAmD,oEAAmB;AACtE;AACA;AACA;AACA;AACA,gCAAgC,wBAAwB;AACxD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,YAAY,sEAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,mCAAmC,uFAA4B;AAC/D;AACA;AACA,mCAAmC,uFAA4B;AAC/D;AACA;AACA,mCAAmC,kFAAuB;AAC1D;AACA;AACA;AACA;AACA;AACA,+BAA+B,kFAAuB;AACtD;AACA;AACA,iBAAiB,sEAAkB;AACnC,mCAAmC,iBAAiB;AACpD,kCAAkC,kFAAuB,iCAAiC;AAC1F;AACA,iBAAiB,sEAAkB;AACnC;AACA;AACA;AACA,YAAY,kEAAY;AACxB;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,YAAY,sEAAkB;AAC9B;AACA;AACA;AACA,+BAA+B,kFAAuB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kFAAuB;AACtD;AACA;AACA,iBAAiB,sEAAkB;AACnC,mCAAmC,iBAAiB;AACpD,mCAAmC,kFAAuB,sBAAsB;AAChF;AACA,iBAAiB,sEAAkB;AACnC;AACA;AACA;AACA,YAAY,kEAAY;AACxB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC7H+F;AACtC;AACQ;AACuB;AACtB;AAC3D;AACP;AACA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,gEAAY;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yCAAyC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,gEAAa;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gCAAgC;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,0DAA0D,gEAAa;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0EAAsB;AACzC,SAAS;AACT;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,uBAAuB,qDAAqD;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA,qDAAqD,8BAA8B;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iBAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kEAAY;AACpC,0DAA0D,kEAAY;AACtE;AACA,+CAA+C,kEAAY;AAC3D;AACA,SAAS;AACT;AACA,oBAAoB,gCAAgC;AACpD,kDAAkD,sEAAkB;AACpE;AACA;AACA,kBAAkB,kGAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gEAAa;AAChC;AACA;AACA;AACA,0DAA0D,QAAQ;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F,gEAAa;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,4EAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpR6D;AAC2B;AACjF;AACP;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AAC5B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sDAAsD;AAChD;AACA;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,yEAAkB;AACjC,eAAe,yEAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yEAAkB;AACjC,eAAe,mGAA+B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,sBAAsB;AACrF;AACO;AACP;AACA,uCAAuC,mFAAe;AACtD;AACA;AACA;AACA;AACO,8DAA8D;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACA;AACA;AACA;AACA;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACxG0E;AACA;AACrB;AAC9C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sBAAsB,uEAAmB,mBAAmB,8EAA0B;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,gFAAgF,qEAAiB;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,sDAAsD;AAChG,gCAAgC,wFAAwF;AACxH;AACA,4BAA4B,8EAA0B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oIAAoI,qEAAiB;AACrJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,kFAAkF;AAC7H;AACA;AACA;AACA,sDAAsD,sDAAsD;AAC5G,4BAA4B,wFAAwF;AACpH;AACA;AACA;AACA,gBAAgB,6CAA6C;AAC7D,0BAA0B,oFAAc,kBAAkB,oFAAc;AACxE;AACA;AACA,gDAAgD,kFAAc,gDAAgD,qEAAiB;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,qEAAiB;AAClE;AACA;AACA;AACA;AACA,6BAA6B,qEAAiB;AAC9C;AACA;AACA;AACA;AACA,6BAA6B,yEAAqB;AAClD;AACA;AACA;AACA;AACA,6BAA6B,uEAAmB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,uBAAuB,qEAAiB,kCAAkC;AACxJ;AACA;AACA;AACA;AACA;AACA,8CAA8C,gCAAgC;AAC9E,oCAAoC,sBAAsB;AAC1D;AACA,aAAa;AACb;AACA;AACA;AACA,mEAAmE,iBAAiB;AACpF,gEAAgE,iBAAiB;AACjF;AACA;AACA;AACA,4DAA4D,0BAA0B,uEAAmB,EAAE;AAC3G;AACA;AACA;AACA;AACA;AACA,yCAAyC,iCAAiC;AAC1E;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AC7MmD;AACqB;AACV;AACc;AACJ;AACJ;AACtB;AACuB;AAC9D;AACP;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uEAAsB,OAAO,oFAAgB;AAChE,0BAA0B,iEAAW,QAAQ,kFAAY;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,oBAAoB;AACpB,0BAA0B;AAC1B,6BAA6B;AAC7B;AACA,4BAA4B,8EAA0B;AACtD;AACA;AACA;AACA;AACA,iCAAiC,oFAAyB,UAAU,uDAAY,EAAE,gFAAgB;AAClG;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACzD8C;AACuF;AACrI;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,mBAAmB,sEAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,2BAA2B,kFAA8B;AACzD;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,mBAAmB,wEAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,2BAA2B,oFAAgC;AAC3D;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,mBAAmB,sEAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,2BAA2B,kFAA8B;AACzD;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,mBAAmB,uEAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,2BAA2B,mFAA+B;AAC1D;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,mBAAmB,wEAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,2BAA2B,oFAAgC;AAC3D;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,iCAAiC,yEAAqB,EAAE;AAClG,0CAA0C,gCAAgC,yEAAqB,EAAE;AACjG;AACA;AACA,6BAA6B,uEAAmB;AAChD;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,0CAA0C,iCAAiC,uEAAmB,EAAE;AAChG,0CAA0C,gCAAgC,uEAAmB,EAAE;AAC/F;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,mBAAmB,mEAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,2BAA2B,+EAA2B;AACtD;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uEAAmB;AAChD;AACA;AACA,iBAAiB;AACjB;AACA;AACA,6BAA6B,uEAAmB;AAChD;AACA;AACA,iBAAiB;AACjB,0CAA0C,iCAAiC,yEAAqB,EAAE;AAClG;AACA;AACA;AACA,0CAA0C,iCAAiC,uEAAmB,EAAE;AAChG;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,gCAAgC,8EAAsB;AACtD,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uEAAmB;AAChD;AACA;AACA,iBAAiB;AACjB;AACA;AACA,6BAA6B,uEAAmB;AAChD;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,0CAA0C,iCAAiC,uEAAmB,EAAE;AAChG,0CAA0C,gCAAgC,uEAAmB,EAAE;AAC/F;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,2BAA2B,8EAAsB;AACjD,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uEAAmB;AAChD;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,0CAA0C,gCAAgC,uEAAmB,EAAE;AAC/F;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,gCAAgC,8EAAsB;AACtD,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA;AACA,0CAA0C,iCAAiC,qEAAiB,0BAA0B;AACtH,0CAA0C,gCAAgC,qEAAiB,0BAA0B;AACrH,0CAA0C,gCAAgC,qEAAiB,0BAA0B;AACrH,0CAA0C,+BAA+B,qEAAiB,0BAA0B;AACpH,0CAA0C,gCAAgC,qEAAiB,0BAA0B;AACrH,0CAA0C,+BAA+B,qEAAiB,0BAA0B;AACpH,0CAA0C,iCAAiC,qEAAiB,0BAA0B;AACtH,0CAA0C,gCAAgC,qEAAiB,0BAA0B;AACrH;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,6BAA6B,cAAc,IAAI;AACtG;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,8EAAsB;AAC1B,oCAAoC,uDAAY;AAChD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,mBAAmB,0EAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,2BAA2B,sFAAkC;AAC7D;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;;;;AC//B2E;AACpE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC,wCAAwC,mFAAiB;AAClD;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,CAAC,KAAK;AACC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA,oDAAoD,wFAAsB;AAC1E;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACA,+CAA+C,wFAAsB;;;;;;;;;;;;;;;;;;;ACtDnB;AACU;AACnE;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,8DAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,8DAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA,yEAAyE;AAClE;AACP;AACA;AACA,gCAAgC,uEAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,oBAAoB,8DAAkB;AACtC;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAS,CAAC,mHAA0D;;;;;;;;;;;;;;;;;;;;AC3GvB;AAC+B;AAC5B;AACe;AAC/D;AACO,2BAA2B,qDAAW;AAC7C;AACA,QAAQ,qEAA2B;AACnC;AACA,yBAAyB,OAAO,+CAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0EAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA,gFAAgF,MAAM,mFAA0B,EAAE;AAClH;AACA;AACA;AACA;AACA;AACA,oCAAoC,sFAA4C;AAChF;AACA;;;;;;;;;;;;;;;;;;;;ACxCuE;AAC1B;AACG;AACe;AAC/D;AACO,+BAA+B,qDAAW;AACjD;AACA,QAAQ,qEAA2B;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO,+CAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,SAAS,MAAM,QAAQ;AAChD,mDAAmD,SAAS,sBAAsB,QAAQ;AAC1F;AACA,uBAAuB,+EAA4B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC;AACA,iBAAiB,UAAU;AAC3B,4BAA4B,uFAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AChE6C;AACuB;AACQ;AAC5B;AACe;AAC/D;AACO,4BAA4B,qDAAW;AAC9C;AACA,QAAQ,qEAA2B;AACnC;AACA,yBAAyB,OAAO,+CAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0EAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ,YAAY,+BAA+B;AACnE;AACA;AACA;AACA,sFAAsF,0EAAmB;AACzG;AACA,6BAA6B,mBAAmB;AAChD;AACA;AACA;AACA;AACA,kDAAkD,MAAM,qFAA4B,EAAE;AACtF;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACjD6C;AACmB;AAChB;AACe;AAC/D;AACO,wBAAwB,qDAAW;AAC1C;AACA,QAAQ,qEAA2B;AACnC;AACA,yBAAyB,OAAO,+CAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2EAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,8EAA2B;AACzD;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;;AC1C6C;AACG;AACe;AAC/D;AACO,6BAA6B,qDAAW;AAC/C;AACA,QAAQ,qEAA2B;AACnC;AACA,yBAAyB,OAAO,+CAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0EAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACpCmG;AACtD;AAC8B;AAC3B;AACe;AAC/D;AACO,uBAAuB,qDAAW;AACzC;AACA,QAAQ,qEAA2B;AACnC;AACA,6CAA6C,WAAW;AACxD,wBAAwB,WAAW;AACnC;AACA;AACA,wBAAwB,OAAO;AAC/B,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,IAAI;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO,+CAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qFAAkC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,IAAI,qEAAc,iCAAiC;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4FAA2B;AAC3C,oBAAoB,4FAA2B;AAC/C;AACA;AACA;AACA;AACA;AACA,4BAA4B,4FAA2B;AACvD;AACA,mDAAmD,8BAA8B;AACjF;AACA;AACA;AACA;AACA;AACA,8BAA8B,4FAA2B;AACzD;AACA,4FAA4F,qEAAc;AAC1G;AACA;AACA,qCAAqC,oFAAmB,+BAA+B,oFAAmB;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6DAAM;AAClC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACzN6C;AACsB;AACnB;AACe;AACiC;AAC7B;AACG;AACtE;AACO,yBAAyB,qDAAW;AAC3C;AACA,QAAQ,qEAA2B;AACnC;AACA,6BAA6B,2EAAa;AAC1C,yBAAyB,OAAO,+CAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,8EAA2B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0GAA0B;AACjD;AACA,qBAAqB,oFAAmB;AACxC;AACA;AACA,wBAAwB,IAAI,qEAAc,EAAE;AAC5C;AACA;AACA;AACA,4BAA4B,IAAI,qEAAc,EAAE;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,+BAA+B;AACzE;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC3E6C;AAC+B;AAC5B;AACe;AACb;AAC+B;AACd;AACc;AACjF;AACO,wBAAwB,qDAAW;AAC1C;AACA,QAAQ,qEAA2B;AACnC;AACA,6BAA6B,2DAAc;AAC3C,yBAAyB,OAAO,+CAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,8EAA2B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA,4BAA4B,kFAAqB;AACjD;AACA,wBAAwB,IAAI,qEAAc,EAAE;AAC5C,4BAA4B,IAAI,qEAAc,EAAE;AAChD;AACA,kEAAkE,wFAAsB;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,OAAO,mFAAe,+BAA+B;AACjG;AACA,wCAAwC,OAAO,mFAAe,0BAA0B;AACxF;AACA;AACA;AACA;AACA,4CAA4C,qDAAqD;AACjG;AACA,wCAAwC,gDAAgD;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACxEoE;AACvB;AAC0C;AACvC;AACe;AACb;AAClD;AACO,uBAAuB,qDAAW;AACzC;AACA,QAAQ,qEAA2B;AACnC;AACA,6BAA6B,2DAAc;AAC3C,yBAAyB,OAAO,+CAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+EAA4B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA,mCAAmC,uEAAsB;AACzD;AACA;AACA,uCAAuC,4EAAqB;AAC5D;AACA,yBAAyB,OAAO;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yEAAsB;AACpD;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;;;ACzD6C;AACuB;AACpB;AACe;AAC/D;AACO,4BAA4B,qDAAW;AAC9C;AACA,QAAQ,qEAA2B;AACnC;AACA,yBAAyB,OAAO,+CAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+EAA4B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ,YAAY,+BAA+B;AACnE;AACA;AACA,6EAA6E,0EAAmB;AAChG;AACA,6BAA6B,mBAAmB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACrD+D;AAClB;AACiC;AACI;AAClC;AACe;AAC/D;AACO,wBAAwB,qDAAW;AAC1C;AACA,QAAQ,qEAA2B;AACnC;AACA,yBAAyB,OAAO,+CAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,6EAA0B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,IAAI,mEAAY,EAAE;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,4BAA4B,qDAAW;AAC9C;AACA,QAAQ,qEAA2B;AACnC;AACA,yBAAyB,OAAO,+CAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,6EAA0B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+DAAY;AACpB;AACA;AACA;AACA;AACA;AACO,0BAA0B,qDAAW;AAC5C;AACA,QAAQ,qEAA2B;AACnC;AACA,yBAAyB,OAAO,+CAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,6EAA0B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mBAAmB;AACpC,4BAA4B,wEAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wFAAkB;AAC9B;AACA;AACA;AACA,YAAY,wFAAkB;AAC9B;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACpH6C;AACmB;AAChB;AACe;AAC/D;AACO,yBAAyB,qDAAW;AAC3C;AACA,QAAQ,qEAA2B;AACnC;AACA,yBAAyB,OAAO,+CAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2EAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,0EAAuB;AAClF;AACA;;;;;;;;;;;;;;;;;;;ACnC6C;AACG;AACe;AAC/D;AACO,8BAA8B,qDAAW;AAChD;AACA,QAAQ,qEAA2B;AACnC;AACA,6CAA6C,YAAY;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qFAAkC;AACzD;AACA;AACA;AACA;AACA,yBAAyB,OAAO,+CAAK;AACrC;AACA,8DAA8D,IAAI;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gBAAgB;AAClD;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACrH6C;AACmB;AAChB;AACe;AAC/D;AACO,+BAA+B,qDAAW;AACjD;AACA,QAAQ,qEAA2B;AACnC;AACA,yBAAyB,OAAO,+CAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2EAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mFAAgC;AAC9D;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;;;;;AC1C6C;AACuB;AACT;AACkC;AAC7C;AACe;AAC/D;AACO,4BAA4B,qDAAW;AAC9C;AACA,QAAQ,qEAA2B;AACnC;AACA,yBAAyB,OAAO,+CAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,8EAA2B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA,4BAA4B,6DAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA,YAAY,+EAAkB;AAC9B,6CAA6C,0EAAmB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA,sCAAsC,0EAAmB;AACzD;AACA;AACA;AACA;AACA;AACA,iCAAiC,yCAAyC;AAC1E;AACA,iCAAiC,+EAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACjF6C;AAC2C;AACxC;AACe;AAC/D;AACO,wBAAwB,qDAAW;AAC1C;AACA,QAAQ,qEAA2B;AACnC;AACA,yBAAyB,OAAO,+CAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0EAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA,gBAAgB,QAAQ,wBAAwB,wBAAwB;AACxE;AACA;AACA;AACA;AACA;AACA,oBAAoB,yEAAkB;AACtC,wCAAwC,0EAAmB;AAC3D;AACA;AACA;AACA;AACA,wBAAwB,yEAAkB;AAC1C,4CAA4C,0EAAmB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACtDgG;AAC7B;AACtB;AAC8B;AACqB;AAChD;AACe;AAC/D;AACO,yBAAyB,qDAAW;AAC3C;AACA,QAAQ,qEAA2B;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO,+CAAK;AACrC;AACA;AACA;AACA;AACA,+BAA+B,iBAAiB;AAChD,uCAAuC,kBAAkB;AACzD;AACA,uBAAuB,2EAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6DAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mEAAuB,cAAc,qEAAc;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0GAA0B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,mCAAmC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,+EAAkB;AACzE;AACA,+BAA+B,0GAA0B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,6DAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uEAA6B,oBAAoB,MAAM,mFAA0B,EAAE;AAC/F;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACzK6C;AACc;AACX;AACe;AAC/D;AACO,oBAAoB,qDAAW;AACtC;AACA,QAAQ,qEAA2B;AACnC;AACA,yBAAyB,OAAO,+CAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+EAA4B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,6DAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AChDmD;AACsB;AACE;AACkC;AACrB;AACgD;AACxC;AAC/B;AACC;AAClE;AACA,yCAAyC,EAAE,GAAG,EAAE,GAAG,YAAY;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uFAAsB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oFAAc;AAC7B;AACA,gBAAgB,oFAAc;AAC9B,cAAc,iEAAW,KAAK,kFAAY;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wCAAwC;AACxD,4BAA4B,4EAAM;AAClC;AACA;AACA;AACA;AACA,yFAAyF,yFAAmB;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oFAAoF;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,2DAAgB;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,uBAAuB,IAAI;AACjF;AACA;AACA;AACA;AACA,gBAAgB,6EAA6E;AAC7F;AACA;AACA;AACA;AACA;AACA,uBAAuB,eAAe,GAAG,eAAe,GAAG,kBAAkB;AAC7E;AACA;AACA;AACA,+BAA+B,0GAA0B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,wGAAqB;AACvD,gCAAgC,4EAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0BAA0B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8CAA8C;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,wGAAqB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iEAAiE;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,yFAAmB;AACvG;AACA;AACA;AACA;AACA,wEAAwE,sFAAgB;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,wGAAqB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,wGAAqB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kDAAkD;AAClE;AACA,gBAAgB,iCAAiC;AACjD;AACA;AACA,4BAA4B,4EAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,4EAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,4EAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wEAAwE;AACxF;AACA,4BAA4B,4EAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,sFAAgB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,gBAAgB,yDAAyD;AACzE;AACA,wBAAwB,4EAAM;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,gBAAgB,kFAAkF;AAClG;AACA;AACA,qBAAqB;AACrB,+BAA+B,uFAAsB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,IAAI,oFAAc,EAAE;AAChD,gCAAgC,IAAI,oFAAc,EAAE;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,YAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,wGAAqB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,OAAO;AACpC,iCAAiC,OAAO;AACxC;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa,8FAAkB;AAC/B;AACA,gBAAgB,qDAAqD;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8DAA8D;AAC9E;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,gBAAgB,0BAA0B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iFAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,oGAA4B,yBAAyB,qGAA6B;AAC5J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,2DAAgB;AACzC;AACA;AACA;AACA;AACA,oBAAoB,8FAAkB;AACtC;AACA,6BAA6B,oGAA4B;AACzD,6BAA6B,qGAA6B;AAC1D;AACA;AACA,6BAA6B,sGAA8B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+EAA4B;AAC/C;AACA;AACA;AACO,0BAA0B,iEAAkB;;;;;;;;;;;;;;;;;;;;;;;;ACpqB8D;AACjB;AAC/B;AACR;AAClD;AACP;AACA;AACA,eAAe,0FAAyC;AACxD;AACA,CAAC;AACM,iCAAiC,iEAAkB;AAC1D,qBAAqB,+DAAoB;AACzC;AACA,gCAAgC,gFAA+B;AAC/D;AACA,gBAAgB,8FAAkB;AAClC;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACM,iCAAiC,iEAAkB;AAC1D,qBAAqB,+DAAoB;AACzC;AACA,gCAAgC,gFAA+B;AAC/D;AACA,iBAAiB,8FAAkB;AACnC;AACA,qCAAqC,6FAAqB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACM,gCAAgC,iEAAkB;AACzD,qBAAqB,8DAAmB;AACxC;AACA,gCAAgC,gFAA+B;AAC/D;AACA,iBAAiB,8FAAkB;AACnC;AACA;AACA,0CAA0C,0GAA0B;AACpE;AACA;AACA;AACA;AACA;AACA,CAAC;AACM,wBAAwB,iEAAkB;AACjD,qBAAqB,4DAAiB;AACtC;AACA,gCAAgC,gFAA+B;AAC/D;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;;;;ACpEgE;AACR;AACqB;AACvB;AAChD,wBAAwB,iEAAkB,CAAC,2FAA4B;AAC9E,qBAAqB,4DAAiB;AACtC;AACA;AACA,mBAAmB,+EAAgC;AACnD;AACA;AACA,mBAAmB,iFAAgC;AACnD;AACA,CAAC;;;;;;;;;;;;;;;;;;;ACbmG;AACnC;AAC1D;AACP;AACA;AACA;AACA;AACA;AACA,aAAa,8FAAkB;AAC/B;AACA;AACA;AACA;AACO,0BAA0B,iEAAkB;AACnD,qBAAqB,2DAAgB;AACrC;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8FAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;;;;;;;AC3C4F;AACG;AAC/B;AACV;AAChD;AACP;AACA;AACA,eAAe,wFAAyC;AACxD;AACA,CAAC;AACM,yBAAyB,iEAAkB;AAClD,qBAAqB,6DAAkB;AACvC;AACA,gCAAgC,8EAA+B;AAC/D;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACM,yBAAyB,iEAAkB;AAClD,qBAAqB,6DAAkB;AACvC;AACA,gCAAgC,8EAA+B;AAC/D;AACA,iBAAiB,8FAAkB;AACnC;AACA,qCAAqC,6FAAqB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACM,wBAAwB,iEAAkB;AACjD,qBAAqB,4DAAiB;AACtC;AACA,gCAAgC,8EAA+B;AAC/D;AACA,iBAAiB,8FAAkB;AACnC;AACA;AACA,0CAA0C,0GAA0B;AACpE;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;;;ACtDM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AAC1B;AACA;AACA;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AClB+F;AAC2D;AAC1D;AACvB;AACjB;AACoC;AACc;AACxB;AACR;AAC1E,0BAA0B,qEAAc,6BAA6B,qEAAc,SAAS,qEAAc;AAC1G,wBAAwB,qEAAc;AACtC;AACO;AACP;AACA,oBAAoB,IAAI,qEAAc,EAAE;AACxC,mBAAmB,sEAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA,oBAAoB,IAAI,qEAAc,EAAE;AACxC,wBAAwB,IAAI,qEAAc,EAAE;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF;AACtF,sCAAsC,kCAAkC,qGAAiB;AACzF,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA,sCAAsC,IAAI,qGAAiB;AAC3D,6BAA6B;AAC7B;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,+EAAY;AACzE;AACA;AACA;AACA,gBAAgB,0GAA0B;AAC1C;AACA;AACA;AACA;AACA;AACA,0CAA0C,kGAAkB;AAC5D,iCAAiC,kGAAkB;AACnD;AACA,KAAK;AACL,wCAAwC,WAAW;AACnD,oBAAoB,2BAA2B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F,oFAAgB;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,YAAY;AACjF;AACA,+BAA+B,uFAAsB,uBAAuB,qEAAc;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA,mCAAmC,yFAAmB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,IAAI,qEAAc,EAAE;AACxC,wBAAwB,IAAI,qEAAc,EAAE;AAC5C;AACA;AACA;AACA;AACA,2CAA2C,+EAAY,8BAA8B,qGAAiB;AACtG,4BAA4B,qEAAc;AAC1C,8CAA8C,qEAAc;AAC5D;AACA;AACA,4BAA4B,6DAAM;AAClC,4BAA4B,IAAI,qEAAc,EAAE;AAChD;AACA;AACA;AACA;AACA,iDAAiD,2FAAmB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,qGAAiB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,uFAAsB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,IAAI,qEAAc,EAAE;AACpD,oCAAoC,IAAI,qEAAc,EAAE;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iEAAW,CAAC,uFAAsB,uBAAuB,qEAAc,qBAAqB,mEAAY;AAC/H,6BAA6B,iEAAW,IAAI,mEAAY;AACxD,yCAAyC,iEAAW,YAAY,mEAAY;AAC5E;AACA;AACA;AACA;AACA;AACA,4CAA4C,YAAY,qBAAqB,YAAY;AACzF,4BAA4B,yBAAyB;AACrD,gCAAgC,4BAA4B;AAC5D;AACA;AACA;AACA;AACA;AACA,iCAAiC,OAAO;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,8BAA8B,6EAAuB,OAAO,iEAAW,IAAI,mEAAY,GAAG,mEAAY;AACtG,oBAAoB,IAAI,mEAAY,EAAE;AACtC,wBAAwB,IAAI,mEAAY,EAAE;AAC1C;AACA;AACA;AACA;AACA;AACA,4CAA4C,YAAY,qBAAqB,YAAY;AACzF,6BAA6B,KAAK,qEAAc,EAAE;AAClD,iCAAiC,KAAK,qEAAc,EAAE;AACtD;AACA;AACA;AACA;AACA;AACA,4FAA4F,qCAAqC,EAAE,mCAAmC;AACtK;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,YAAY,qEAAc,EAAE;AACxE,+CAA+C,sEAAQ;AACvD;AACA;AACA;AACA;AACA;AACA,6BAA6B,KAAK,qEAAc,EAAE;AAClD,iCAAiC,KAAK,qEAAc,EAAE;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6DAAM;AAC9B;AACA;AACA;AACA;AACA;AACA,SAAS,sGAAsB,KAAK;AACpC;AACA;AACA;AACA,aAAa,qGAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,2FAA0C;AACpG;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0GAA0B;AACtC;AACA,6BAA6B,qGAAiB;AAC9C,oBAAoB,0GAA0B;AAC9C;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wEAAkB;AAC9B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,iEAAW,QAAQ,mEAAY;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,uDAAuD,sGAAqC;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,yCAAyC,6EAAuB,OAAO,iEAAW,IAAI,mEAAY,GAAG,mEAAY;AACjH,4BAA4B,6DAAM;AAClC;AACA;AACA;AACA,qCAAqC,6DAAM;AAC3C;AACA;AACA;AACA;AACA;AACA,gCAAgC,wBAAwB;AACxD;AACA,iDAAiD,0GAA0B;AAC3E;AACA,wCAAwC,8BAA8B;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,wFAAkB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,wBAAwB;AAC5D,gDAAgD,0GAA0B;AAC1E;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,oCAAoC,0GAA0B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6DAAM;AAClC;AACA;AACA;AACA,4BAA4B,IAAI,mEAAY,EAAE;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACpe+D;AACU;AACuB;AACT;AACN;AACb;AACpE;AACA,YAAY,sDAAsD;AAClE,iCAAiC,6EAAuB,OAAO,uFAAsB,WAAW,kFAAY;AAC5G,oBAAoB,IAAI,oFAAc,EAAE;AACxC,wBAAwB,IAAI,oFAAc,EAAE;AAC5C;AACA;AACA;AACA,gCAAgC,4EAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,qGAAiB;AAC9C;AACA,6CAA6C,SAAS,oFAAc,EAAE;AACtE,iDAAiD,SAAS,oFAAc,EAAE;AAC1E;AACA;AACA,4DAA4D,iFAAgB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+FAAkC;AAC9D;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;AClD0E;AACsB;AAC7C;AACH;AACe;AACqB;AACpF;AACO,qBAAqB,qDAAW;AACvC;AACA,QAAQ,qEAA2B;AACnC;AACA,6BAA6B,4FAAmB;AAChD;AACA,yBAAyB,OAAO,qDAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,8EAA2B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,oFAAc;AACjE,sDAAsD,oFAAc;AACpE;AACA;AACA,wBAAwB,0GAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC5D0D;AAC2B;AACI;AACmB;AACzB;AACa;AACzB;AACe;AACtF;AACO,8BAA8B,iFAAW;AAChD;AACA,QAAQ,iGAA2B;AACnC;AACA,yBAAyB,OAAO,oEAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2GAA4B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,qCAAqC;AACtD,4BAA4B,uFAAiB;AAC7C,0GAA0G,kFAAY;AACtH;AACA;AACA;AACA,kCAAkC,oGAA4B;AAC9D,qCAAqC,sGAA8B;AACnE,qCAAqC,qGAA6B;AAClE,oBAAoB,gCAAgC;AACpD;AACA;AACA;AACA;AACA;AACA,oBAAoB,0GAA0B;AAC9C,gEAAgE,0GAAmB,CAAC,iGAAc;AAClG;AACA;AACA;AACA,uCAAuC,kFAAY;AACnD;AACA,oBAAoB,uGAAkB;AACtC;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AChEkE;AACf;AAC+B;AAClC;AACe;AACiC;AACf;AACvB;AACY;AACtE;AACO,wBAAwB,qDAAW;AAC1C;AACA,QAAQ,qEAA2B;AACnC;AACA,yBAAyB,OAAO,qDAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0EAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mEAAmE;AACnF,qCAAqC,8EAAqB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,gBAAgB,wEAAkB;AAClC,+EAA+E,oFAAgB;AAC/F;AACA;AACA;AACA;AACA;AACA,gEAAgE,wFAAsB;AACtF;AACA,gCAAgC,0GAA0B;AAC1D;AACA,gCAAgC,oFAAmB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACvEuD;AACJ;AACc;AACoC;AACrD;AACe;AACqB;AACY;AACvB;AACzE;AACO,2BAA2B,qDAAW;AAC7C;AACA,QAAQ,qEAA2B;AACnC;AACA,6BAA6B,4FAAmB;AAChD,yBAAyB,OAAO,qDAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,8EAA2B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+EAAkB;AAC9B,oBAAoB,mEAAmE;AACvF;AACA;AACA;AACA;AACA;AACA,4BAA4B,uDAAW,QAAQ,mEAAY,eAAe,uDAAW,QAAQ,mEAAY;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,0GAA0B;AAC3C,iGAAiG,2FAAmB,CAAC,kFAAc;AACnI;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC5DmD;AACc;AACjB;AAChD;AACO,4BAA4B,qDAAW;AAC9C;AACA,QAAQ,qEAA2B;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO,qDAAO;AACvC;AACA;AACA;AACA;AACA;AACA,gEAAgE,qBAAqB;AACrF;AACA,6EAA6E,qBAAqB;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oBAAoB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mEAAY;AACzC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACtEmD;AACc;AACjB;AACe;AACE;AACa;AAC9E;AACO,uBAAuB,qDAAW;AACzC;AACA,QAAQ,qEAA2B;AACnC;AACA;AACA;AACA;AACA;AACA,6BAA6B,yEAAa,QAAQ,+DAAgB,GAAG,mFAAoC;AACzG,2BAA2B,mEAAY;AACvC,yBAAyB,OAAO,qDAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+EAA4B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,mEAAY;AAC9D;AACA;AACA;AACA;AACA,iDAAiD,mEAAY;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,YAAY;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iFAAmC;AAC/C;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC/F4D;AACO;AAChB;AACyD;AAChC;AAC5B;AACe;AACW;AAC1E;AACO,4BAA4B,qDAAW;AAC9C;AACA,QAAQ,qEAA2B;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO,qDAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+EAA4B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,wFAAqB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0EAAa;AACzB;AACA;AACA;AACA,2BAA2B,0BAA0B,kFAAuB,eAAe;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gCAAgC;AAChD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,iDAAiD,MAAM,wFAA+B,EAAE;AACxF;AACA;AACA,qDAAqD,yEAAkB;AACvE;AACA,gCAAgC,6DAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,iFAAsB,gCAAgC;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACrGoE;AACD;AAChB;AACgC;AACV;AACA;AACzB;AAChD;AACO,qBAAqB,qDAAW;AACvC;AACA,QAAQ,qEAA2B;AACnC;AACA;AACA;AACA;AACA,4CAA4C,qEAAe,gBAAgB,mEAAY;AACvF;AACA;AACA;AACA;AACA,iCAAiC,iEAAW,IAAI,mEAAY;AAC5D;AACA;AACA,yBAAyB,OAAO,qDAAO;AACvC;AACA,yHAAyH,EAAE;AAC3H;AACA;AACA;AACA,yBAAyB,OAAO;AAChC,gCAAgC,OAAO;AACvC,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA;AACA;AACA,8EAA8E,IAAI;AAClF;AACA;AACA,4BAA4B,oBAAoB;AAChD;AACA;AACA;AACA;AACA,iCAAiC,mEAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,6BAA6B;AAC/C;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA,4BAA4B,6DAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,yFAA8B;AACjE,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA,+BAA+B,+EAAkB;AACjD;AACA;AACA,iCAAiC,iEAAW,IAAI,mEAAY;AAC5D,gCAAgC,6DAAM;AACtC;AACA;AACA;AACA;AACA,+BAA+B,yEAAkB;AACjD;AACA;AACA;AACA;AACA;AACA,oCAAoC,6DAAM;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC9GmD;AACmD;AACb;AACzC;AAChD;AACO,iCAAiC,qDAAW;AACnD;AACA,QAAQ,qEAA2B;AACnC;AACA;AACA,yBAAyB,OAAO,qDAAO;AACvC;AACA;AACA;AACA;AACA;AACA,kCAAkC,6BAA6B;AAC/D,4DAA4D,8BAA8B;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,6BAA6B;AACpD;AACA,iBAAiB,qCAAqC;AACtD,4BAA4B,wEAAiB;AAC7C;AACA,0GAA0G,mEAAY;AACtH;AACA;AACA;AACA;AACA,4BAA4B,mEAAY;AACxC,qCAAqC,iFAAsB;AAC3D,mBAAmB,2FAA0B;AAC7C;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AClDkE;AACf;AACH;AACe;AACY;AAC3E;AACO,mCAAmC,qDAAW;AACrD;AACA,QAAQ,qEAA2B;AACnC;AACA,yBAAyB,OAAO,qDAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0EAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,qFAA4B;AACrE;AACA;AACA,8CAA8C,sFAA6B;AAC3E;AACA;AACA;AACA,sCAAsC,iFAAsB;AAC5D;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AChDmD;AACkC;AACrC;AACe;AAC8B;AAC7F;AACO,8BAA8B,qDAAW;AAChD,yBAAyB,OAAO,qDAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,8EAA2B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,+EAAkB;AACnC,oBAAoB,+EAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,2FAAmB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC9EmD;AAC2B;AAC9B;AACe;AAC/D;AACO,0BAA0B,qDAAW;AAC5C;AACA,QAAQ,qEAA2B;AACnC;AACA,2BAA2B,mEAAY;AACvC;AACA;AACA;AACA,yBAAyB,OAAO,qDAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sFAAmC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B,4BAA4B,wEAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,mEAAY;AAC9D;AACA;AACA;AACA;AACA,iDAAiD,mEAAY;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,YAAY;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACjEuE;AACpB;AACH;AAChD;AACO,4BAA4B,qDAAW;AAC9C;AACA,QAAQ,qEAA2B;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO,qDAAO;AACvC;AACA;AACA;AACA;AACA,yBAAyB,mBAAmB;AAC5C,iCAAiC,mBAAmB;AACpD,qEAAqE,oBAAoB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mBAAmB;AACnD;AACA,iBAAiB,4BAA4B;AAC7C,yFAAyF,uFAAiB;AAC1G;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACjDoD;AACD;AACyB;AAC5B;AACe;AAC/D;AACO;AACP;AACA;AACA;AACA;AACO;AACA,+BAA+B,qDAAW;AACjD;AACA,QAAQ,qEAA2B;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO,qDAAO;AACvC;AACA;AACA;AACA;AACA;AACA,2CAA2C,wCAAwC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0EAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oBAAoB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,wFAA+B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kEAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC9GmE;AAChB;AACqB;AACa;AACI;AACzC;AACe;AACX;AACpD;AACO,uBAAuB,qDAAW;AACzC;AACA,QAAQ,qEAA2B;AACnC;AACA,6BAA6B,6DAAe;AAC5C,yBAAyB,OAAO,qDAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2EAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B,4BAA4B,wEAAiB;AAC7C;AACA;AACA;AACA;AACA,4BAA4B,6DAAM;AAClC;AACA;AACA;AACA;AACA,6CAA6C,2FAA0B;AACvE;AACA,iEAAiE,2FAAmB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,yEAAkB;AAC/C;AACA;AACA;AACA;AACA,8CAA8C,2FAA0B;AACxE;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;;ACtEmD;AACH;AAChD;AACO,kCAAkC,qDAAW;AACpD;AACA,QAAQ,qEAA2B;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO,qDAAO;AACvC;AACA;AACA;AACA;AACA;AACA,qEAAqE,8BAA8B;AACnG;AACA,mGAAmG,+BAA+B;AAClI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,8BAA8B;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACzDuD;AACU;AACC;AAClB;AACe;AAC/D;AACO,yBAAyB,qDAAW;AAC3C;AACA,QAAQ,qEAA2B;AACnC;AACA,yBAAyB,OAAO,oEAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+EAA4B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uDAAW,QAAQ,mEAAY;AACzD;AACA;AACA;AACA;AACA;AACA,eAAe,6FAAqC;AACpD;AACA;;;;;;;;;;;;;;;;;;;;AC3CkI;AAC7B;AACnC;AAClB;AAChD;AACO,wBAAwB,qDAAW;AAC1C;AACA,QAAQ,qEAA2B;AACnC;AACA;AACA;AACA;AACA;AACA,qEAAqE,qGAAiB;AACtF,iCAAiC,mGAAmB,EAAE,kGAAkB,EAAE,oGAAoB,EAAE,oGAAoB;AACpH;AACA,yBAAyB,OAAO,oEAAY;AAC5C;AACA;AACA,8BAA8B,0GAA0B;AACxD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iDAAiD,+FAA2B,CAAC,sFAAkB,cAAc;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,qGAAiB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,8BAA8B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACzDyE;AACN;AACD;AAClB;AAChD;AACO;AACA,4BAA4B,qDAAW;AAC9C;AACA,QAAQ,qEAA2B;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO,oEAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,mBAAmB,EAAE,uFAAmB,sBAAsB;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,qEAAc;AAC9E,gEAAgE,qEAAc;AAC9E;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACnDkE;AACO;AACzB;AACe;AAC/D;AACO,kCAAkC,qDAAW;AACpD,yBAAyB,OAAO,oEAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+EAA4B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oFAAmB;AACvD;AACA;AACA;AACA;AACA;AACA,eAAe,sGAA8C;AAC7D;AACA;;;;;;;;;;;;;;;;;;;;ACvCgF;AACd;AAClB;AACe;AAC/D;AACO,uBAAuB,qDAAW;AACzC;AACA,QAAQ,qEAA2B;AACnC;AACA,yBAAyB,OAAO,oEAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+EAA4B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,gCAAgC,mGAAmB,EAAE;AAC/F,0CAA0C,+BAA+B,mGAAmB,EAAE;AAC9F,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC9CkE;AACO;AACzB;AAChD;AACO,wBAAwB,qDAAW;AAC1C;AACA,QAAQ,qEAA2B;AACnC;AACA;AACA,eAAe,oEAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gCAAgC;AAChD;AACA,yBAAyB,sFAAqB,gBAAgB,kFAAiB,gBAAgB,kFAAiB;AAChH;AACA;AACA;AACA;AACA;AACA,yBAAyB,oFAAmB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sGAA8C;AAC7D;AACA;;;;;;;;;;;;;;;;;;;ACjDkE;AAClB;AACe;AAC/D;AACO,sBAAsB,qDAAW;AACxC;AACA,QAAQ,qEAA2B;AACnC;AACA,yBAAyB,OAAO,oEAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+EAA4B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,6FAAqC;AAC7C;AACA;;;;;;;;;;;;;;;;;ACzC8D;AACvD;AACP,WAAW,4EAAc;AACzB,YAAY,4EAAc;AAC1B,gBAAgB,4EAAc;AAC9B,cAAc,4EAAc;AAC5B,sBAAsB,4EAAc;AACpC,eAAe,4EAAc;AAC7B,gBAAgB,4EAAc;AAC9B,uBAAuB,4EAAc;AACrC,YAAY,4EAAc;AAC1B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACXuC;AACM;AACe;AAC2B;AACA;AACN;AACV;AACkB;AACV;AACgB;AACM;AACf;AACQ;AAClD;AACrC;AACP;AACA,CAAC;AACD;AACA,IAAI,0FAAU,EAAE,gGAAa,EAAE,gFAAK,EAAE,gGAAa;AACnD,IAAI,gGAAS,EAAE,wGAAa;AAC5B,IAAI,wFAAQ;AACZ;AACA;AACA;AACA,iCAAiC,+CAAK;AACtC;AACA;AACA,sCAAsC,oEAAY;AAClD;AACA;AACA,sCAAsC,qDAAO;AAC7C;AACA;AACA;AACO;AACP;AACA;AACA,yBAAyB,wGAAa,EAAE,gGAAS,EAAE,wGAAgB,EAAE,kGAAa,EAAE,+GAAmB;AACvG,8BAA8B,sEAA2B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACO;AACP;AACA,4BAA4B,0EAA+B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACxJwF;AACD;AAChC;AACO;AACJ;AACnD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,oEAAc;AACnD,wBAAwB,uEAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qGAAsB;AAClD;AACA,iDAAiD,kGAAiB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uEAAwB;AACrC;AACP;AACA;AACA;AACA,eAAe,2EAAiB;AAChC;AACA;;;;;;;;;;;;;;;;;;;;;;;AC1D0D;AAC4C;AACuB;AACiE;AACvG;AACX;AACrE;AACP;AACA;AACA;AACA,8CAA8C,IAAI,mCAAmC,IAAI;AACzF,0CAA0C,IAAI,YAAY,IAAI;AAC9D,kEAAkE,IAAI;AACtE;AACA,yBAAyB;AACzB,uBAAuB;AACvB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,6DAAqB;AAC1D,mCAAmC,6DAAqB;AACxD;AACA;AACA,qBAAqB;AACrB;AACA;AACA,mCAAmC,6DAAqB;AACxD;AACA;AACA,qBAAqB,OAAO,kGAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,6FAAqB;AAC9C,iDAAiD,6FAAqB;AACtE,gBAAgB,6FAAqB;AACrC,yBAAyB,MAAM,6FAAqB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,yGAAoB,YAAY,qGAAiB;AAC9D;AACA,+BAA+B,6DAAqB;AACpD;AACA;AACA;AACA,mBAAmB,0GAAmB,CAAC,0FAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,8BAA8B,0GAAmB,CAAC,iGAAc;AAChE;AACA;AACA;AACA,gCAAgC,6DAAqB;AACrD,8BAA8B,6DAAqB;AACnD,QAAQ,wEAAkB;AAC1B,QAAQ,wEAAkB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,0BAA0B,qGAA6B;AAC5E;AACA;AACA,qBAAqB,0BAA0B,oGAA4B;AAC3E;AACA;AACA;AACA;AACA,SAAS,8FAAkB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,mGAAuB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF,iEAAyB;AAC9G,6BAA6B,yGAAoB;AACjD;AACA,qEAAqE,0FAAS;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,6DAAqB;AACpG,6BAA6B,yGAAoB;AACjD;AACA,sEAAsE,0FAAS;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uGAA2B;AAC/C,kDAAkD;AAClD;AACA;AACA,wFAAwF,4BAA4B;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8FAAkB;AAClC;AACA;AACA;AACA,+DAA+D,KAAK;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yBAAyB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uGAA2B;AAC3C,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AChSO;AACP;AACA;AACA;AACA;AACA;AACA,uCAAuC,qCAAqC;AAC5E;AACA;AACA;AACA,sCAAsC,EAAE,qBAAqB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACtByD;AACgJ;AACtI;AAC5D;AACP,iBAAiB,gFAAoB;AACrC,sBAAsB,sEAAgB;AACtC,kBAAkB,gFAAqB;AACvC,UAAU,yEAAa,UAAU,yEAAa;AAC9C,iBAAiB,gFAAoB;AACrC,iBAAiB,gFAAoB;AACrC,gBAAgB,+EAAmB;AACnC,gBAAgB,+EAAmB;AACnC,aAAa,4EAAgB;AAC7B,CAAC;;;;;;;;;;;;;;;;;;;;;;;;ACbmE;AACK;AACf;AACsC;AAC0C;AAC1B;AACnD;AACtD;AACP,wBAAwB,oFAAc,oCAAoC,oFAAc;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE,4BAA4B;AAC3C;AACA;AACA;AACA,QAAQ,qEAAe,WAAW,kFAAY;AAC9C;AACA;AACA;AACA;AACA,kCAAkC,kFAAY,EAAE,qBAAqB,gBAAgB;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,uCAAuC;AACxF;AACA;AACA;AACO;AACP;AACA;AACA,eAAe,uFAAsB,OAAO,mGAAgB;AAC5D,qBAAqB,oEAAO;AAC5B;AACA,KAAK;AACL;AACA,eAAe,qDAAa;AAC5B,KAAK;AACL;AACA,4BAA4B,iDAAS;AACrC;AACA,4BAA4B,oEAAO;AACnC,sBAAsB,uFAAsB,OAAO,mGAAgB;AACnE;AACA,gCAAgC,4GAAqB;AACrD;AACA,8EAA8E,oFAAc;AAC5F;AACA;AACA;AACA;AACA,gBAAgB,yGAAoB;AACpC,qCAAqC,0FAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qEAAe,SAAS,kFAAY;AACpD;AACA;AACA;AACA,6EAA6E,iBAAiB;AAC9F;AACA;AACA,2BAA2B,iEAAW,OAAO,kFAAY;AACzD;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,4GAAqB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,gCAAgC,4EAAM;AACtC;AACA,uCAAuC,kGAAiB;AACxD;AACA;AACA;AACA;AACA;AACA,4BAA4B,IAAI,oFAAc,EAAE;AAChD,gCAAgC,IAAI,oFAAc,EAAE;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,oFAAc;AACrE,sCAAsC,oBAAoB;AAC1D,gCAAgC,oBAAoB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA,gBAAgB,cAAc;AAC9B;AACA,8BAA8B,gGAAe,gCAAgC;AAC7E,8BAA8B,0DAA0D;AACxF,8BAA8B,oEAAoE;AAClG,8BAA8B,qEAAqE;AACnG,8BAA8B,sBAAsB;AACpD,8BAA8B,cAAc;AAC5C,8BAA8B,qCAAqC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,oBAAoB;AAC9D;AACA;AACA,sCAAsC,kBAAkB;AACxD;AACA;AACA,sCAAsC,oBAAoB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+CAAO;AACtB;AACA,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjM8D;AAC8F;AACzG;AACS;AAC7D;AACO;AACP;AACA,kBAAkB,qFAAe;AACjC;AACA,eAAe,qDAAa;AAC5B,KAAK;AACL;AACA,4BAA4B,iDAAS;AACrC,yCAAyC,iFAAW;AACpD;AACA;AACA;AACA,eAAe,qFAAe;AAC9B,KAAK;AACL;AACA,eAAe,+CAAO;AACtB;AACA,CAAC;AACD;AACO;AACP;AACA;AACA;AACA,eAAe,qDAAa;AAC5B,KAAK;AACL;AACA,wBAAwB,iDAAS;AACjC,KAAK;AACL;AACA;AACA;AACA;AACA,mBAAmB,+CAAO;AAC1B;AACA;AACA,mBAAmB,+CAAO;AAC1B;AACA;AACA,CAAC;AACD;AACO;AACP;AACA;AACA;AACA,eAAe,qDAAa;AAC5B,KAAK;AACL;AACA,eAAe,iDAAS;AACxB,KAAK;AACL;AACA;AACA;AACA,eAAe,+CAAO;AACtB;AACA,CAAC;AACD,8EAA8E,6CAA6C;AACpH;AACP;AACA;AACA;AACA,eAAe,qDAAa;AAC5B,KAAK;AACL;AACA;AACA,2BAA2B,iDAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,kDAAkD,2BAA2B,UAAU,0BAA0B;AACjH;AACA;AACA,oCAAoC,kEAAc,gCAAgC;AAClF;AACA;AACA,iCAAiC,kEAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+CAAO;AACtB;AACA,CAAC;AACD;AACO;AACP;AACA;AACA;AACA,eAAe,qDAAa;AAC5B,KAAK;AACL;AACA,4BAA4B,iDAAS;AACrC,eAAe,mGAAyB;AACxC,KAAK;AACL;AACA;AACA;AACA,eAAe,+CAAO;AACtB;AACA,CAAC;AACD;AACO;AACP;AACA;AACA;AACA,eAAe,qDAAa;AAC5B,KAAK;AACL;AACA,0BAA0B,iDAAS;AACnC;AACA,KAAK;AACL;AACA;AACA;AACA,eAAe,+CAAO;AACtB;AACA,CAAC;AACM;AACP;AACA,kBAAkB,6EAAuB,UAAU,GAAG,kFAAY;AAClE;AACA,4BAA4B,4EAAM;AAClC,+BAA+B,gGAAsB;AACrD,gBAAgB,qDAAa,0BAA0B,qDAAa,cAAc,WAAW;AAC7F;AACA;AACA;AACA,KAAK;AACL;AACA,4BAA4B,4EAAM;AAClC,+BAA+B,gGAAsB;AACrD;AACA,gBAAgB,qDAAa;AAC7B,6BAA6B,iDAAS;AACtC;AACA,+CAA+C;AAC/C;AACA;AACA,qBAAqB,qDAAa,cAAc,WAAW;AAC3D,mCAAmC,iDAAS;AAC5C;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,4BAA4B,4EAAM;AAClC;AACA;AACA,yCAAyC,+CAAO,IAAI,iFAAW,QAAQ;AACvE;AACA;AACA,yCAAyC,+CAAO,IAAI,iFAAW,QAAQ;AACvE;AACA;AACA;AACA;AACA,CAAC;AACD;AACO;AACP;AACA;AACA;AACA,eAAe,qDAAa;AAC5B,KAAK;AACL;AACA,eAAe,iDAAS;AACxB,KAAK;AACL;AACA;AACA;AACA,eAAe,+CAAO;AACtB;AACA,CAAC;;;;;;;;;;;;;;;;;;AC/MyG;AAC7C;AAC7D;AACO;AACP;AACA,kBAAkB,qGAAsB;AACxC;AACA,eAAe,qDAAa;AAC5B,KAAK;AACL;AACA,eAAe,gGAAiB,CAAC,iDAAS;AAC1C,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+CAAO;AACtB;AACA,CAAC;;;;;;;;;;;;;;;;;;;;AC3BM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO,0CAA0C,SAAS,GAAG,QAAQ;AAC9D,oFAAoF,0BAA0B;AAC9G,+DAA+D,YAAY;;;;;;;;;;;;;;;;;;;ACnB3E;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC5CO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACdO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACnBO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA,0BAA0B,SAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://spring-react-app/./src/main/client/ts/baseTypes.ts","webpack://spring-react-app/./src/main/client/ts/interfaces/Colors.ts","webpack://spring-react-app/./src/main/client/ts/logic/BaseInterfaces.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/Board/Board.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/Board/BoardInterface.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/FENData/FENData.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/FENData/FENDataInterface.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/FENData/FENOptions/FENOptions.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/FENData/FENOptions/FENOptionsTags.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/FENData/FENOptions/FENOptionsTagsInterface.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/GameInformation/GameData.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/GameInformation/GameUnits/GameUnits.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/GameInformation/GameUnits/PieceString.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/MoveTree/MoveNotationStringifier.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/MoveTree/MoveTree.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/MoveTree/MoveTreeInterface.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/PieceControl/PieceControl.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/PieceControl/PieceControlBuilder.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/PieceControl/PieceControlDeclarations.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/PieceControl/PieceControlInterface.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRule.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/AllowPassing.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/AlternativeTeams.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/BarePieceRule.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/Blindfold.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/CaptureTheKing.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/Chess960.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/Crazyhouse.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/DuckChess.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/FogOfWar.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/ForcedCapture.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/GameMetadataRules.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/Ghostboard.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/ParadigmChess30.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/PiecesFaceCenter.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/SeirawanSetup.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/SelfCheck.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/SetupChess.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/Taboo.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardVariantModules/EngineMoveGeneration/Algorithms/ComfuterEvaluation.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardVariantModules/EngineMoveGeneration/Algorithms/ComfuterEvaluationExtensions.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardVariantModules/EngineMoveGeneration/Algorithms/MixedAlgorithms.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardVariantModules/EngineMoveGeneration/Algorithms/RandomEvaluation.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardVariantModules/EngineMoveGeneration/Algorithms/RandomEvaluationExtensions.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardVariantModules/EngineMoveGeneration/BotInterface.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardVariantModules/InsufficientMaterial/InsufficientMaterialGeneration.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardVariantModules/InsufficientMaterial/PieceMedianCounter.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/Atomic.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/DeadKingWalking.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/EnPassant.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/FatalCapture.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/FiftyMoveRule.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/Giveaway.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/KingOfTheHill.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/NCheck.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/OppositeMultiplier.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/OppositeSideCastling.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/PiecesGoToBanks.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/PlayForMate.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/PointsForMate.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/StalemateOptions.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/Takeover.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/ThreefoldRepetition.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/PieceControlDecorators/AnyCapture.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/PieceControlDecorators/PromoteTo.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/PieceControlDecorators/PromotionRank.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/PieceControlDecorators/RoyalsCannotCapture.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/PieceControlDecorators/Sideways.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/PieceControlDecorators/Stonewall.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/PieceControlDecorators/Torpedo.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleInterface.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleSetup.ts","webpack://spring-react-app/./src/main/client/ts/logic/utils/Tags/InputOutputProcessing.ts","webpack://spring-react-app/./src/main/client/ts/logic/utils/Tags/Moves/ParsePGNMoves.ts","webpack://spring-react-app/./src/main/client/ts/logic/utils/Tags/Moves/SerializePGNMoves.ts","webpack://spring-react-app/./src/main/client/ts/logic/utils/Tags/TagInterface.ts","webpack://spring-react-app/./src/main/client/ts/logic/utils/Tags/TagLogic/FENDataTag.ts","webpack://spring-react-app/./src/main/client/ts/logic/utils/Tags/TagLogic/GameMetadataTags.ts","webpack://spring-react-app/./src/main/client/ts/logic/utils/Tags/TagLogic/VariantRulesTag.ts","webpack://spring-react-app/./src/main/client/ts/logic/utils/Tags/Utils.ts","webpack://spring-react-app/./src/main/client/ts/utils/ArrayUtils.ts","webpack://spring-react-app/./src/main/client/ts/utils/NumberUtils.ts","webpack://spring-react-app/./src/main/client/ts/utils/ObjectUtils.ts","webpack://spring-react-app/./src/main/client/ts/utils/StringFormatUtils.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/ sync \\.ts$"],"sourcesContent":["export const verifyFunctionType = (func) => typeof func === 'function';\r\nexport const createTuple = (val, length) => Array.from({ length }).fill(val);\r\nexport const createTupleFromCallback = (val, length) => Array.from({ length }, val);\r\nexport const verifyTupleType = (arr, length) => arr.length === length;\r\nexport function assertNonUndefined(data) {\r\n    if (data == null)\r\n        throw new Error(\"Expected the data above to be anything but null or undefined\");\r\n}\r\nexport function throwOnNever(arg) {\r\n    console.dir(arg);\r\n    throw new TypeError(`Unexpected argument that is supposed to be of type never`);\r\n}\r\nexport function importAll(r) {\r\n    r.keys().forEach(r);\r\n}\r\nexport function getEnumKeys(object) {\r\n    const resultingArray = [];\r\n    let key;\r\n    for (key in object)\r\n        resultingArray.push(key);\r\n    return resultingArray;\r\n}\r\n","import { throwOnNever, verifyTupleType } from \"../baseTypes\";\r\nconst hexColorRegex = /^#(?:[0-9a-fA-F]{3}){1,2}$/;\r\nexport const createHexColor = (color) => {\r\n    if (hexColorRegex.test(color)) {\r\n        return color;\r\n    }\r\n    else\r\n        throw new TypeError(\"The supplied hex color is not a hex color: \" + color);\r\n};\r\nexport const verifyHexColor = (color) => typeof color === 'string';\r\nexport const validateHexColor = (color) => {\r\n    if (typeof color === \"string\") {\r\n        try {\r\n            createHexColor(color);\r\n            return true;\r\n        }\r\n        catch (_) {\r\n            return false;\r\n        }\r\n    }\r\n    else\r\n        return false;\r\n};\r\nexport const createRGBColor = (color) => {\r\n    if (color >= 0 || color <= 255) {\r\n        return color;\r\n    }\r\n    else\r\n        throw new TypeError(`The supplied RGB color value is not an RGB color value: ${color}`);\r\n};\r\nexport const wrapRGBColor = (color) => `rgb(${color.join(\",\")})`;\r\nexport const verifyRGBColor = (color) => Array.isArray(color);\r\nexport const validateRGBColor = (color) => {\r\n    if (Array.isArray(color) && verifyTupleType(color, 3)\r\n        && color.every((c) => typeof c === \"number\")) {\r\n        try {\r\n            color.forEach(c => createRGBColor(c));\r\n            return true;\r\n        }\r\n        catch (_) {\r\n            return false;\r\n        }\r\n    }\r\n    else\r\n        return false;\r\n};\r\nexport const createHSLColor = (color) => {\r\n    if ((color.hue >= 0 || color.hue <= 359) && (color.saturation >= 0 || color.saturation <= 100)\r\n        && (color.lightness >= 0 || color.lightness <= 100)) {\r\n        return color;\r\n    }\r\n    else\r\n        throw new TypeError(`The supplied HSL value is not an HSL color: \" + color`);\r\n};\r\nexport const wrapHSLColor = (color) => `hsl(${color.hue},${color.saturation}%,${color.lightness}%)`;\r\nexport const verifyHSLColor = (color) => typeof color === 'object';\r\nexport const validateHSLColor = (color) => {\r\n    const verifyNumberRecord = (obj) => {\r\n        for (const key in obj) {\r\n            if (!Object.prototype.hasOwnProperty.call(obj, key))\r\n                continue;\r\n            if (typeof obj[key] !== \"number\")\r\n                return false;\r\n        }\r\n        return true;\r\n    };\r\n    if (typeof color === \"object\" && color && \"hue\" in color\r\n        && \"saturation\" in color && \"lightness\" in color\r\n        && verifyNumberRecord(color)) {\r\n        try {\r\n            createHSLColor(color);\r\n            return true;\r\n        }\r\n        catch (_) {\r\n            return false;\r\n        }\r\n    }\r\n    else\r\n        return false;\r\n};\r\nexport const wrapIndexedColor = (color) => {\r\n    if (verifyHexColor(color)) {\r\n        return color;\r\n    }\r\n    else if (verifyRGBColor(color)) {\r\n        return wrapRGBColor(color);\r\n    }\r\n    else if (verifyHSLColor(color)) {\r\n        return wrapHSLColor(color);\r\n    }\r\n    else {\r\n        return throwOnNever(color);\r\n    }\r\n};\r\nexport const validateIndexedColor = (color) => {\r\n    return validateHexColor(color) || validateRGBColor(color) || validateHSLColor(color);\r\n};\r\n","import { createTupleFromCallback } from \"../baseTypes\";\r\nimport { boardDimension } from \"./movegen/GameInformation/GameData\";\r\nexport const initializeBoardSquares = (baseValue) => createTupleFromCallback(() => createTupleFromCallback(baseValue, boardDimension), boardDimension);\r\nexport const isVerticalPlacement = (color) => color % 2 === 0;\r\nexport function getVerticalPlacementModulus(num) {\r\n    const result = num % 2;\r\n    if (result !== 0 && result !== 1)\r\n        throw new Error(`Invalid number passed: ${num}`);\r\n    return result;\r\n}\r\nexport function getHorizontalPlacementModulus(num) {\r\n    const result = (num % 2) ^ 1;\r\n    if (result !== 0 && result !== 1)\r\n        throw new Error(`Invalid number passed: ${num}`);\r\n    return result;\r\n}\r\n","import { assertNonUndefined, createTuple, createTupleFromCallback } from \"../../../baseTypes\";\r\nimport { initializeBoardSquares } from \"../../BaseInterfaces\";\r\nimport { createMoveTree } from \"../MoveTree/MoveTree\";\r\nimport { createBaseMoveWrapper, InternalMoveSignature, SpecialMove } from \"../MoveTree/MoveTreeInterface\";\r\nimport { FENData } from \"../FENData/FENData\";\r\nimport { boardDimension, colors, totalPlayers } from \"../GameInformation/GameData\";\r\nimport { nonPlayablePieces } from \"../GameInformation/GameUnits/GameUnits\";\r\nimport { createPieceFromData, deadColorIndex, pawnPieceString, wallPieceString } from \"../GameInformation/GameUnits/PieceString\";\r\nimport { PieceControlBuilder } from \"../PieceControl/PieceControlBuilder\";\r\nimport { initPieceControlDeclarations } from \"../PieceControl/PieceControlDeclarations\";\r\nimport { AttackType, pieceControlConfigSettings } from \"../PieceControl/PieceControlInterface\";\r\nimport { decorateClassWithVariants } from \"../VariantRules/VariantRule\";\r\nimport { copyVariantRules, validateVariantRules } from \"../VariantRules/VariantRuleSetup\";\r\nimport { createGameTypeSettings, createComplexMoveLegalityTracker, createBasePreGeneratedAttacks, compareCoordinates, stringifyCoordinate } from \"./BoardInterface\";\r\nimport { copyClass } from \"@client/ts/utils/ObjectUtils\";\r\nimport { parsePGN4 } from \"../../utils/Tags/InputOutputProcessing\";\r\ninitPieceControlDeclarations();\r\nexport const baseImmunes = createTuple(false, totalPlayers);\r\nexport class Board {\r\n    controls = {};\r\n    data;\r\n    moves;\r\n    preGeneratedAttacks = createTupleFromCallback(createBasePreGeneratedAttacks, totalPlayers);\r\n    board;\r\n    isComplexSetup = createComplexMoveLegalityTracker();\r\n    gameData;\r\n    gameType = createGameTypeSettings();\r\n    variantRules;\r\n    variantData;\r\n    isTwoPlayer;\r\n    insufficientMaterialModule;\r\n    __baseClass;\r\n    initDecoratorSettings() { }\r\n    /*---------------------------------- INITIALIZATION -----------------------------------------*/\r\n    constructor(pgn4) {\r\n        this.__baseClass = this;\r\n        const parsingResults = parsePGN4(pgn4);\r\n        this.gameType.type = parsingResults.gameType;\r\n        this.variantRules = parsingResults.variantRules;\r\n        this.gameData = parsingResults.gameData;\r\n        this.board = parsingResults.board;\r\n        this.data = parsingResults.fenData;\r\n        this.data.injectBoard(this);\r\n        this.data = decorateClassWithVariants(this.data, FENData, this.variantRules.fenDataDecorators);\r\n        this.variantData = parsingResults.variantRuleData;\r\n        this.variantRules = validateVariantRules(this);\r\n        this.isTwoPlayer = this.data.getRealPlayers() === 2;\r\n        this.initPieceControls(parsingResults.pieceSet);\r\n        this.moves = createMoveTree(this.createSnapshot());\r\n        this.moves.moves = parsingResults.moves;\r\n        this.pregenerateAttacks();\r\n        /*\r\n                new Promise((resolve: (value: InsufficientMaterialModule) => void) => {\r\n                    setTimeout(() => resolve(generateInsufficientMatingPieces(this)), 0)\r\n                }).then(result => {\r\n                    this.insufficientMaterialModule = result;\r\n                }).catch(exception => {\r\n                    console.error(\"Failed to generate insufficient material module: \");\r\n                    console.trace(exception);\r\n                });*/\r\n    }\r\n    initPieceControls(pieces) {\r\n        if (pieces.size === 0)\r\n            return;\r\n        const builder = new PieceControlBuilder();\r\n        builder.setFENData(this.data);\r\n        builder.setVariantRules(this.variantRules.pieceControlDecorators);\r\n        for (const piece of pieces) {\r\n            const pieceControlConfigurator = builder.createPieceControlWrap(piece);\r\n            this.controls[piece] = pieceControlConfigurator;\r\n        }\r\n    }\r\n    getSquareVisibility() {\r\n        return initializeBoardSquares(() => []);\r\n    }\r\n    createSnapshot() {\r\n        return {\r\n            data: this.data.createSnapshot(),\r\n            board: this.board.map(a => [...a]),\r\n            isComplexSetup: Object.assign({}, this.isComplexSetup)\r\n        };\r\n    }\r\n    loadSnapshot(snapshot) {\r\n        this.isComplexSetup = { ...snapshot.isComplexSetup };\r\n        this.data.loadSnapshot(snapshot.data);\r\n        this.board = snapshot.board.map((row) => [...row]);\r\n        this.pregenerateAttacks();\r\n        this.runComplexLegalityEvaluationChecks();\r\n    }\r\n    createClone() {\r\n        let targetObject = copyClass(this.__baseClass, Board);\r\n        targetObject.board = this.board.map(a => [...a]); // PieceStrings are immutable\r\n        targetObject.isComplexSetup = Object.assign({}, this.isComplexSetup);\r\n        targetObject.preGeneratedAttacks = createTupleFromCallback(createBasePreGeneratedAttacks, totalPlayers);\r\n        targetObject.data = this.data.createClone();\r\n        targetObject = decorateClassWithVariants(targetObject, Board, copyVariantRules(this.__baseClass.variantRules.boardDecorators));\r\n        targetObject.data.injectBoard(targetObject);\r\n        targetObject.data = decorateClassWithVariants(targetObject.data, FENData, copyVariantRules(this.__baseClass.variantRules.fenDataDecorators));\r\n        const presumedPieceLetters = new Set();\r\n        let letter;\r\n        for (letter in this.controls) {\r\n            if (Object.prototype.hasOwnProperty.call(this.controls, letter)) {\r\n                presumedPieceLetters.add(letter);\r\n            }\r\n        }\r\n        targetObject.initPieceControls(presumedPieceLetters);\r\n        targetObject.pregenerateAttacks();\r\n        return targetObject;\r\n    }\r\n    /*---------------------------------- INITIALIZATION -----------------------------------------*/\r\n    /*-------------------------------------------------------------------------------------------*/\r\n    /*------------------------------------- UTILITIES -------------------------------------------*/\r\n    isKingInCheck(baseColor, fenRoyal = this.data.fenOptions.tag(\"royal\")) {\r\n        const royal = fenRoyal[baseColor];\r\n        if (!royal || this.data.fenOptions.tag(\"dead\")[baseColor])\r\n            return false;\r\n        const coordinates = royal;\r\n        return !!(this.preGeneratedAttacks[baseColor].slidingPieces[coordinates[0]][coordinates[1]]\r\n            || this.preGeneratedAttacks[baseColor].hoppingPieces[coordinates[0]][coordinates[1]]);\r\n    }\r\n    getPlayerPieces() {\r\n        const playerPieces = [[], [], [], []];\r\n        for (let i = 0; i < boardDimension; i++) {\r\n            for (let j = 0; j < boardDimension; j++) {\r\n                const square = this.board[i][j];\r\n                if (square.isEmpty())\r\n                    continue;\r\n                const color = square.color;\r\n                if (color !== deadColorIndex)\r\n                    playerPieces[color].push([i, j]);\r\n            }\r\n        }\r\n        return playerPieces;\r\n    }\r\n    getCheckmatesAndStalemates() {\r\n        const dead = this.data.fenOptions.tag(\"dead\"), royal = this.data.fenOptions.tag(\"royal\");\r\n        const kingChecks = createTuple(false, totalPlayers);\r\n        const legalMoves = createTuple(false, totalPlayers);\r\n        const playerPieces = this.getPlayerPieces();\r\n        legalMoves[this.data.sideToMove] = true;\r\n        for (const color of colors) {\r\n            if (dead[color])\r\n                continue;\r\n            const playerArmy = playerPieces[color];\r\n            if (this.isKingInCheck(color)) {\r\n                kingChecks[color] = true;\r\n            }\r\n            for (const piece of playerArmy) {\r\n                if (this.getLegalMoves(piece[0], piece[1], color).length) {\r\n                    legalMoves[color] = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!legalMoves[color]) {\r\n                if (this.preGeneratedAttacks[color].pieceDrops.pawn.length || this.preGeneratedAttacks[color].pieceDrops.piece.length) {\r\n                    legalMoves[color] = true;\r\n                }\r\n            }\r\n        }\r\n        const kingCaptures = royal.map((r, i) => !dead[i] && r\r\n            ? this.board[r[0]][r[1]].isEmpty() || this.board[r[0]][r[1]].color !== i : false);\r\n        return {\r\n            checkmates: legalMoves.map((move, i) => kingCaptures[i] || (!move && kingChecks[i])),\r\n            stalemates: legalMoves.map((move, i) => !move && !kingChecks[i]),\r\n            checks: kingChecks\r\n        };\r\n    }\r\n    runComplexLegalityEvaluationChecks() {\r\n        if (this.isComplexSetup.hasComplexRules)\r\n            return;\r\n        for (let i = 0; i < 14; i++) {\r\n            for (let j = 0; j < 14; j++) {\r\n                const square = this.board[i][j];\r\n                if (square.isPiece() && pieceControlConfigSettings[square.piece].moveGenerationSettings.isComplex) {\r\n                    this.isComplexSetup.hasComplexPieces = true;\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    getCurrentChecks(sideToMove = this.data.sideToMove) {\r\n        const dead = this.data.fenOptions.tag(\"dead\"), resigned = this.data.fenOptions.tag(\"resigned\"), royal = this.data.fenOptions.tag(\"royal\");\r\n        const playerRoyals = royal.map((r, i) => r && !dead[i] && !resigned[i] ? r : null);\r\n        const attackingCoordinates = createTupleFromCallback(() => [], totalPlayers);\r\n        for (const [startingCoordinate, attackList] of this.preGeneratedAttacks[sideToMove].pieceMovements) {\r\n            for (const attack of attackList) {\r\n                for (const color of colors) {\r\n                    if (color === sideToMove)\r\n                        continue;\r\n                    const royal = playerRoyals[color];\r\n                    if (royal && compareCoordinates(royal, attack.move)) {\r\n                        attackingCoordinates[color].push(startingCoordinate);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return attackingCoordinates;\r\n    }\r\n    /*------------------------------------- UTILITIES -------------------------------------------*/\r\n    /*-------------------------------------------------------------------------------------------*/\r\n    /*---------------------------------------- API ----------------------------------------------*/\r\n    makeMove(move, ignoreNextMoves = false) {\r\n        let returnValues;\r\n        const sideToMove = this.data.sideToMove, pregeneratedAttacks = this.preGeneratedAttacks;\r\n        for (let i = 0; i < move.length; i++) {\r\n            if (i === move.length - 1) {\r\n                returnValues = this.data.affectOptions(move[i], {\r\n                    ignoreCheckmateChecks: ignoreNextMoves, ignoreNextTurn: false\r\n                });\r\n            }\r\n            else {\r\n                this.data.affectOptions(move[i], {\r\n                    ignoreCheckmateChecks: ignoreNextMoves, ignoreNextTurn: true\r\n                });\r\n            }\r\n        }\r\n        this.runComplexLegalityEvaluationChecks();\r\n        if (ignoreNextMoves)\r\n            return returnValues;\r\n        const path = this.moves.currentMove.slice();\r\n        path[path.length - 1]++;\r\n        this.moves.currentMove = this.moves.setNewMove({\r\n            move: createBaseMoveWrapper({ path, moveData: move }),\r\n            snapshot: {\r\n                boardSnapshot: this.createSnapshot(),\r\n                pregeneratedAttacks: pregeneratedAttacks[sideToMove]\r\n            },\r\n            fenDataString: this.data.constructPreliminaryHashString()\r\n        });\r\n        if (this.data.gameOver || this.data.getRealPlayers() === 1)\r\n            return returnValues;\r\n        if (returnValues.checkmates[this.data.sideToMove]) {\r\n            returnValues = this.makeMove([{ type: InternalMoveSignature.TeamsCheckmate }], true);\r\n        }\r\n        else if (returnValues.stalemates[this.data.sideToMove]) {\r\n            returnValues = this.makeMove([{ type: InternalMoveSignature.Stalemate }]);\r\n        }\r\n        return returnValues;\r\n    }\r\n    pregenerateAttacks(exclusiveSideToMoveGeneration = false) {\r\n        const royal = this.data.fenOptions.tag(\"royal\");\r\n        this.preGeneratedAttacks = createTupleFromCallback(createBasePreGeneratedAttacks, totalPlayers);\r\n        this.getPlayerPieces().forEach((army, armyColor) => {\r\n            if (exclusiveSideToMoveGeneration !== false && exclusiveSideToMoveGeneration !== armyColor)\r\n                return;\r\n            const preGeneratedAttacks = this.preGeneratedAttacks[armyColor];\r\n            for (const coordinate of army) {\r\n                const square = this.board[coordinate[0]][coordinate[1]];\r\n                if (!square.isPiece())\r\n                    continue;\r\n                const color = square.color;\r\n                const letter = square.piece;\r\n                const controlBuilder = this.controls[letter]().setColor(color)\r\n                    .setCoordinates(coordinate[0], coordinate[1]).setBoard(this.board);\r\n                const setting = pieceControlConfigSettings[square.piece];\r\n                const resultingMoves = [];\r\n                let control = controlBuilder.setBaseImmunePieces(this.gameType.getBaseColors(color)).constructPieceControl();\r\n                resultingMoves.push(...control.getPseudoLegalMoves());\r\n                control = controlBuilder.setBaseImmunePieces(baseImmunes).constructPieceControl();\r\n                if (setting.moveGenerationSettings.isJumping) {\r\n                    const attacks = control.rayGenJumpingAttacks();\r\n                    for (const { move: attack } of attacks) {\r\n                        for (const color of colors) {\r\n                            if (color === armyColor)\r\n                                continue;\r\n                            const preGeneratedAttacks = this.preGeneratedAttacks[color];\r\n                            preGeneratedAttacks.hoppingPieces[attack[0]][attack[1]]++;\r\n                            preGeneratedAttacks.hoppingPieceLines.push([coordinate, attack]);\r\n                            const l = preGeneratedAttacks.attackingColors[attack[0]][attack[1]];\r\n                            if (~l && preGeneratedAttacks.attackingColors[attack[0]][attack[1]] !== color + 1) {\r\n                                preGeneratedAttacks.attackingColors[attack[0]][attack[1]] = (l === 0 ? 1 + color : -1);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (setting.moveGenerationSettings.isSliding) {\r\n                    const attacks = control.rayGenSlidingAttacks();\r\n                    for (const attack of attacks) {\r\n                        for (const color of colors) {\r\n                            if (color === armyColor)\r\n                                continue;\r\n                            const preGeneratedAttacks = this.preGeneratedAttacks[color];\r\n                            for (const { move: subAttack } of attack) {\r\n                                preGeneratedAttacks.slidingPieces[subAttack[0]][subAttack[1]]++;\r\n                                const l = preGeneratedAttacks.attackingColors[subAttack[0]][subAttack[1]];\r\n                                if (~l && preGeneratedAttacks.attackingColors[subAttack[0]][subAttack[1]] !== color + 1) {\r\n                                    preGeneratedAttacks.attackingColors[subAttack[0]][subAttack[1]] = (l === 0 ? 1 + color : -1);\r\n                                }\r\n                            }\r\n                            if (attack.length !== 0) {\r\n                                preGeneratedAttacks.slidingPiecesLines.push([coordinate, attack.map(m => m.move)]);\r\n                            }\r\n                            else {\r\n                                const coordinateArray = [];\r\n                                preGeneratedAttacks.slidingPiecesLines.push([coordinate, coordinateArray]);\r\n                            }\r\n                        }\r\n                    }\r\n                    const rayGen = control.rayGenSlidingAttacks(AttackType.RayTraceLimited);\r\n                    for (const attack of rayGen) {\r\n                        for (const color of colors) {\r\n                            if (color === armyColor)\r\n                                continue;\r\n                            const preGeneratedAttacks = this.preGeneratedAttacks[color];\r\n                            if (attack.length !== 0) {\r\n                                let isRoyalOnLine = false;\r\n                                const resultingAttack = [];\r\n                                for (const { move } of attack) {\r\n                                    resultingAttack.push(move);\r\n                                    if (isRoyalOnLine) {\r\n                                        preGeneratedAttacks.slidingPieces[move[0]][move[1]]++;\r\n                                    }\r\n                                    else if (compareCoordinates(royal[color] ?? [-1, -1], move)) {\r\n                                        isRoyalOnLine = true;\r\n                                    }\r\n                                }\r\n                                preGeneratedAttacks.slidingPiecesRayTracing.push([coordinate, attack.map(m => m.move)]);\r\n                            }\r\n                            else {\r\n                                preGeneratedAttacks.slidingPiecesLines.push([coordinate, []]);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                preGeneratedAttacks.pieceMovements.set(stringifyCoordinate(coordinate), resultingMoves);\r\n            }\r\n            preGeneratedAttacks.pieceDrops.piece = this.getDroppingMoves(createPieceFromData(armyColor, nonPlayablePieces.wall));\r\n            preGeneratedAttacks.pieceDrops.pawn = this.getDroppingMoves(createPieceFromData(armyColor, pawnPieceString.piece));\r\n        });\r\n    }\r\n    isSetupComplex() { return this.isComplexSetup.hasComplexPieces || this.isComplexSetup.hasComplexRules || this.data.isComplexEvaluation(); }\r\n    isTheMoveLegal(color, moveData, isSeirawanDrop = false) {\r\n        const royals = this.data.fenOptions.tag(\"royal\");\r\n        const { startCoordinates: [pieceI, pieceJ], endCoordinates: [attackI, attackJ] } = moveData;\r\n        const royal = royals[color];\r\n        if (!this.board[attackI][attackJ].isEmpty() && royal && attackI === royal[0] && attackJ === royal[1])\r\n            return false;\r\n        if (this.isSetupComplex()) {\r\n            const snapshot = this.createSnapshot();\r\n            const moveArray = [{\r\n                    startCoordinates: [pieceI, pieceJ],\r\n                    endCoordinates: [attackI, attackJ]\r\n                }];\r\n            if (isSeirawanDrop)\r\n                moveArray.push({ piece: wallPieceString, endCoordinates: [pieceI, pieceJ] });\r\n            const { checks, checkmates } = this.makeMove(moveArray, true);\r\n            let isKingInCheck = checks[color] || checkmates[color];\r\n            if (!isKingInCheck) {\r\n                this.pregenerateAttacks(color);\r\n                isKingInCheck = this.isKingInCheck(color);\r\n            }\r\n            this.loadSnapshot(snapshot);\r\n            return !isKingInCheck;\r\n        }\r\n        else {\r\n            const [royalI, royalJ] = royal ?? [null, null];\r\n            const preGeneratedAttacks = this.preGeneratedAttacks[color];\r\n            if (royalI === null)\r\n                return true;\r\n            const isRoyalMove = royalI === pieceI && royalJ === pieceJ;\r\n            const attackers = preGeneratedAttacks.hoppingPieces[royalI][royalJ] +\r\n                preGeneratedAttacks.slidingPieces[royalI][royalJ];\r\n            const targetSafety = preGeneratedAttacks.slidingPieces[attackI][attackJ]\r\n                + preGeneratedAttacks.hoppingPieces[attackI][attackJ] === 0;\r\n            const legalitySettings = {\r\n                canKingCapture: undefined\r\n            };\r\n            for (const kingCaptureColor of colors) {\r\n                const royal = royals[kingCaptureColor];\r\n                if (kingCaptureColor !== color && royal && royal[0] === attackI && royal[1] === attackJ) {\r\n                    const royalDefendedSquare = preGeneratedAttacks.attackingColors[royal[1]][royal[0]];\r\n                    if ((royalDefendedSquare === kingCaptureColor + 1 || royalDefendedSquare === 0)\r\n                        && (isRoyalMove || preGeneratedAttacks.attackingColors[royalI][royalJ] === kingCaptureColor + 1)) {\r\n                        legalitySettings.canKingCapture = kingCaptureColor + 1;\r\n                    }\r\n                }\r\n            }\r\n            if (!this.gameType.isFFA() && legalitySettings.canKingCapture !== undefined)\r\n                return true;\r\n            for (const [attackingPiece, attackLine] of preGeneratedAttacks.slidingPiecesRayTracing) {\r\n                let isPieceUnderAttack = false, isRoyalUnderAttack = false, isTheTargetSquarePinListed = false;\r\n                for (const [attackedX, attackedY] of attackLine) {\r\n                    if (!isPieceUnderAttack && attackedX === pieceI && attackedY === pieceJ)\r\n                        isPieceUnderAttack = true;\r\n                    else if (!isTheTargetSquarePinListed && !isRoyalUnderAttack &&\r\n                        attackedX === attackI && attackedY === attackJ)\r\n                        isTheTargetSquarePinListed = true;\r\n                    if (!isRoyalUnderAttack && attackedX === royalI && attackedY === royalJ)\r\n                        isRoyalUnderAttack = true;\r\n                    if (isRoyalMove) {\r\n                        if (isRoyalUnderAttack && attackedX === attackI && attackedY === attackJ) {\r\n                            if (legalitySettings.canKingCapture && legalitySettings.canKingCapture > 0 && this.board[attackedX][attackedY].color + 1 === legalitySettings.canKingCapture)\r\n                                continue;\r\n                            return false;\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (isPieceUnderAttack && isRoyalUnderAttack && !compareCoordinates(attackingPiece, moveData.endCoordinates) && !isTheTargetSquarePinListed) {\r\n                            if (legalitySettings.canKingCapture && legalitySettings.canKingCapture > 0 && this.board[attackedX][attackedY].color + 1 === legalitySettings.canKingCapture)\r\n                                continue;\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (attackers > 1) {\r\n                return isRoyalMove ? targetSafety || Boolean(legalitySettings.canKingCapture) : Boolean(legalitySettings.canKingCapture);\r\n            }\r\n            else if (attackers === 1) {\r\n                if (!isRoyalMove) {\r\n                    if (preGeneratedAttacks.hoppingPieces[royalI][royalJ] === 1) {\r\n                        for (const [attackingPiece, attackCoordinates] of preGeneratedAttacks.hoppingPieceLines) {\r\n                            if (attackCoordinates[0] === royalI && attackCoordinates[1] === royalJ\r\n                                && attackingPiece[0] === attackI && attackingPiece[1] === attackJ) {\r\n                                return true;\r\n                            }\r\n                        }\r\n                        return Boolean(legalitySettings.canKingCapture);\r\n                    }\r\n                    else {\r\n                        for (const [attackingPiece, attackLine] of preGeneratedAttacks.slidingPiecesLines) {\r\n                            let isRoyalUnderAttack = false, isTheTargetSquareBlocked = false;\r\n                            for (const [attackedX, attackedY] of attackLine) {\r\n                                if (!isRoyalUnderAttack && attackedX === royalI && attackedY === royalJ)\r\n                                    isRoyalUnderAttack = true;\r\n                                else if (!isTheTargetSquareBlocked && !isRoyalUnderAttack &&\r\n                                    attackedX === attackI && attackedY === attackJ)\r\n                                    isTheTargetSquareBlocked = true;\r\n                                if (isRoyalUnderAttack && !compareCoordinates(attackingPiece, moveData.endCoordinates) && !isTheTargetSquareBlocked) {\r\n                                    if (legalitySettings.canKingCapture && legalitySettings.canKingCapture > 0 && this.board[attackedX][attackedY].color + 1 === legalitySettings.canKingCapture)\r\n                                        continue;\r\n                                    return Boolean(legalitySettings.canKingCapture);\r\n                                }\r\n                            }\r\n                        }\r\n                        return true;\r\n                    }\r\n                }\r\n                else {\r\n                    return targetSafety || Boolean(legalitySettings.canKingCapture);\r\n                }\r\n            }\r\n            else {\r\n                return isRoyalMove ? targetSafety || Boolean(legalitySettings.canKingCapture) : true;\r\n            }\r\n        }\r\n    }\r\n    getCastlingMoves(parameters) {\r\n        const { i, j, baseColor } = parameters;\r\n        const specialMoves = [];\r\n        const royal = this.data.fenOptions.tag(\"royal\")[baseColor];\r\n        if (royal && royal[0] === i && royal[1] === j) {\r\n            if (this.data.fenOptions.isKingsideCastlingAvailable(baseColor, this)) {\r\n                specialMoves.push({\r\n                    startCoordinates: [i, j],\r\n                    endCoordinates: this.data.fenOptions.getKingsideCastlingEndCoordinate(baseColor),\r\n                    specialType: SpecialMove.CastlingKingside\r\n                });\r\n            }\r\n            if (this.data.fenOptions.isQueensideCastlingAvailable(baseColor, this)) {\r\n                specialMoves.push({\r\n                    startCoordinates: [i, j],\r\n                    endCoordinates: this.data.fenOptions.getQueensideCastlingEndCoordinate(baseColor),\r\n                    specialType: SpecialMove.CastlingQueenside\r\n                });\r\n            }\r\n        }\r\n        return specialMoves;\r\n    }\r\n    getEnPassantMoves(parameters) {\r\n        const { i, j, baseColor, pieceLetter } = parameters;\r\n        const specialMoves = [];\r\n        if (pieceControlConfigSettings[pieceLetter].moveGenerationSettings.isPawn) {\r\n            const enPassantCaptures = this.data.fenOptions.getAvailableEnPassantCaptures(baseColor);\r\n            const pawnAttacks = this.controls[pieceLetter]()\r\n                .setBaseImmunePieces(this.gameType.getBaseColors(baseColor))\r\n                .setBoard(this.board).setCoordinates(i, j).setColor(baseColor)\r\n                .constructPieceControl().rayGenJumpingAttacks();\r\n            if (enPassantCaptures.length !== 0) {\r\n                for (const attack of pawnAttacks) {\r\n                    for (const enP of enPassantCaptures) {\r\n                        if (compareCoordinates(attack.move, enP)) {\r\n                            const snapshot = this.createSnapshot();\r\n                            const move = [{\r\n                                    startCoordinates: [i, j],\r\n                                    endCoordinates: attack.move,\r\n                                    specialType: SpecialMove.EnPassant,\r\n                                    isIrreversible: attack.irreversible\r\n                                }];\r\n                            this.makeMove(move, true);\r\n                            this.pregenerateAttacks();\r\n                            if (!this.isKingInCheck(baseColor))\r\n                                specialMoves.push(move[0]);\r\n                            this.loadSnapshot(snapshot);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return specialMoves;\r\n    }\r\n    getSpecialMoves(parameters) {\r\n        return [...this.getCastlingMoves(parameters), ...this.getEnPassantMoves(parameters)];\r\n    }\r\n    getLegalMoves(i, j, baseColor = this.data.sideToMove, isSeirawanDrop = false) {\r\n        const pieceString = this.board[i]?.[j], royal = this.data.fenOptions.tag(\"royal\")[baseColor];\r\n        if (pieceString.isPiece()) {\r\n            const color = pieceString.color;\r\n            if (color !== baseColor)\r\n                return [];\r\n            const pseudoLegalMoves = this.preGeneratedAttacks[color].pieceMovements.get(stringifyCoordinate([i, j]));\r\n            assertNonUndefined(pseudoLegalMoves);\r\n            const specialMoves = this.getSpecialMoves({ i, j, baseColor, pieceLetter: pieceString.piece });\r\n            return [...pseudoLegalMoves.map(generatedMove => {\r\n                    const moveData = {\r\n                        startCoordinates: [i, j],\r\n                        endCoordinates: generatedMove.move,\r\n                        isIrreversible: generatedMove.irreversible\r\n                    };\r\n                    if (generatedMove.move[2]) {\r\n                        moveData.promotion = generatedMove.move[2].split(\"\").map(piece => createPieceFromData(color, piece));\r\n                    }\r\n                    return moveData;\r\n                }).filter(m => {\r\n                    const capturedPieces = this.data.getCapturedPieces(m);\r\n                    const isKingCapture = royal && (capturedPieces.find((c) => royal[0] === c[0] && royal[1] === c[1]));\r\n                    return this.isTheMoveLegal(color, m, isSeirawanDrop) && !isKingCapture;\r\n                }), ...specialMoves];\r\n        }\r\n        else {\r\n            return [];\r\n        }\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    getDroppingMoves(_piece, _sideToMove = this.data.sideToMove) {\r\n        return [];\r\n    }\r\n    getAllowedInternalMoves(sideToMove = this.data.sideToMove) {\r\n        const currentMoves = [InternalMoveSignature.DrawByAgreement];\r\n        const currentSnapshot = this.createSnapshot();\r\n        this.makeMove([{ type: InternalMoveSignature.Resign }], true);\r\n        const maximum = Math.max(...this.data.points);\r\n        const pointIndexes = this.data.points.reduce((p, n, i) => n === maximum ? [...p, i] : p, []);\r\n        this.loadSnapshot(currentSnapshot);\r\n        if (pointIndexes.length === 1 && pointIndexes[0] === sideToMove) {\r\n            currentMoves.push(InternalMoveSignature.ClaimWin);\r\n        }\r\n        else {\r\n            currentMoves.push(InternalMoveSignature.Resign, InternalMoveSignature.Timeout);\r\n        }\r\n        return currentMoves.map(type => ({ type }));\r\n    }\r\n}\r\n","import { createTupleFromCallback, verifyTupleType } from \"../../../baseTypes\";\r\nimport { initializeBoardSquares } from \"../../BaseInterfaces\";\r\nimport { totalPlayers, VariantType } from \"../GameInformation/GameData\";\r\nimport { verifyNumericColor } from \"../GameInformation/GameUnits/GameUnits\";\r\nexport var DisplaySettings;\r\n(function (DisplaySettings) {\r\n    DisplaySettings[DisplaySettings[\"Highlighted\"] = 0] = \"Highlighted\";\r\n    DisplaySettings[DisplaySettings[\"Fogged\"] = 1] = \"Fogged\";\r\n    DisplaySettings[DisplaySettings[\"Ghosted\"] = 2] = \"Ghosted\";\r\n    DisplaySettings[DisplaySettings[\"Blindfolded\"] = 3] = \"Blindfolded\";\r\n    DisplaySettings[DisplaySettings[\"PieceFacesCenter\"] = 4] = \"PieceFacesCenter\";\r\n})(DisplaySettings || (DisplaySettings = {}));\r\nconst baseTeams = [true, false, true, false];\r\nexport const stringifyCoordinate = (coordinate) => `${coordinate[0]}:${coordinate[1]}`;\r\nexport const unstringifyCoordinate = (coordinate) => {\r\n    const result = coordinate.split(\":\").map(v => Number(v));\r\n    if (verifyTupleType(result, 2) && result.every(n => !Number.isNaN(n))) {\r\n        return result;\r\n    }\r\n    else\r\n        throw new Error(`Unexpected stringified coordinate: ${coordinate}`);\r\n};\r\nexport const createGameTypeSettings = () => ({\r\n    type: VariantType.FFA,\r\n    teamSettings: {\r\n        firstTeamColors: baseTeams.map(e => e),\r\n        secondTeamColors: baseTeams.map(e => !e)\r\n    },\r\n    getBaseColors(color) {\r\n        if (this.isFFA()) {\r\n            return createTupleFromCallback((_, i) => i === color, totalPlayers);\r\n        }\r\n        else {\r\n            return this.teamSettings.firstTeamColors[color] ? this.teamSettings.firstTeamColors : this.teamSettings.secondTeamColors;\r\n        }\r\n    },\r\n    isFFA() {\r\n        return this.type === VariantType.FFA || this.type === VariantType.Solo;\r\n    },\r\n    isSameTeam(colorA, colorB) {\r\n        if (colorA === colorB)\r\n            return true;\r\n        if (this.isFFA()) {\r\n            return false;\r\n        }\r\n        else {\r\n            return this.teamSettings.firstTeamColors[colorA]\r\n                ? this.teamSettings.firstTeamColors[colorA] && this.teamSettings.firstTeamColors[colorA]\r\n                : this.teamSettings.secondTeamColors[colorA] && this.teamSettings.secondTeamColors[colorB];\r\n        }\r\n    },\r\n    getTeammateColor(color) {\r\n        if (this.isFFA())\r\n            return color;\r\n        const teammateIndex = this.teamSettings.firstTeamColors[color]\r\n            ? this.teamSettings.firstTeamColors.map((b, i) => b && i !== color).indexOf(true)\r\n            : this.teamSettings.secondTeamColors.map((b, i) => b && i !== color).indexOf(true);\r\n        return verifyNumericColor(teammateIndex) ? teammateIndex : color;\r\n    }\r\n});\r\nexport const createComplexMoveLegalityTracker = () => ({\r\n    hasComplexPieces: false,\r\n    hasComplexRules: false,\r\n});\r\nexport const createBasePreGeneratedAttacks = () => {\r\n    return {\r\n        hoppingPieces: initializeBoardSquares(() => 0),\r\n        slidingPieces: initializeBoardSquares(() => 0),\r\n        hoppingPieceLines: [],\r\n        slidingPiecesLines: [],\r\n        slidingPiecesRayTracing: [],\r\n        attackingColors: initializeBoardSquares(() => 0),\r\n        pieceMovements: new Map(),\r\n        pieceDrops: {\r\n            pawn: [], piece: []\r\n        },\r\n        variantRuleCache: {}\r\n    };\r\n};\r\nexport const compareCoordinates = (coordinate1, coordinate2) => coordinate1[0] === coordinate2[0] && coordinate1[1] === coordinate2[1];\r\n","import { isVerticalPlacement } from \"../../BaseInterfaces\";\r\nimport { createDefaultArmyDeathSettings, createDefaultFENEffectSettings, getNeighboringSideToMove } from \"./FENDataInterface\";\r\nimport { InternalMoveSignature, SpecialMove, verifyDroppingMove, verifyInternalMove, verifyStandardMove } from \"../MoveTree/MoveTreeInterface\";\r\nimport { createTuple, throwOnNever } from \"../../../baseTypes\";\r\nimport { colors, getPlayerNameFromColor, totalPlayers, verifyDrawingTermination, verifyWinningTermination } from \"../GameInformation/GameData\";\r\nimport { createPieceFromData, emptyPieceString, deadColorIndex } from \"../GameInformation/GameUnits/PieceString\";\r\nimport { pieceControlConfigSettings } from \"@moveGeneration/PieceControl/PieceControlInterface\";\r\nimport { compareCoordinates } from \"../Board/BoardInterface\";\r\nimport { nonPlayablePieces, verifyNumericColor } from \"../GameInformation/GameUnits/GameUnits\";\r\nimport { FENOptions } from \"./FENOptions/FENOptions\";\r\nimport { verifyDynamicFENOptionKey } from \"./FENOptions/FENOptionsTagsInterface\";\r\nconst defaultPointsForMate = 20;\r\nclass FENData {\r\n    points;\r\n    sideToMove;\r\n    fenOptions;\r\n    plyCount;\r\n    board;\r\n    privateGameOver = false;\r\n    __baseClass;\r\n    initDecoratorSettings() { }\r\n    constructor() {\r\n        this.points = [0, 0, 0, 0];\r\n        this.sideToMove = 0;\r\n        this.fenOptions = new FENOptions();\r\n        this.plyCount = 0;\r\n        this.__baseClass = this;\r\n    }\r\n    get gameOver() {\r\n        return this.privateGameOver;\r\n    }\r\n    set gameOver(gameOver) {\r\n        if (gameOver === false || this.privateGameOver === false) {\r\n            this.privateGameOver = gameOver;\r\n        }\r\n    }\r\n    injectBoard(board) {\r\n        this.board = board;\r\n        this.fenOptions.generateCastling(board);\r\n    }\r\n    createClone() {\r\n        const newFENData = new FENData();\r\n        newFENData.fenOptions = this.fenOptions.createClone();\r\n        newFENData.points = [...this.points];\r\n        newFENData.sideToMove = this.sideToMove;\r\n        newFENData.plyCount = this.plyCount;\r\n        return newFENData;\r\n    }\r\n    createSnapshot() {\r\n        return {\r\n            points: [...this.points],\r\n            sideToMove: this.sideToMove,\r\n            fenOptionsSnapshot: this.fenOptions.createSnapshot(),\r\n            plyCount: this.plyCount,\r\n            gameOver: this.gameOver\r\n        };\r\n    }\r\n    loadSnapshot(snapshot) {\r\n        this.fenOptions.loadSnapshot(snapshot.fenOptionsSnapshot);\r\n        this.points = [...snapshot.points];\r\n        this.sideToMove = snapshot.sideToMove;\r\n        this.plyCount = snapshot.plyCount;\r\n        this.privateGameOver = snapshot.gameOver;\r\n    }\r\n    getCapturedPieces(moveData) {\r\n        const pieceString = this.board.board[moveData.endCoordinates[0]][moveData.endCoordinates[1]];\r\n        return pieceString.isEmpty() || pieceString.isDead() ? [] : [[...moveData.endCoordinates]];\r\n    }\r\n    getCastlingPieceEndCoordinates(coordinates, color) {\r\n        return [\r\n            isVerticalPlacement(color)\r\n                ? [coordinates[0], this.fenOptions.getKingsideCastlingTandemPiece(color)]\r\n                : [this.fenOptions.getKingsideCastlingTandemPiece(color), coordinates[1]],\r\n            isVerticalPlacement(color)\r\n                ? [coordinates[0], this.fenOptions.getQueensideCastlingTandemPiece(color)]\r\n                : [this.fenOptions.getQueensideCastlingTandemPiece(color), coordinates[1]],\r\n        ];\r\n    }\r\n    processStandardMove(moveData) {\r\n        const { startCoordinates: [startI, startJ], endCoordinates: [endI, endJ], promotion } = moveData;\r\n        const endPiece = this.board.board[endI][endJ];\r\n        const piece = promotion?.[0] ?? this.board.board[startI][startJ];\r\n        const capturedPieces = this.getCapturedPieces(moveData);\r\n        this.board.board[endI][endJ] = piece;\r\n        this.board.board[startI][startJ] = emptyPieceString;\r\n        for (const coordinate of capturedPieces) {\r\n            if (compareCoordinates(coordinate, moveData.startCoordinates)) {\r\n                this.board.board[endI][endJ] = emptyPieceString;\r\n            }\r\n            else if (!compareCoordinates(coordinate, moveData.endCoordinates)) {\r\n                this.board.board[coordinate[0]][coordinate[1]] = emptyPieceString;\r\n            }\r\n        }\r\n        const [kingsidePiece, queensidePiece] = this.getCastlingPieceEndCoordinates(moveData.startCoordinates, this.sideToMove);\r\n        if (\"specialType\" in moveData) {\r\n            const type = moveData.specialType;\r\n            switch (type) {\r\n                case SpecialMove.CastlingKingside: {\r\n                    const secondKPiece = isVerticalPlacement(this.sideToMove)\r\n                        ? this.board.board[startI][this.fenOptions.getKingsideCastlingTandemPiece(this.sideToMove)]\r\n                        : this.board.board[this.fenOptions.getKingsideCastlingTandemPiece(this.sideToMove)][startJ];\r\n                    const [kI, kJ] = this.fenOptions.getKingsideCastlingPieceEndCoordinate(this.sideToMove);\r\n                    this.board.board[kI][kJ] = secondKPiece;\r\n                    this.board.board[kingsidePiece[0]][kingsidePiece[1]] = emptyPieceString;\r\n                    break;\r\n                }\r\n                case SpecialMove.CastlingQueenside: {\r\n                    const secondQPiece = isVerticalPlacement(this.sideToMove)\r\n                        ? this.board.board[startI][this.fenOptions.getQueensideCastlingTandemPiece(this.sideToMove)]\r\n                        : this.board.board[this.fenOptions.getQueensideCastlingTandemPiece(this.sideToMove)][startJ];\r\n                    const [qI, qJ] = this.fenOptions.getQueensideCastlingPieceEndCoordinate(this.sideToMove);\r\n                    this.board.board[qI][qJ] = secondQPiece;\r\n                    this.board.board[queensidePiece[0]][queensidePiece[1]] = emptyPieceString;\r\n                    break;\r\n                }\r\n                default:\r\n                    if (type === undefined || !(type in SpecialMove)) {\r\n                        console.error(`Unknown special move constant: ${String(type)}`);\r\n                    }\r\n            }\r\n        }\r\n        const castleKingside = this.fenOptions.tag(\"castleKingside\"), castleQueenside = this.fenOptions.tag(\"castleQueenside\"), royal = this.fenOptions.tag(\"royal\");\r\n        this.fenOptions.setTag(\"royal\", this.fenOptions.tag(\"royal\").map((r, i) => {\r\n            if (r) {\r\n                if (r[0] === startI && r[1] === startJ) {\r\n                    castleKingside[i] = false;\r\n                    castleQueenside[i] = false;\r\n                    return [endI, endJ];\r\n                }\r\n                else\r\n                    return [...r];\r\n            }\r\n            else\r\n                return null;\r\n        }));\r\n        for (const color of colors) {\r\n            const royalPiece = royal[color];\r\n            if (!royalPiece)\r\n                continue;\r\n            if (compareCoordinates(royalPiece, moveData.startCoordinates)) {\r\n                castleKingside[color] = false;\r\n                castleQueenside[color] = false;\r\n                break;\r\n            }\r\n            else if (compareCoordinates(kingsidePiece, moveData.startCoordinates)) {\r\n                castleKingside[color] = false;\r\n                break;\r\n            }\r\n            else if (compareCoordinates(queensidePiece, moveData.startCoordinates)) {\r\n                castleQueenside[color] = false;\r\n                break;\r\n            }\r\n        }\r\n        return { endPiece: endPiece.isEmpty() ? [] : [endPiece] };\r\n    }\r\n    spreadPointsBetweenPlayersEvenly() {\r\n        const resigned = this.fenOptions.tag(\"resigned\"), dead = this.fenOptions.tag(\"dead\");\r\n        const realPlayers = resigned.reduce((p, n, i) => p + Number(n || dead[i]), 0);\r\n        const individualPoints = Math.ceil(this.obtainPointsForMate() / realPlayers);\r\n        for (const color of colors) {\r\n            if (!dead[color]) {\r\n                this.assignPoints(color, individualPoints);\r\n            }\r\n        }\r\n    }\r\n    branchBetweenResignationMoves(move, sideToMove) {\r\n        const playerName = getPlayerNameFromColor(sideToMove).toUpperCase();\r\n        switch (move) {\r\n            case InternalMoveSignature.Resign:\r\n                this.gameOver = `${playerName} RESIGNED!`;\r\n                break;\r\n            case InternalMoveSignature.Timeout:\r\n                this.gameOver = `${playerName} FORFEITS ON TIME!`;\r\n                break;\r\n            case InternalMoveSignature.ClaimWin:\r\n                this.gameOver = `${playerName} CLAIMED THE WIN!`;\r\n                break;\r\n            default:\r\n                throwOnNever(move);\r\n        }\r\n    }\r\n    processInternalMove(internalMove) {\r\n        const resigned = this.fenOptions.tag(\"resigned\"), dead = this.fenOptions.tag(\"dead\");\r\n        const stalemates = createTuple(false, totalPlayers);\r\n        const insufficientMaterial = this.board.insufficientMaterialModule?.(this.board)?.every((b, i) => {\r\n            if (i === this.sideToMove) {\r\n                return b;\r\n            }\r\n            else {\r\n                return b || dead[i];\r\n            }\r\n        });\r\n        switch (internalMove.type) {\r\n            case InternalMoveSignature.Stalemate:\r\n                dead[this.sideToMove] = true;\r\n                stalemates[this.sideToMove] = true;\r\n                break;\r\n            case InternalMoveSignature.Resign:\r\n            case InternalMoveSignature.Timeout:\r\n                if (insufficientMaterial) {\r\n                    this.assignGeneralTermination(\"Timeout vs Insufficient Material\");\r\n                }\r\n            // * Fallthrough\r\n            case InternalMoveSignature.ClaimWin: {\r\n                resigned[this.sideToMove] = true;\r\n                this.turnPiecesDead(this.sideToMove, { ...createDefaultArmyDeathSettings(), excludeRoyals: true, doNotSetDead: true });\r\n                const deadPlayers = dead.map((d, i) => d || resigned[i]).filter(Boolean);\r\n                let isResignationOver = deadPlayers.length === totalPlayers - 1;\r\n                if (insufficientMaterial) {\r\n                    this.spreadPointsBetweenPlayersEvenly();\r\n                }\r\n                else if (deadPlayers.length === totalPlayers - 1) {\r\n                    const alivePlayer = deadPlayers.findIndex(d => !d);\r\n                    if (verifyNumericColor(alivePlayer)) {\r\n                        this.assignPoints(alivePlayer, this.countTotalPointsOnBoard()\r\n                            .reduce((p, n, i) => p + (i === alivePlayer ? n : 0), 0));\r\n                        isResignationOver = true;\r\n                    }\r\n                }\r\n                else if (!this.board.gameType.isFFA()) {\r\n                    isResignationOver = true;\r\n                }\r\n                if (isResignationOver) {\r\n                    this.branchBetweenResignationMoves(internalMove.type, this.sideToMove);\r\n                }\r\n                break;\r\n            }\r\n            case InternalMoveSignature.DrawByAgreement:\r\n                this.gameOver = \"- AGREED.\";\r\n                break;\r\n            case InternalMoveSignature.Pass:\r\n                break;\r\n            case InternalMoveSignature.TeamsCheckmate: {\r\n                this.gameOver = `CHECKMATE  ${this.getCurrentResult()}`;\r\n                this.turnPiecesDead(this.sideToMove);\r\n                this.turnPiecesDead(this.board.gameType.getTeammateColor(this.sideToMove));\r\n                break;\r\n            }\r\n            default:\r\n                throwOnNever(internalMove.type);\r\n        }\r\n        return { stalemates };\r\n    }\r\n    processDroppingMove(move) {\r\n        const bank = this.fenOptions.tag(\"bank\"), areBanksEnabled = this.fenOptions.tag(\"areBanksEnabled\"), setupComplete = this.fenOptions.tag(\"setupComplete\");\r\n        if (!this.board.variantData.duckChess && !areBanksEnabled[this.sideToMove])\r\n            return;\r\n        const playerBank = bank[this.sideToMove];\r\n        const pieceStringReference = [...playerBank.keys()].find(pieceString => pieceString.piece === move.piece.piece);\r\n        if (!pieceStringReference && !this.board.variantData.duckChess && move.piece.piece !== nonPlayablePieces.duck)\r\n            return;\r\n        const safeReference = pieceStringReference ?? move.piece;\r\n        this.board.board[move.endCoordinates[0]][move.endCoordinates[1]] = move.piece;\r\n        if (!setupComplete[this.sideToMove])\r\n            return;\r\n        const bankPieceCount = playerBank.get(safeReference);\r\n        if (bankPieceCount == 1) {\r\n            playerBank.delete(safeReference);\r\n        }\r\n        else if (bankPieceCount) {\r\n            playerBank.set(safeReference, bankPieceCount - 1);\r\n        }\r\n    }\r\n    turnPiecesDead(color, settings = createDefaultArmyDeathSettings()) {\r\n        const royal = this.fenOptions.tag(\"royal\"), dead = this.fenOptions.tag(\"dead\");\r\n        const royalPiece = royal[color];\r\n        if (!settings.doNotSetDead) {\r\n            dead[color] = true;\r\n            royal[color] = null;\r\n        }\r\n        for (const coordinate of this.board.getPlayerPieces()[color]) {\r\n            if (settings.excludeRoyals && royalPiece && compareCoordinates(coordinate, royalPiece))\r\n                continue;\r\n            const piece = this.board.board[coordinate[0]][coordinate[1]].piece;\r\n            if (settings.onlyPawns && !pieceControlConfigSettings[piece].moveGenerationSettings.isPawn)\r\n                continue;\r\n            this.board.board[coordinate[0]][coordinate[1]] =\r\n                createPieceFromData(deadColorIndex, this.board.board[coordinate[0]][coordinate[1]].piece);\r\n        }\r\n    }\r\n    getKingCaptures() {\r\n        const kingCaptures = createTuple(false, totalPlayers);\r\n        for (const color of colors) {\r\n            const royalCoordinate = this.fenOptions.tag(\"royal\")[color];\r\n            if (!royalCoordinate)\r\n                continue;\r\n            const pieceString = this.board.board[royalCoordinate[0]][royalCoordinate[1]];\r\n            if (pieceString.isEmpty() || pieceString.color !== color) {\r\n                kingCaptures[color] = true;\r\n            }\r\n        }\r\n        return kingCaptures;\r\n    }\r\n    processPointsForChecks(currentChecks) {\r\n        const sideToMove = this.sideToMove;\r\n        const updatedChecks = this.board.getCurrentChecks(), playerChecks = createTuple(false, totalPlayers);\r\n        for (const color of colors) {\r\n            for (const coordinate of updatedChecks[color]) {\r\n                if (!currentChecks[color].has(coordinate)) {\r\n                    playerChecks[color] = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        const checkedPlayers = playerChecks.filter(Boolean).length;\r\n        if (checkedPlayers === 2) {\r\n            this.assignPoints(sideToMove, 1);\r\n        }\r\n        else if (checkedPlayers === 3) {\r\n            this.assignPoints(sideToMove, 5);\r\n        }\r\n    }\r\n    affectOptions(move, settings = createDefaultFENEffectSettings()) {\r\n        let moveStalemates;\r\n        let endSquare;\r\n        const currentChecks = this.board.getCurrentChecks().map(arr => new Set(arr));\r\n        if (verifyInternalMove(move)) {\r\n            moveStalemates = this.processInternalMove(move).stalemates;\r\n        }\r\n        else if (verifyStandardMove(move)) {\r\n            endSquare = this.processStandardMove(move).endPiece;\r\n        }\r\n        else if (verifyDroppingMove(move)) {\r\n            this.processDroppingMove(move);\r\n        }\r\n        if (!settings.ignoreCheckmateChecks)\r\n            this.board.pregenerateAttacks();\r\n        const { checkmates, stalemates, checks } = settings.ignoreCheckmateChecks ? {\r\n            checkmates: createTuple(false, totalPlayers), checks: createTuple(false, totalPlayers), stalemates: createTuple(false, totalPlayers)\r\n        } : this.board.getCheckmatesAndStalemates();\r\n        if (moveStalemates) {\r\n            for (let i = 0; i < totalPlayers; i++) {\r\n                if (moveStalemates[i]) {\r\n                    stalemates[i] = true;\r\n                }\r\n            }\r\n        }\r\n        const totalMateSum = checkmates.reduce((p, n) => n ? p + this.obtainPointsForMate() : p, 0);\r\n        const boardAlternations = {\r\n            pointDistribution: {\r\n                checkmatePoints: checkmates.map((_, i) => i === this.sideToMove ? totalMateSum : 0),\r\n                pieceCapturingPoints: createTuple(0, totalPlayers)\r\n            }\r\n        };\r\n        if (endSquare) {\r\n            for (const piece of endSquare) {\r\n                boardAlternations.pointDistribution.pieceCapturingPoints[this.sideToMove] = this.getPointsForPiece(piece);\r\n            }\r\n        }\r\n        const kingCaptures = this.getKingCaptures();\r\n        const dead = this.fenOptions.tag(\"dead\"), resigned = this.fenOptions.tag(\"resigned\");\r\n        if (this.board.gameType.isFFA()) {\r\n            for (const color of colors) {\r\n                if (dead[color] || resigned[color]) {\r\n                    continue;\r\n                }\r\n                if (checkmates[color] || (color === this.sideToMove && stalemates[color])) {\r\n                    this.turnPiecesDead(color);\r\n                    continue;\r\n                }\r\n                this.assignPoints(color, boardAlternations.pointDistribution.checkmatePoints[color]\r\n                    + boardAlternations.pointDistribution.pieceCapturingPoints[color]);\r\n            }\r\n        }\r\n        else {\r\n            for (const color of colors) {\r\n                if (kingCaptures[color]) {\r\n                    this.turnPiecesDead(color);\r\n                    this.assignGeneralTermination(\"King Captured\");\r\n                }\r\n            }\r\n        }\r\n        const realPlayers = this.getRealPlayers();\r\n        const isOver = this.board.gameType.isFFA() ? realPlayers === 1 : realPlayers !== totalPlayers;\r\n        if (isOver)\r\n            this.assignGeneralTermination(\"Checkmate\");\r\n        if (!settings.ignoreNextTurn && !isOver) {\r\n            this.processPointsForChecks(currentChecks);\r\n            const insufficientPieces = this.board.insufficientMaterialModule?.(this.board);\r\n            if (!this.gameOver && insufficientPieces?.every((insufficient, i) => dead[i] || insufficient)) {\r\n                this.gameOver = `INSUFFICIENT MATERIAL  ${this.getCurrentResult()}`;\r\n                this.spreadPointsBetweenPlayersEvenly();\r\n            }\r\n            if (this.getRealPlayers() > 1) {\r\n                this.sideToMove = this.nextTurn();\r\n            }\r\n        }\r\n        return { checkmates, stalemates, checks };\r\n    }\r\n    constructPreliminaryHashString() {\r\n        let builder = '';\r\n        builder += this.sideToMove;\r\n        let key;\r\n        for (key in this.fenOptions.tags) {\r\n            const tag = this.fenOptions.tags[key];\r\n            if (!verifyDynamicFENOptionKey(tag, key))\r\n                continue;\r\n            const serializedForm = tag.serialize();\r\n            if (serializedForm)\r\n                builder += serializedForm;\r\n        }\r\n        builder = this.board.board.reduce((p, n) => p + n.map(ps => ps.value || \"-\").join(\"\"), builder);\r\n        return builder;\r\n    }\r\n    getRealPlayers() {\r\n        const dead = this.fenOptions.tag(\"dead\"), resigned = this.fenOptions.tag(\"resigned\");\r\n        let totalPlayers = 0;\r\n        for (const color of colors) {\r\n            if (resigned[color] || dead[color])\r\n                continue;\r\n            totalPlayers++;\r\n        }\r\n        return totalPlayers;\r\n    }\r\n    nextTurn(player = this.sideToMove) {\r\n        if (this.getRealPlayers() <= 1)\r\n            throw new Error(\"Next turn called while the game is terminated\");\r\n        return getNeighboringSideToMove(player, this.fenOptions.tag(\"dead\"));\r\n    }\r\n    previousTurn(player = this.sideToMove) {\r\n        const dead = this.fenOptions.tag(\"dead\");\r\n        if (this.getRealPlayers() <= 1)\r\n            throw new Error(\"Previous turn called while the game is terminated\");\r\n        let sideToMove = player;\r\n        do {\r\n            sideToMove = (sideToMove === 0 ? totalPlayers - 1 : sideToMove - 1);\r\n        } while (dead[sideToMove]);\r\n        if (verifyNumericColor(sideToMove)) {\r\n            return sideToMove;\r\n        }\r\n        else\r\n            throw new Error(`Unexpected numeric color: ${sideToMove}`);\r\n    }\r\n    isComplexEvaluation() { return false; }\r\n    obtainPointsForMate() {\r\n        return defaultPointsForMate;\r\n    }\r\n    assignPoints(sideToMove, points) {\r\n        if (points > 0) {\r\n            this.points[sideToMove] += points;\r\n        }\r\n    }\r\n    getPointsForPiece(pieceString) {\r\n        if (pieceString.isPiece() && this.board.gameType.isFFA()) {\r\n            return pieceControlConfigSettings[pieceString.piece].points.singlesPoints;\r\n        }\r\n        else\r\n            return 0;\r\n    }\r\n    countTotalPointsOnBoard() {\r\n        const royal = this.fenOptions.tag(\"royal\"), resigned = this.fenOptions.tag(\"resigned\"), zombieImmune = this.fenOptions.tag(\"zombieImmune\");\r\n        const resultingPoints = [0, 0, 0, 0];\r\n        this.board.getPlayerPieces().forEach((army, color) => {\r\n            if (zombieImmune[color])\r\n                return;\r\n            const royalPiece = royal[color];\r\n            for (const coordinate of army) {\r\n                if (royalPiece && compareCoordinates(coordinate, royalPiece)) {\r\n                    resultingPoints[color] += this.obtainPointsForMate();\r\n                }\r\n                else if (resigned[color]) {\r\n                    const piece = this.board.board[coordinate[0]][coordinate[1]].piece;\r\n                    resultingPoints[color] += pieceControlConfigSettings[piece].points.singlesPoints;\r\n                }\r\n            }\r\n        });\r\n        return resultingPoints;\r\n    }\r\n    getCurrentResult() {\r\n        if (this.board.gameType.isFFA()) {\r\n            const dead = this.fenOptions.tag(\"dead\"), resigned = this.fenOptions.tag(\"resigned\");\r\n            if (!this.board.isTwoPlayer)\r\n                throw new Error(\"Result can only get called for 2P and teams\");\r\n            const max = Math.max(...this.points);\r\n            let firstAlivePlayer, maximumIndex;\r\n            for (const color of colors) {\r\n                if (dead[color] || resigned[color])\r\n                    continue;\r\n                if (this.points[color] === max) {\r\n                    if (maximumIndex === undefined) {\r\n                        maximumIndex = color;\r\n                    }\r\n                    else\r\n                        return \"-\";\r\n                }\r\n                if (firstAlivePlayer === undefined)\r\n                    firstAlivePlayer = color;\r\n            }\r\n            return firstAlivePlayer === maximumIndex ? \"1-0\" : \"0-1\";\r\n        }\r\n        else {\r\n            let result = \"-\";\r\n            for (const color of colors) {\r\n                if (this.points[color] > 0) {\r\n                    result = this.board.gameType.teamSettings.firstTeamColors[color] ? \"1-0\" : \"0-1\";\r\n                    break;\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n    assignGeneralTermination(generalTermination, sideToMove) {\r\n        if (this.board.gameType.isFFA() && !this.board.isTwoPlayer) {\r\n            if (sideToMove !== undefined) {\r\n                switch (generalTermination) {\r\n                    case \"Stalemate\":\r\n                        this.gameOver = `${getPlayerNameFromColor(sideToMove).toUpperCase()} STALEMATED!`;\r\n                        return;\r\n                }\r\n            }\r\n            if (verifyWinningTermination(generalTermination)) {\r\n                this.gameOver = `${generalTermination.toUpperCase()}!`;\r\n            }\r\n            else if (verifyDrawingTermination(generalTermination)) {\r\n                this.gameOver = `${generalTermination.toUpperCase()}`;\r\n            }\r\n            else {\r\n                throwOnNever(generalTermination);\r\n            }\r\n        }\r\n        else {\r\n            this.gameOver = `${generalTermination.toUpperCase()}  ${this.getCurrentResult()}`;\r\n        }\r\n    }\r\n}\r\nexport { FENData, FENOptions };\r\n","import { verifyNumericColor } from \"@moveGeneration/GameInformation/GameUnits/GameUnits\";\r\nimport { totalPlayers } from \"../GameInformation/GameData\";\r\nexport const createDefaultFENEffectSettings = () => ({\r\n    ignoreCheckmateChecks: false, ignoreNextTurn: false\r\n});\r\nexport const createDefaultArmyDeathSettings = () => ({\r\n    excludeRoyals: false, onlyPawns: false, doNotSetDead: false\r\n});\r\nexport function getNeighboringSideToMove(player, dead) {\r\n    let sideToMove = player;\r\n    do {\r\n        sideToMove = (sideToMove === totalPlayers - 1 ? 0 : sideToMove + 1);\r\n    } while (dead[sideToMove]);\r\n    if (verifyNumericColor(sideToMove)) {\r\n        return sideToMove;\r\n    }\r\n    else\r\n        throw new Error(`Unexpected numeric color: ${sideToMove}`);\r\n}\r\n","import { createTupleFromCallback, assertNonUndefined } from \"@client/ts/baseTypes\";\r\nimport { getHorizontalPlacementModulus, getVerticalPlacementModulus, isVerticalPlacement } from \"@client/ts/logic/BaseInterfaces\";\r\nimport { botAlgorithms, ZombieType } from \"@moveGeneration/VariantRules/VariantRuleDefinitions/BoardVariantModules/EngineMoveGeneration/BotInterface\";\r\nimport { copyClass } from \"@utils/ObjectUtils\";\r\nimport { totalPlayers } from \"../../GameInformation/GameData\";\r\nimport { createFENOptionsTags, createFENOptionsTagsSnapshot } from \"./FENOptionsTagsInterface\";\r\nexport class FENOptions {\r\n    tags = createFENOptionsTags();\r\n    castlingKingsideData = createTupleFromCallback(() => ({ endCoordinates: -1, pieceCoordinates: -1, pieceEndCoordinates: -1, checkSquares: [] }), totalPlayers);\r\n    castlingQueensideData = createTupleFromCallback(() => ({ endCoordinates: -1, pieceCoordinates: -1, pieceEndCoordinates: -1, checkSquares: [] }), totalPlayers);\r\n    createSnapshot() {\r\n        return {\r\n            tagsSnapshot: createFENOptionsTagsSnapshot(this.tags)\r\n        };\r\n    }\r\n    loadTagSnapshot(value, tag) {\r\n        tag.loadSnapshot(value);\r\n    }\r\n    loadSnapshot(snapshot) {\r\n        let key;\r\n        for (key in snapshot.tagsSnapshot) {\r\n            if (!Object.prototype.hasOwnProperty.call(snapshot.tagsSnapshot, key))\r\n                continue;\r\n            this.loadTagSnapshot(snapshot.tagsSnapshot[key], this.tags[key]);\r\n        }\r\n    }\r\n    verifyKeyTag(key, snapshot) {\r\n        return key in snapshot;\r\n    }\r\n    createClone() {\r\n        const newOptions = copyClass(this, FENOptions);\r\n        const snapshot = this.createSnapshot();\r\n        newOptions.tags = createFENOptionsTags();\r\n        newOptions.loadSnapshot(snapshot);\r\n        let key;\r\n        for (key in this.tags) {\r\n            if (Object.prototype.hasOwnProperty.call(this.tags, key) && !this.verifyKeyTag(key, snapshot.tagsSnapshot)) {\r\n                newOptions.tags[key].value = this.tags[key].createSnapshot();\r\n            }\r\n        }\r\n        return newOptions;\r\n    }\r\n    tag(key) {\r\n        return this.tags[key].value;\r\n    }\r\n    setTag(key, value) {\r\n        this.tags[key].value = value;\r\n    }\r\n    generateCastling(board) {\r\n        let [dimensionRY, dimensionBG] = this.tag(\"dim\");\r\n        if (!this.tag(\"noCorners\")) {\r\n            if (dimensionRY > 8)\r\n                dimensionRY = 8;\r\n            if (dimensionBG > 8)\r\n                dimensionBG = 8;\r\n        }\r\n        const dimensions = [dimensionRY, dimensionBG, dimensionRY, dimensionBG];\r\n        const royalRanks = this.tag(\"royal\").map((r, i) => r ? r[getHorizontalPlacementModulus(i)] : r);\r\n        const royalCoordinates = this.tag(\"royal\").map((r, i) => r ? r[getHorizontalPlacementModulus(i)] : r);\r\n        const kingsideCastlePieceCoordinate = [];\r\n        const queensideCastlePieceCoordinate = [];\r\n        const boardSquares = board.board;\r\n        for (let i = 0; i < this.tag(\"royal\").length; i++) {\r\n            const royalCoordinateI = royalCoordinates[i];\r\n            const royalRanksI = royalRanks[i];\r\n            if (royalCoordinateI === null || royalRanksI === null) {\r\n                kingsideCastlePieceCoordinate.push(-1);\r\n                queensideCastlePieceCoordinate.push(-1);\r\n                continue;\r\n            }\r\n            const condition = i % 2 === 0;\r\n            for (let j = royalCoordinateI; j < 14; j++) {\r\n                const pieceString = boardSquares[condition ? royalRanksI : j][condition ? j : royalRanksI];\r\n                if (!pieceString.isEmpty() && pieceString.piece === this.tag(\"castleWith\")) {\r\n                    kingsideCastlePieceCoordinate.push(j);\r\n                    break;\r\n                }\r\n                else if (j === 13) {\r\n                    kingsideCastlePieceCoordinate.push(-1);\r\n                }\r\n            }\r\n            for (let j = royalCoordinateI; j > -1; j--) {\r\n                const pieceString = boardSquares[condition ? royalRanksI : j][condition ? j : royalRanksI];\r\n                if (!pieceString.isEmpty() && pieceString.piece === this.tag(\"castleWith\")) {\r\n                    queensideCastlePieceCoordinate.push(j);\r\n                    break;\r\n                }\r\n                else if (j === 0) {\r\n                    queensideCastlePieceCoordinate.push(-1);\r\n                }\r\n            }\r\n        }\r\n        for (let i = 0; i < this.tag(\"royal\").length; i++) {\r\n            const royalCoordinate = royalCoordinates[i];\r\n            if (royalCoordinate === null)\r\n                continue;\r\n            const d = dimensions[i] - 6 < 1 ? 1 : dimensions[i] - 6;\r\n            if (kingsideCastlePieceCoordinate[i] === -1) {\r\n                this.tag(\"castleKingside\")[i] = false;\r\n            }\r\n            else {\r\n                const kArr = [...Array(kingsideCastlePieceCoordinate[i] - royalCoordinate - 1).keys()];\r\n                const endCoordinates = royalCoordinate + d;\r\n                const castlingData = {\r\n                    endCoordinates, checkSquares: kArr.map(j => j + royalCoordinate + 1),\r\n                    pieceCoordinates: kingsideCastlePieceCoordinate[i], pieceEndCoordinates: endCoordinates - 1\r\n                };\r\n                if (royalCoordinate <= 6) {\r\n                    this.castlingQueensideData[i] = castlingData;\r\n                }\r\n                else {\r\n                    this.castlingKingsideData[i] = castlingData;\r\n                }\r\n            }\r\n            if (queensideCastlePieceCoordinate[i] === -1) {\r\n                this.tags.castleQueenside.value[i] = false;\r\n            }\r\n            else {\r\n                const qArr = [...Array(royalCoordinate - queensideCastlePieceCoordinate[i] - 1).keys()];\r\n                const endCoordinates = royalCoordinate - d;\r\n                const castlingData = {\r\n                    endCoordinates, checkSquares: royalCoordinate <= 6 ? qArr.map(j => j + royalCoordinate - 2) : qArr.map(j => j + royalCoordinate - 3),\r\n                    pieceCoordinates: queensideCastlePieceCoordinate[i], pieceEndCoordinates: endCoordinates + 1\r\n                };\r\n                if (royalCoordinate <= 6) {\r\n                    this.castlingKingsideData[i] = castlingData;\r\n                }\r\n                else {\r\n                    this.castlingQueensideData[i] = castlingData;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    isCastlingAvailable(player, board, checks) {\r\n        const royal = this.tag(\"royal\")[player];\r\n        if (royal === null)\r\n            return false;\r\n        const royalCoordinate = royal[getVerticalPlacementModulus(player)];\r\n        const squares = board.board;\r\n        for (const checkSquare of checks) {\r\n            const coordinateA = isVerticalPlacement(player) ? royalCoordinate : checkSquare;\r\n            const coordinateB = isVerticalPlacement(player) ? checkSquare : royalCoordinate;\r\n            if (!squares[coordinateA][coordinateB].isEmpty() ||\r\n                board.preGeneratedAttacks[player].hoppingPieces[coordinateA][coordinateB] > 0 ||\r\n                board.preGeneratedAttacks[player].slidingPieces[coordinateA][coordinateB] > 0)\r\n                return false;\r\n        }\r\n        if (board.isKingInCheck(player))\r\n            return false;\r\n        return true;\r\n    }\r\n    isKingsideCastlingAvailable(player, board) {\r\n        if (!this.tag(\"castleKingside\")[player])\r\n            return false;\r\n        if (this.castlingKingsideData[player].endCoordinates === -1) {\r\n            this.generateCastling(board);\r\n        }\r\n        return this.isCastlingAvailable(player, board, this.castlingKingsideData[player].checkSquares);\r\n    }\r\n    isQueensideCastlingAvailable(player, board) {\r\n        if (!this.tag(\"castleQueenside\")[player])\r\n            return false;\r\n        if (this.castlingQueensideData[player].endCoordinates === -1) {\r\n            this.generateCastling(board);\r\n        }\r\n        return this.isCastlingAvailable(player, board, this.castlingQueensideData[player].checkSquares);\r\n    }\r\n    getCastlingEndCoordinate(player, coordinates) {\r\n        const royalCoordinate = this.tag(\"royal\")[player]?.[getVerticalPlacementModulus(player)];\r\n        assertNonUndefined(coordinates);\r\n        assertNonUndefined(royalCoordinate);\r\n        const coordinateA = isVerticalPlacement(player) ? royalCoordinate : coordinates;\r\n        const coordinateB = isVerticalPlacement(player) ? coordinates : royalCoordinate;\r\n        return [coordinateA, coordinateB];\r\n    }\r\n    getKingsideCastlingEndCoordinate(player) { return this.getCastlingEndCoordinate(player, this.castlingKingsideData[player].endCoordinates); }\r\n    getQueensideCastlingEndCoordinate(player) { return this.getCastlingEndCoordinate(player, this.castlingQueensideData[player].endCoordinates); }\r\n    getKingsideCastlingPieceEndCoordinate(player) { return this.getCastlingEndCoordinate(player, this.castlingKingsideData[player].pieceEndCoordinates); }\r\n    getQueensideCastlingPieceEndCoordinate(player) { return this.getCastlingEndCoordinate(player, this.castlingQueensideData[player].pieceEndCoordinates); }\r\n    getKingsideCastlingTandemPiece(player) { return this.castlingKingsideData[player].pieceCoordinates; }\r\n    getQueensideCastlingTandemPiece(player) { return this.castlingQueensideData[player].pieceCoordinates; }\r\n    getAvailableEnPassantCaptures(baseColor) {\r\n        const coordinates = [];\r\n        this.tag(\"enPassant\").forEach((enPassant, i) => {\r\n            if (i === baseColor)\r\n                return;\r\n            if (enPassant)\r\n                coordinates.push(enPassant[0]);\r\n        });\r\n        return coordinates.map(e => [...e]);\r\n    }\r\n    getDefaultZombieAlgorithm(baseColor) {\r\n        const algorithm = botAlgorithms.get(this.tag(\"resigned\")[baseColor] ? this.tag(\"zombieType\")[baseColor] : ZombieType.F_Checker);\r\n        assertNonUndefined(algorithm);\r\n        return algorithm;\r\n    }\r\n}\r\n","import { createTuple, createTupleFromCallback, verifyTupleType } from \"@client/ts/baseTypes\";\r\nimport { compareArrays } from \"@client/ts/utils/ArrayUtils\";\r\nimport { stringifyCoordinate, unstringifyCoordinate } from \"../../Board/BoardInterface\";\r\nimport { boardDimension, colors, convertCoordinateToPGN4, totalPlayers } from \"../../GameInformation/GameData\";\r\nimport { verifyNumericColor } from \"../../GameInformation/GameUnits/GameUnits\";\r\nimport { createPieceFromString } from \"../../GameInformation/GameUnits/PieceString\";\r\nimport { verifyPieceLetter } from \"../../PieceControl/PieceControlInterface\";\r\nimport { verifyZombieType, ZombieType } from \"@moveGeneration/VariantRules/VariantRuleDefinitions/BoardVariantModules/EngineMoveGeneration/BotInterface\";\r\nimport { PGN4_SYNTAX } from \"@client/ts/logic/utils/Tags/Moves/ParsePGNMoves\";\r\nimport { parseEnPassantCoordinates, parseSingleCoordinate } from \"@client/ts/logic/utils/Tags/Utils\";\r\nconst verifyParameterType = (param, type) => {\r\n    return Array.isArray(param) && verifyTupleType(param, totalPlayers) && param.every(v => typeof v === type);\r\n};\r\nexport function createBooleanTupleTag(parameters) {\r\n    const { defaultValue, key, isStatic } = parameters;\r\n    const resultingObject = {\r\n        value: [...defaultValue],\r\n        parse(value) {\r\n            if (verifyParameterType(value, \"boolean\")) {\r\n                return value;\r\n            }\r\n            else\r\n                return this.createSnapshot();\r\n        },\r\n        serialize() {\r\n            if (key === \"castleKingside\" || key === \"castleQueenside\" || key === \"dead\" || key === \"areBanksEnabled\")\r\n                return;\r\n            if (!compareArrays(this.value, defaultValue)) {\r\n                return `'${key}':(${this.value.join(\",\")})`;\r\n            }\r\n            else\r\n                return;\r\n        },\r\n        createSnapshot() {\r\n            return [...this.value];\r\n        },\r\n        loadSnapshot(snapshot) {\r\n            const tuple = [...snapshot];\r\n            this.value = tuple;\r\n        }\r\n    };\r\n    if (isStatic)\r\n        delete resultingObject.loadSnapshot;\r\n    return resultingObject;\r\n}\r\nconst defaultPawnBaseRank = 2;\r\nexport const createPawnBaseRankTag = () => ({\r\n    value: defaultPawnBaseRank,\r\n    parse(value) {\r\n        return typeof value === \"number\" && (value > 0 && value <= boardDimension) ? value : this.value;\r\n    },\r\n    serialize() {\r\n        return this.value === defaultPawnBaseRank ? undefined : `'pawnBaseRank':${this.value}`;\r\n    },\r\n    createSnapshot() {\r\n        return this.value;\r\n    }\r\n});\r\nexport const createEnPassantTag = () => ({\r\n    value: createTuple(null, totalPlayers),\r\n    parse(input) {\r\n        if (verifyParameterType(input, \"string\")) {\r\n            return input.map(v => parseEnPassantCoordinates(v) ?? null);\r\n        }\r\n        else\r\n            return this.createSnapshot();\r\n    },\r\n    serialize() {\r\n        if (this.value.some(v => !v)) {\r\n            return `'enPassant':(${this.value.map(enP => enP ?\r\n                `'${convertCoordinateToPGN4(enP[0])}:${convertCoordinateToPGN4(enP[1])}'` : \"''\").join(\",\")})`;\r\n        }\r\n        else\r\n            return;\r\n    },\r\n    createSnapshot() {\r\n        return this.value.map(enP => enP ? [[...enP[0]], [...enP[1]]] : enP);\r\n    },\r\n    loadSnapshot(snapshot) {\r\n        this.value = snapshot.map(enP => enP ? [[...enP[0]], [...enP[1]]] : enP);\r\n    }\r\n});\r\nconst defaultCastleWith = \"R\";\r\nexport const createCastleWithTag = () => ({\r\n    value: defaultCastleWith,\r\n    parse(input) {\r\n        return typeof input === \"string\" ? input : this.value;\r\n    },\r\n    serialize() {\r\n        return this.value === defaultCastleWith ? undefined : `'castleWith':${this.value}`;\r\n    },\r\n    createSnapshot() {\r\n        return this.value;\r\n    }\r\n});\r\nconst defaultBoxOffset = 0;\r\nexport const createBoxOffsetTag = () => ({\r\n    value: defaultBoxOffset,\r\n    parse(input) {\r\n        return typeof input === \"number\" && verifyNumericColor(input) ? input : this.value;\r\n    },\r\n    serialize() {\r\n        return this.value === defaultBoxOffset ? undefined : `'boxOffset':${this.value}`;\r\n    },\r\n    createSnapshot() {\r\n        return this.value;\r\n    }\r\n});\r\nexport function createBooleanTag(parameters) {\r\n    const { defaultValue, key, isStatic } = parameters;\r\n    const result = {\r\n        value: defaultValue,\r\n        parse(input) {\r\n            return typeof input === \"boolean\" ? input : this.createSnapshot();\r\n        },\r\n        serialize() {\r\n            return this.value === defaultValue ? undefined : `'${key}':${String(this.value)}`;\r\n        },\r\n        createSnapshot() {\r\n            return this.value;\r\n        },\r\n        loadSnapshot(snapshot) {\r\n            this.value = snapshot;\r\n        }\r\n    };\r\n    if (isStatic)\r\n        delete result.loadSnapshot;\r\n    return result;\r\n}\r\nconst defaultDimension = [14, 14];\r\nexport const createDimensionTag = () => ({\r\n    value: [...defaultDimension],\r\n    parse(baseInput) {\r\n        if (typeof baseInput !== \"string\")\r\n            return this.createSnapshot();\r\n        const input = baseInput.split(\"x\");\r\n        return Array.isArray(input) && verifyTupleType(input, 2)\r\n            && input.every((i) => {\r\n                const v = Number(i);\r\n                return !isNaN(v) && (v >= 2) && (v <= 14) && (v % 2 === 0);\r\n            }) ? input.map(v => Number(v)).reverse() : this.createSnapshot();\r\n    },\r\n    serialize() {\r\n        if (compareArrays(this.value, defaultDimension))\r\n            return;\r\n        return `'dim':'${this.value.join(\"x\")}'`;\r\n    },\r\n    createSnapshot() {\r\n        return [...this.value];\r\n    }\r\n});\r\nconst defaultZombies = createTuple(ZombieType.Rando, totalPlayers);\r\nexport const createZombiesTag = () => ({\r\n    value: [...defaultZombies],\r\n    parse(input) {\r\n        if (Array.isArray(input) && verifyTupleType(input, totalPlayers)\r\n            && input.every((v) => typeof v === 'string')) {\r\n            const newZombies = this.createSnapshot();\r\n            for (const color of colors) {\r\n                const zombieType = input[color];\r\n                if (verifyZombieType(zombieType))\r\n                    newZombies[color] = zombieType;\r\n            }\r\n            return newZombies;\r\n        }\r\n        else\r\n            return this.createSnapshot();\r\n    },\r\n    serialize() {\r\n        if (compareArrays(this.value, defaultZombies))\r\n            return;\r\n        return `'zombieType':(${this.value\r\n            .map((t, i) => t === defaultZombies[i] ? \"''\" : `'${t}'`).join(\",\")})`;\r\n    },\r\n    createSnapshot() {\r\n        return [...this.value];\r\n    }\r\n});\r\nexport const createRoyalTag = () => ({\r\n    value: createTuple(null, totalPlayers),\r\n    parse(input) {\r\n        if (verifyParameterType(input, \"string\")) {\r\n            return input.map(c => parseSingleCoordinate(c) ?? null);\r\n        }\r\n        else\r\n            return this.createSnapshot();\r\n    },\r\n    serialize() {\r\n        return `'royal':(${this.value.map(r => r ? `'${convertCoordinateToPGN4(r)}'` : \"''\").join(\",\")})`;\r\n    },\r\n    createSnapshot() {\r\n        return this.value.map(c => c ? [...c] : c);\r\n    },\r\n    loadSnapshot(snapshot) {\r\n        this.value = snapshot.map(c => c ? [...c] : c);\r\n    }\r\n});\r\nexport const createLivesTag = () => ({\r\n    value: createTuple(null, totalPlayers),\r\n    parse(input) {\r\n        if (verifyParameterType(input, \"number\")) {\r\n            return input;\r\n        }\r\n        else\r\n            return this.createSnapshot();\r\n    },\r\n    serialize() {\r\n        if (this.value.some(v => v !== null)) {\r\n            return `'lives':(${this.value.map(l => l ? String(l) : \"1\").join(\",\")})`;\r\n        }\r\n        else\r\n            return;\r\n    },\r\n    createSnapshot() {\r\n        return [...this.value];\r\n    },\r\n    loadSnapshot(snapshot) {\r\n        this.value = [...snapshot];\r\n    }\r\n});\r\nexport const createBankTag = () => ({\r\n    value: createTupleFromCallback(() => new Map, totalPlayers),\r\n    parse(input) {\r\n        const defaultBanks = this.createSnapshot();\r\n        if (verifyParameterType(input, \"string\")) {\r\n            for (const color of colors) {\r\n                for (const pieceDefinition of input[color].split(\",\")) {\r\n                    const [piece, count = 1] = pieceDefinition.split(\"x\").map((e, i) => i === 1 ? Number(e) : e);\r\n                    if (typeof piece !== \"string\" || typeof count !== \"number\")\r\n                        continue;\r\n                    if (!/^(?:r|b|y|g).$/.test(piece))\r\n                        continue;\r\n                    const pieceLetter = piece.charAt(1);\r\n                    if (verifyPieceLetter(pieceLetter)) {\r\n                        defaultBanks[color].set(createPieceFromString(piece), count);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return defaultBanks;\r\n    },\r\n    serialize() {\r\n        if (this.value.some(b => b.size !== 0)) {\r\n            return `'bank':(${this.value.map(bank => {\r\n                const resultingStrings = [];\r\n                for (const [piece, count] of bank) {\r\n                    if (count === 1) {\r\n                        resultingStrings.push(piece.value);\r\n                    }\r\n                    else {\r\n                        resultingStrings.push(`${piece.value}x${count}`);\r\n                    }\r\n                }\r\n                return `'${resultingStrings.join(\",\")}'`;\r\n            }).join(\",\")})`;\r\n        }\r\n        else\r\n            return;\r\n    },\r\n    createSnapshot() {\r\n        return this.value.map(m => new Map(m));\r\n    },\r\n    loadSnapshot(snapshot) {\r\n        this.value = snapshot.map(m => new Map(m));\r\n    }\r\n});\r\nconst verifyPromotedFromRecord = (object) => typeof object === \"object\" && object !== null;\r\nexport const createPromotedFromTag = () => ({\r\n    value: new Map(),\r\n    parse(input) {\r\n        const promotedFromMap = new Map();\r\n        if (!verifyPromotedFromRecord(input))\r\n            return promotedFromMap;\r\n        for (const key in input) {\r\n            if (!Object.prototype.hasOwnProperty.call(promotedFromMap, key))\r\n                continue;\r\n            const parsedCoordinate = parseSingleCoordinate(key);\r\n            const pieceLetter = input[key];\r\n            if (!parsedCoordinate || typeof pieceLetter !== \"string\" || !verifyPieceLetter(pieceLetter))\r\n                continue;\r\n            promotedFromMap.set(parsedCoordinate, pieceLetter);\r\n        }\r\n        return promotedFromMap;\r\n    },\r\n    serialize() {\r\n        if (this.value.size === 0)\r\n            return;\r\n        const promotedFromStrings = [];\r\n        for (const [coordinate, piece] of this.value) {\r\n            promotedFromStrings.push(`'${convertCoordinateToPGN4(coordinate)}':'${piece}'`);\r\n        }\r\n        return `'promotedFrom':{${promotedFromStrings.join(\",\")}}`;\r\n    },\r\n    createSnapshot() {\r\n        const newMap = new Map();\r\n        for (const [coordinate, pieceLetter] of this.value.entries()) {\r\n            newMap.set([...coordinate], pieceLetter);\r\n        }\r\n        return newMap;\r\n    },\r\n    loadSnapshot(snapshot) {\r\n        this.value.clear();\r\n        for (const [coordinate, pieceLetter] of snapshot.entries()) {\r\n            this.value.set([...coordinate], pieceLetter);\r\n        }\r\n    }\r\n});\r\nexport const createSetupPointsTag = () => ({\r\n    value: null,\r\n    parse(input) {\r\n        if (verifyParameterType(input, \"number\")) {\r\n            return input;\r\n        }\r\n        else\r\n            return this.createSnapshot();\r\n    },\r\n    serialize() {\r\n        if (this.value) {\r\n            return `'setupPoints':(${this.value.join(\",\")})`;\r\n        }\r\n        else\r\n            return;\r\n    },\r\n    createSnapshot() {\r\n        return this.value ? [...this.value] : this.value;\r\n    },\r\n    loadSnapshot(snapshot) {\r\n        this.value = snapshot ? [...snapshot] : snapshot;\r\n    }\r\n});\r\nexport const createSeirawanDropsTag = () => ({\r\n    value: createTupleFromCallback(() => new Set(), totalPlayers),\r\n    parse(input) {\r\n        const defaultValue = createTupleFromCallback(() => new Set(), totalPlayers);\r\n        if (Array.isArray(input) && (verifyTupleType(input, totalPlayers) || verifyTupleType(input, totalPlayers + 1))\r\n            && input.every((v) => Array.isArray(v))) {\r\n            for (const color of colors) {\r\n                const seirawanDropsArray = input[color];\r\n                if (!seirawanDropsArray.every((v) => typeof v === 'string'))\r\n                    continue;\r\n                for (const pieceDefinition of seirawanDropsArray) {\r\n                    if (!PGN4_SYNTAX.COORDINATE_REGEX.test(pieceDefinition))\r\n                        continue;\r\n                    const coordinate = parseSingleCoordinate(pieceDefinition);\r\n                    if (coordinate) {\r\n                        defaultValue[color].add(stringifyCoordinate(coordinate));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return defaultValue;\r\n    },\r\n    serialize() {\r\n        if (this.value.every(m => m.size === 0))\r\n            return;\r\n        return `'seirawanDrops':(${this.value.map(coordinates => {\r\n            return `(${[...coordinates].map(coord => `'${convertCoordinateToPGN4(unstringifyCoordinate(coord))}'`).join(\",\")})`;\r\n        }).join(\",\")})`;\r\n    },\r\n    createSnapshot() {\r\n        return this.value.map(s => new Set(s));\r\n    },\r\n    loadSnapshot(snapshot) {\r\n        this.value = snapshot.map(s => new Set(s));\r\n    }\r\n});\r\n","import { createTuple } from \"@client/ts/baseTypes\";\r\nimport { totalPlayers } from \"../../GameInformation/GameData\";\r\nimport { createBankTag, createBooleanTag, createBooleanTupleTag, createBoxOffsetTag, createCastleWithTag, createDimensionTag, createEnPassantTag, createLivesTag, createPawnBaseRankTag, createPromotedFromTag, createRoyalTag, createSeirawanDropsTag, createSetupPointsTag, createZombiesTag } from \"./FENOptionsTags\";\r\nexport const verifyDynamicFENOptionKey = (fenTag, key) => \"loadSnapshot\" in fenTag;\r\nconst verifyDynamicTag = (fenTag) => \"loadSnapshot\" in fenTag;\r\nexport function createFENOptionsTags() {\r\n    return {\r\n        dead: createBooleanTupleTag({ key: \"dead\", defaultValue: createTuple(false, totalPlayers), isStatic: false }),\r\n        resigned: createBooleanTupleTag({ key: \"resigned\", defaultValue: createTuple(false, totalPlayers), isStatic: false }),\r\n        pawnBaseRank: createPawnBaseRankTag(),\r\n        enPassant: createEnPassantTag(),\r\n        boxOffset: createBoxOffsetTag(),\r\n        wb: createBooleanTag({ key: \"wb\", defaultValue: false, isStatic: true }),\r\n        dim: createDimensionTag(),\r\n        noCorners: createBooleanTag({ key: \"noCorners\", defaultValue: false, isStatic: true }),\r\n        castleKingside: createBooleanTupleTag({ key: \"castleKingside\", defaultValue: createTuple(true, totalPlayers), isStatic: false }),\r\n        castleQueenside: createBooleanTupleTag({ key: \"castleQueenside\", defaultValue: createTuple(true, totalPlayers), isStatic: false }),\r\n        castleWith: createCastleWithTag(),\r\n        zombieType: createZombiesTag(),\r\n        zombieImmune: createBooleanTupleTag({ key: \"zombieImmune\", defaultValue: createTuple(false, totalPlayers), isStatic: false }),\r\n        royal: createRoyalTag(),\r\n        lives: createLivesTag(),\r\n        bank: createBankTag(),\r\n        promotedFrom: createPromotedFromTag(),\r\n        setupPoints: createSetupPointsTag(),\r\n        setupComplete: createBooleanTupleTag({ key: \"setupComplete\", defaultValue: createTuple(true, totalPlayers), isStatic: false }),\r\n        seirawanDrops: createSeirawanDropsTag(),\r\n        areBanksEnabled: createBooleanTupleTag({ key: \"areBanksEnabled\", defaultValue: createTuple(false, totalPlayers), isStatic: false })\r\n    };\r\n}\r\nconst setFENOptionsTag = (tags, key, tag) => tags[key] = tag.createSnapshot();\r\nexport function createFENOptionsTagsSnapshot(tags) {\r\n    const resultingTags = {};\r\n    let fenTag;\r\n    for (fenTag in tags) {\r\n        if (!Object.prototype.hasOwnProperty.call(tags, fenTag))\r\n            continue;\r\n        const tag = tags[fenTag];\r\n        if (!verifyDynamicFENOptionKey(tag, fenTag) || !verifyDynamicTag(tag))\r\n            continue;\r\n        setFENOptionsTag(resultingTags, fenTag, tag);\r\n    }\r\n    return resultingTags;\r\n}\r\n","import { throwOnNever } from \"@client/ts/baseTypes\";\r\nimport { truncateNumber } from \"@utils/NumberUtils\";\r\nexport const validateComprehensiveUnionArray = () => (arr) => arr;\r\nexport const playerNames = validateComprehensiveUnionArray()([\"Red\", \"Blue\", \"Yellow\", \"Green\", \"White\", \"Black\"]);\r\nconst individualTerminations = validateComprehensiveUnionArray()([\r\n    \"Won the Race\", \"Checkmated\", \"Stalemated\", \"Forfeits on Time\", \"Claimed the Win\", \"Resigned\"\r\n]);\r\nconst generalWinningTerminations = validateComprehensiveUnionArray()([\r\n    \"Checkmate\", \"King Captured\", \"King of the Hill\", \"Stalemate\"\r\n]);\r\nexport const verifyWinningTermination = (termination) => {\r\n    const generalWins = generalWinningTerminations;\r\n    return generalWins.includes(termination);\r\n};\r\nconst generalDrawingTerminations = validateComprehensiveUnionArray()([\r\n    \"50-move Rule\",\r\n    \"Insufficient Material\", \"Threefold Repetition\", \"Timeout vs Insufficient Material\"\r\n]);\r\nexport const verifyDrawingTermination = (termination) => {\r\n    const generalDraws = generalDrawingTerminations;\r\n    return generalDraws.includes(termination);\r\n};\r\nconst generalTerminations = validateComprehensiveUnionArray()([...generalWinningTerminations, ...generalDrawingTerminations]);\r\nconst results = validateComprehensiveUnionArray()([\"0-1\", \"1-0\", \"-\"]);\r\nexport const validateTerminationString = (termination) => {\r\n    const capitalizedTermination = termination.toUpperCase();\r\n    if (playerNames.some(str => capitalizedTermination.startsWith(str.toUpperCase()))\r\n        && individualTerminations.some(str => capitalizedTermination.endsWith(str.toUpperCase() + \"!\"))) {\r\n        return true;\r\n    }\r\n    else if (/.*?\\s\\s.*/.test(capitalizedTermination)\r\n        && generalTerminations.some(str => capitalizedTermination.startsWith(str.toUpperCase()))\r\n        && results.some(str => capitalizedTermination.endsWith(str.toUpperCase()))) {\r\n        return true;\r\n    }\r\n    else if (capitalizedTermination === \"- AGREED.\") {\r\n        return true;\r\n    }\r\n    return false;\r\n};\r\nexport const stringifyTimeControl = (timeControl) => {\r\n    const noIncrement = timeControl.increment === 0;\r\n    let timeControlString = \"\";\r\n    if (timeControl.baseTime < 60) {\r\n        timeControlString += noIncrement ? `${timeControl.baseTime * 60} sec` : `${timeControl.baseTime * 60}s`;\r\n    }\r\n    else if (timeControl.baseTime > 60 && noIncrement) {\r\n        timeControlString += `${truncateNumber(timeControl.baseTime / 60, 1)} min`;\r\n    }\r\n    else {\r\n        timeControlString += truncateNumber(timeControl.baseTime / 60, 1);\r\n    }\r\n    if (!noIncrement) {\r\n        timeControlString += \"|\";\r\n        timeControlString += timeControl.increment;\r\n    }\r\n    if (timeControl.isDelay) {\r\n        timeControlString += \"D\";\r\n    }\r\n    return timeControlString;\r\n};\r\nexport const obtainTimeControlType = (timeControl) => {\r\n    const { baseTime, increment, isDelay } = timeControl;\r\n    if (isDelay) {\r\n        const formula = baseTime / 40 + increment;\r\n        if (formula > 11.5) {\r\n            return TimeControlType.Rapid;\r\n        }\r\n        else if (formula <= 1.375) {\r\n            return TimeControlType.Hyperbullet;\r\n        }\r\n        else if (formula <= 4.5) {\r\n            return TimeControlType.Bullet;\r\n        }\r\n        else {\r\n            return TimeControlType.Blitz;\r\n        }\r\n    }\r\n    else {\r\n        const formula = baseTime / 60 + increment;\r\n        if (formula > 7.5) {\r\n            return TimeControlType.Rapid;\r\n        }\r\n        else if (formula <= 0.5) {\r\n            return TimeControlType.Hyperbullet;\r\n        }\r\n        else if (formula <= 3) {\r\n            return TimeControlType.Bullet;\r\n        }\r\n        else {\r\n            return TimeControlType.Blitz;\r\n        }\r\n    }\r\n};\r\nexport const convertCoordinateToPGN4 = (coordinate, dimension = boardDimension) => {\r\n    if (dimension === boardDimension) {\r\n        return `${String.fromCharCode(coordinate[1] + 97)}${boardDimension - coordinate[0]}`;\r\n    }\r\n    else {\r\n        const alternation = (boardDimension - dimension) / 2;\r\n        return `${String.fromCharCode(coordinate[1] - alternation + 97)}${boardDimension - coordinate[0] - alternation}`;\r\n    }\r\n};\r\nexport const convertCoordinateToPGN4Array = (coordinate, dimension = boardDimension) => {\r\n    if (dimension === boardDimension) {\r\n        return [String.fromCharCode(coordinate[1] + 97), boardDimension - coordinate[0]];\r\n    }\r\n    else {\r\n        const alternation = (boardDimension - dimension) / 2;\r\n        return [String.fromCharCode(coordinate[1] - alternation + 97), boardDimension - coordinate[0] - alternation];\r\n    }\r\n};\r\nexport const getOppositePlacedColor = (color) => {\r\n    switch (color) {\r\n        case 0:\r\n            return 2;\r\n        case 1:\r\n            return 3;\r\n        case 2:\r\n            return 0;\r\n        case 3:\r\n            return 1;\r\n        default:\r\n            return throwOnNever(color);\r\n    }\r\n};\r\nexport const getPlayerNameFromColor = (color, wb = false) => {\r\n    switch (color) {\r\n        case 0:\r\n            return wb ? \"White\" : \"Red\";\r\n        case 1:\r\n            return \"Blue\";\r\n        case 2:\r\n            return wb ? \"Black\" : \"Yellow\";\r\n        case 3:\r\n            return \"Green\";\r\n        default:\r\n            return throwOnNever(color);\r\n    }\r\n};\r\nexport const createDefaultNumericColorAdjustment = () => ({\r\n    wb: false\r\n});\r\nexport var TimeControlType;\r\n(function (TimeControlType) {\r\n    TimeControlType[\"Hyperbullet\"] = \"Hyperbullet\";\r\n    TimeControlType[\"Bullet\"] = \"Bullet\";\r\n    TimeControlType[\"Blitz\"] = \"Blitz\";\r\n    TimeControlType[\"Rapid\"] = \"Rapid\";\r\n})(TimeControlType || (TimeControlType = {}));\r\nexport var VariantType;\r\n(function (VariantType) {\r\n    VariantType[\"FFA\"] = \"FFA\";\r\n    VariantType[\"Teams\"] = \"Teams\";\r\n    VariantType[\"Solo\"] = \"Solo\";\r\n})(VariantType || (VariantType = {}));\r\nexport const totalPlayers = 4;\r\nexport const boardDimension = 14;\r\nexport const colors = [0, 1, 2, 3];\r\n","export const verifyNumericColor = (num) => num >= 0 && num < 4;\r\nexport const nonPlayablePieces = {\r\n    wall: \"X\", transparentWall: \"x\", duck: \"\"\r\n};\r\nexport const colorEnum = {\r\n    r: 0, b: 1, y: 2, g: 3\r\n};\r\nexport const verifyColorEnumValue = (value) => value in colorEnum;\r\nexport const playerEnum = {\r\n    Red: 0,\r\n    Blue: 1,\r\n    Yellow: 2,\r\n    Green: 3,\r\n    White: 0,\r\n    Black: 2\r\n};\r\nexport const verifyPlayerEnumValue = (player) => player in playerEnum;\r\nexport const stringColorEnum = {\r\n    [0]: 'r', [1]: 'b', [2]: 'y', [3]: 'g', [4]: 'd',\r\n};\r\n","import { duckLetter, emptyLetter, pawnPieceLetter, verifyPieceLetter, wallPieceLetter } from \"@moveGeneration/PieceControl/PieceControlInterface\";\r\nimport { colorEnum, stringColorEnum } from \"./GameUnits\";\r\nexport const deadColorIndex = 4;\r\nexport class PieceString {\r\n    _color;\r\n    _piece;\r\n    static comparePieceStrings(pieceString1, pieceString2) {\r\n        return pieceString1._piece === pieceString2._piece && pieceString1._color === pieceString2._color;\r\n    }\r\n    static comparePieceStringObjects(pieceString1, pieceString2) {\r\n        return pieceString1._piece === pieceString2._piece && pieceString1._color === pieceString2._color;\r\n    }\r\n    static fromObjectToClass(object) {\r\n        return new PieceString(object._color, object._piece);\r\n    }\r\n    value;\r\n    constructor(_color, _piece) {\r\n        this._color = _color;\r\n        this._piece = _piece;\r\n        this.value = _piece.length ? /[xX]/.test(_piece) ? _piece : stringColorEnum[_color] + _piece : '';\r\n    }\r\n    isDead() { return this._color === deadColorIndex && !this.isWall(); }\r\n    isEmpty() { return this._piece.length === 0; }\r\n    isWall() { return this.value.length === 1; }\r\n    isPiece() { return this.value.length === 2 && this._color !== deadColorIndex; }\r\n    get piece() {\r\n        if (this.isEmpty())\r\n            throw new TypeError(\"Accessing a piece string piece value while the piece string is empty.\");\r\n        return this._piece;\r\n    }\r\n    get color() {\r\n        if (this.isEmpty())\r\n            throw new TypeError(\"Accessing a piece string color value while the piece string is empty.\");\r\n        return this._color;\r\n    }\r\n    getStringifiedColor() {\r\n        return this.value.charAt(0);\r\n    }\r\n    toObject() {\r\n        return {\r\n            _piece: this._piece,\r\n            _color: this._color,\r\n            value: this.value\r\n        };\r\n    }\r\n}\r\nexport const createPieceFromData = (color, piece) => {\r\n    if (verifyPieceLetter(piece)) {\r\n        return new PieceString(color, piece);\r\n    }\r\n    throw new Error(\"Wrong color signature for the piece provided\");\r\n};\r\nexport const createPieceFromString = (piece) => {\r\n    const verifyColorEnum = (p) => p in colorEnum;\r\n    if (piece.length === 1 && verifyPieceLetter(piece)) {\r\n        return new PieceString(deadColorIndex, piece);\r\n    }\r\n    else {\r\n        const color = piece.charAt(0);\r\n        const pieceLetter = piece.charAt(1);\r\n        if (!verifyPieceLetter(pieceLetter))\r\n            throw new Error(\"Wrong signature for the piece provided\");\r\n        if (color === 'd') {\r\n            return new PieceString(deadColorIndex, pieceLetter);\r\n        }\r\n        else {\r\n            if (verifyColorEnum(color)) {\r\n                return new PieceString(colorEnum[color], pieceLetter);\r\n            }\r\n            else\r\n                throw new Error(\"Wrong color signature for the piece provided\");\r\n        }\r\n    }\r\n};\r\nconst testEmptyPieceString = new PieceString(0, emptyLetter);\r\nif (!testEmptyPieceString.isEmpty())\r\n    throw new Error(\"Empty piece string is not isEmpty\");\r\nexport const emptyPieceString = testEmptyPieceString;\r\nconst testWallPieceString = new PieceString(deadColorIndex, wallPieceLetter);\r\nif (!testWallPieceString.isWall())\r\n    throw new Error(\"Wall piece string is not isWall\");\r\nexport const wallPieceString = testWallPieceString;\r\nconst testActivePieceString = new PieceString(0, pawnPieceLetter);\r\nif (!testActivePieceString.isPiece())\r\n    throw new Error(\"Active piece string is not isActive\");\r\nexport const pawnPieceString = testActivePieceString;\r\nconst testDuckPieceString = new PieceString(deadColorIndex, duckLetter);\r\nif (!testDuckPieceString.isWall())\r\n    throw new Error(\"Wall piece string is not isWall\");\r\nexport const duckPieceString = testActivePieceString;\r\n","import { throwOnNever } from \"@client/ts/baseTypes\";\r\nimport { compareArrays } from \"../../../utils/ArrayUtils\";\r\nimport { isVerticalPlacement } from \"../../BaseInterfaces\";\r\nimport { unstringifyCoordinate } from \"../Board/BoardInterface\";\r\nimport { convertCoordinateToPGN4Array, convertCoordinateToPGN4 } from \"../GameInformation/GameData\";\r\nimport { deadColorIndex, pawnPieceString } from \"../GameInformation/GameUnits/PieceString\";\r\nimport { SpecialMove, verifyDroppingMove, verifyInternalMove, verifyStandardMove } from \"./MoveTreeInterface\";\r\nfunction generateCastlingString(moveData) {\r\n    switch (moveData.specialType) {\r\n        case SpecialMove.CastlingKingside:\r\n            return \"O-O\";\r\n        case SpecialMove.CastlingQueenside:\r\n            return \"O-O-O\";\r\n        default:\r\n            return \"\";\r\n    }\r\n}\r\nfunction extractPiece(metadata) {\r\n    return metadata.movingPiece.piece !== pawnPieceString.piece ? metadata.movingPiece.piece : \"\";\r\n}\r\nfunction obtainAmbiguousOrthogonality(parameters) {\r\n    const { moveMetadata, move, snapshot: { boardSnapshot: { board }, pregeneratedAttacks: { pieceMovements } }, isCapture } = parameters;\r\n    const { piece, color } = moveMetadata.movingPiece;\r\n    const isPawn = piece === pawnPieceString.piece;\r\n    const registeredPieces = [];\r\n    for (const [piece, movements] of pieceMovements) {\r\n        const parsedCoordinate = unstringifyCoordinate(piece);\r\n        const boardPiece = board[parsedCoordinate[0]][parsedCoordinate[1]];\r\n        if (boardPiece.isEmpty() || boardPiece.color !== color\r\n            || boardPiece.piece !== piece)\r\n            continue;\r\n        if (movements.find(m => compareArrays(move.endCoordinates, m.move)) !== undefined) {\r\n            registeredPieces.push(parsedCoordinate);\r\n        }\r\n    }\r\n    if (color === deadColorIndex)\r\n        return [false, false];\r\n    const ambiguousRank = (isCapture && isPawn && isVerticalPlacement(color))\r\n        || registeredPieces.some((c, i) => registeredPieces.some((c2, j) => i !== j && c[0] === c2[0]));\r\n    const ambiguousFile = (isCapture && isPawn && !isVerticalPlacement(color))\r\n        || registeredPieces.some((c, i) => registeredPieces.some((c2, j) => i !== j && c[1] === c2[1]));\r\n    return [ambiguousRank, ambiguousFile];\r\n}\r\nfunction extractPromotion(move) {\r\n    return move.promotion ? `=${move.promotion[0].piece}` : \"\";\r\n}\r\nfunction extractChecksAndCheckmates(metadata) {\r\n    return \"+\".repeat(metadata.checks) + \"#\".repeat(metadata.checkmates);\r\n}\r\nexport const shortenedMoveNotationStringify = (moveWrapper, snapshot, dimension) => {\r\n    let resultingString = \"\";\r\n    let isFirstCapturingMoveSet = false;\r\n    for (const move of moveWrapper.moveData) {\r\n        if (verifyStandardMove(move)) {\r\n            if ((resultingString += generateCastlingString(move)))\r\n                continue;\r\n            resultingString += extractPiece(moveWrapper.metadata);\r\n            const isCapture = !isFirstCapturingMoveSet && moveWrapper.metadata.isCapture;\r\n            const [ambiguousRank, ambiguousFile] = obtainAmbiguousOrthogonality({\r\n                isCapture, move, snapshot, moveMetadata: moveWrapper.metadata\r\n            });\r\n            if (ambiguousFile && !ambiguousRank) {\r\n                resultingString += convertCoordinateToPGN4Array(move.startCoordinates, dimension)[1];\r\n            }\r\n            else if (!ambiguousFile && ambiguousRank) {\r\n                resultingString += convertCoordinateToPGN4Array(move.startCoordinates, dimension)[0];\r\n            }\r\n            else if (ambiguousFile && ambiguousRank) {\r\n                resultingString += convertCoordinateToPGN4(move.startCoordinates, dimension);\r\n            }\r\n            if (isCapture) {\r\n                resultingString += \"x\";\r\n                isFirstCapturingMoveSet = true;\r\n            }\r\n            resultingString += convertCoordinateToPGN4(move.endCoordinates, dimension);\r\n            resultingString += extractPromotion(move);\r\n        }\r\n        else if (verifyDroppingMove(move)) {\r\n            resultingString += `@${move.piece.piece}`;\r\n            resultingString += `${convertCoordinateToPGN4(move.endCoordinates, dimension)}`;\r\n        }\r\n        else if (verifyInternalMove(move)) {\r\n            resultingString += move.type;\r\n        }\r\n        else\r\n            throwOnNever(move);\r\n    }\r\n    resultingString += extractChecksAndCheckmates(moveWrapper.metadata);\r\n    resultingString += moveWrapper.metadata.annotation ?? \"\";\r\n    return resultingString;\r\n};\r\nexport const fullMoveNotationStringify = (moveWrapper) => {\r\n    let resultingString = \"\";\r\n    let firstStandardMoveCaptureSet = false;\r\n    for (const move of moveWrapper.moveData) {\r\n        if (verifyStandardMove(move)) {\r\n            if ((resultingString += generateCastlingString(move)))\r\n                continue;\r\n            resultingString += extractPiece(moveWrapper.metadata);\r\n            resultingString += convertCoordinateToPGN4(move.startCoordinates);\r\n            if (!firstStandardMoveCaptureSet && moveWrapper.metadata.isCapture) {\r\n                resultingString += \"x\";\r\n                firstStandardMoveCaptureSet = true;\r\n            }\r\n            else\r\n                resultingString += \"-\";\r\n            resultingString += convertCoordinateToPGN4(move.endCoordinates);\r\n            resultingString += extractPromotion(move);\r\n        }\r\n        else if (verifyDroppingMove(move)) {\r\n            resultingString += `@${move.piece.piece}`;\r\n            resultingString += `-${convertCoordinateToPGN4(move.endCoordinates)}`;\r\n        }\r\n        else if (verifyInternalMove(move)) {\r\n            resultingString += move.type;\r\n        }\r\n        else\r\n            throwOnNever(move);\r\n    }\r\n    resultingString += extractChecksAndCheckmates(moveWrapper.metadata);\r\n    return resultingString;\r\n};\r\nexport const moveNotation = {\r\n    fullMoveNotation: fullMoveNotationStringify,\r\n    shortenedMoveNotation: shortenedMoveNotationStringify\r\n};\r\n","import { compareMoves, getMoveFromPathAndTree, verifyStandardMove } from './MoveTreeInterface';\r\nimport { moveNotation } from './MoveNotationStringifier';\r\nimport { compareArrays, findLastIndex } from '@utils/ArrayUtils';\r\nimport { pawnPieceString } from '@moveGeneration/GameInformation/GameUnits/PieceString';\r\nimport { colors } from '@moveGeneration/GameInformation/GameData';\r\nexport function alterCurrentPath(current, path) {\r\n    let currentMove = [...current];\r\n    for (let i = 0; i < currentMove.length; i++) {\r\n        if (path[i] > currentMove[i])\r\n            break;\r\n        if (path[i] === currentMove[i]) {\r\n            if (i === path.length - 1) {\r\n                currentMove = currentMove.slice(0, i + 1);\r\n                currentMove[i]--;\r\n                break;\r\n            }\r\n        }\r\n        else {\r\n            currentMove = currentMove.slice(0, i + 1);\r\n            currentMove[i] = path[i] - 1;\r\n            break;\r\n        }\r\n    }\r\n    const indexOfMinus = currentMove.indexOf(-1);\r\n    if (indexOfMinus !== -1) {\r\n        currentMove = currentMove.slice(0, indexOfMinus);\r\n        let lastNumber = 0;\r\n        do {\r\n            const popped = currentMove.pop();\r\n            if (popped === undefined) {\r\n                lastNumber = -1;\r\n                break;\r\n            }\r\n            lastNumber = popped;\r\n        } while (lastNumber <= 0);\r\n        if (lastNumber !== -1)\r\n            currentMove.push(lastNumber);\r\n    }\r\n    return currentMove;\r\n}\r\nexport function verifyValidMove(move) {\r\n    return move !== undefined && !Array.isArray(move);\r\n}\r\nexport function assertValidMove(move) {\r\n    if (!move || Array.isArray(move)) {\r\n        throw new Error(\"The selected move is not a valid move\");\r\n    }\r\n}\r\nexport const createMoveTree = (baseSnapshot) => {\r\n    const snapshots = new WeakMap();\r\n    const boardHashes = new Map();\r\n    const moves = [];\r\n    const startingSnapshot = {\r\n        boardSnapshot: baseSnapshot,\r\n        get hash() {\r\n            throw new Error(\"Should not access hash on base move\");\r\n        },\r\n        get pregeneratedAttacks() {\r\n            throw new Error(\"Should not access pregenerated attacks on base move\");\r\n        }\r\n    };\r\n    function obtainMatchingAlternativeLine(baseMoveWrapper, newMoveWrapper) {\r\n        for (const [alternativeFirstMove] of baseMoveWrapper.alternativeLines) {\r\n            if (alternativeFirstMove.moveData.length !== newMoveWrapper.moveData.length)\r\n                continue;\r\n            if (alternativeFirstMove.moveData.every((m, i) => compareMoves(m, newMoveWrapper.moveData[i]))) {\r\n                return alternativeFirstMove.path;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    function stripEmptyAlternativeLines(current = moves) {\r\n        for (const moveWrapper of current) {\r\n            for (let i = 0; i < moveWrapper.alternativeLines.length; i++) {\r\n                if (moveWrapper.alternativeLines[i].length === 0) {\r\n                    moveWrapper.alternativeLines.splice(i, 1);\r\n                }\r\n                else\r\n                    stripEmptyAlternativeLines(moveWrapper.alternativeLines[i]);\r\n            }\r\n        }\r\n    }\r\n    function stripDeletedMoveHashes(current, currentMove) {\r\n        for (const moveWrapper of current) {\r\n            const snapshot = snapshots.get(moveWrapper);\r\n            if (!snapshot)\r\n                continue;\r\n            const { hash } = snapshot;\r\n            const boardHash = boardHashes.get(hash);\r\n            if (boardHash) {\r\n                if (boardHash.length === 1) {\r\n                    boardHashes.delete(hash);\r\n                }\r\n                else {\r\n                    const currentLine = boardHash.findIndex(p => compareArrays(p, currentMove));\r\n                    if (currentLine === -1) {\r\n                        console.error(\"Current line for move wrapper not found in board hashes\");\r\n                    }\r\n                    else {\r\n                        boardHash.splice(currentLine, 1);\r\n                    }\r\n                }\r\n            }\r\n            for (const line of moveWrapper.alternativeLines)\r\n                stripDeletedMoveHashes(line, currentMove);\r\n        }\r\n    }\r\n    function addBoardSnapshot(parameters, currentMove) {\r\n        const { move, snapshot, fenDataString } = parameters;\r\n        snapshots.set(move, {\r\n            boardSnapshot: snapshot.boardSnapshot,\r\n            pregeneratedAttacks: snapshot.pregeneratedAttacks,\r\n            hash: fenDataString\r\n        });\r\n        const boardHash = boardHashes.get(fenDataString);\r\n        if (boardHash) {\r\n            const hasAdditionalPath = boardHash.find(p => compareArrays(p, currentMove));\r\n            boardHashes.set(fenDataString, hasAdditionalPath ? boardHash : [...boardHash, currentMove.slice()]);\r\n        }\r\n        else\r\n            boardHashes.set(fenDataString, [currentMove.slice()]);\r\n    }\r\n    const assignMoveWrapperKey = (object, key, value) => {\r\n        object[key] = value;\r\n    };\r\n    return {\r\n        moves, currentMove: [-1],\r\n        getMove(path) {\r\n            return getMoveFromPathAndTree(moves, path);\r\n        },\r\n        setNewMove(parameters) {\r\n            const { move } = parameters;\r\n            const moveWrapper = this.getMove(move.path.slice(0, -1));\r\n            let path = move.path.slice();\r\n            if (!moveWrapper)\r\n                return path;\r\n            if (Array.isArray(moveWrapper)) {\r\n                if (moveWrapper.length > move.path[move.path.length - 1]) {\r\n                    const currentMove = this.getMove(move.path);\r\n                    if (Array.isArray(currentMove)) {\r\n                        this.setNewMove({ ...parameters, move: { ...move, path: [...move.path, currentMove.length] } });\r\n                    }\r\n                    else if (currentMove) {\r\n                        const alternativeLine = obtainMatchingAlternativeLine(currentMove, move);\r\n                        if (alternativeLine) {\r\n                            return alternativeLine;\r\n                        }\r\n                        else {\r\n                            currentMove.alternativeLines.push([]);\r\n                            const newMove = { ...move, path: [...move.path, currentMove.alternativeLines.length - 1, 0] };\r\n                            path = newMove.path.slice();\r\n                            return this.setNewMove({ ...parameters, move: newMove });\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    moveWrapper.push(move);\r\n                    addBoardSnapshot(parameters, this.currentMove);\r\n                }\r\n            }\r\n            else {\r\n                let key;\r\n                for (key in move) {\r\n                    if (Object.prototype.hasOwnProperty.call(move, key))\r\n                        assignMoveWrapperKey(moveWrapper, key, move[key]);\r\n                }\r\n                addBoardSnapshot(parameters, this.currentMove);\r\n            }\r\n            return path;\r\n        },\r\n        getBoardSnapshot(move) {\r\n            if (move === -1) {\r\n                return startingSnapshot;\r\n            }\r\n            else {\r\n                return snapshots.get(move);\r\n            }\r\n        },\r\n        deleteMove(path) {\r\n            let items = [];\r\n            const moveWrapper = this.getMove(path.slice(0, -1));\r\n            if (!moveWrapper)\r\n                return;\r\n            const finalIndex = path[path.length - 1];\r\n            if (Array.isArray(moveWrapper)) {\r\n                items = [...moveWrapper.splice(finalIndex, moveWrapper.length - finalIndex)];\r\n            }\r\n            else {\r\n                if (moveWrapper.alternativeLines.length > 0) {\r\n                    items = moveWrapper.alternativeLines.splice(path[path.length - 1], 1)[0];\r\n                }\r\n            }\r\n            stripDeletedMoveHashes(items, this.currentMove);\r\n            stripEmptyAlternativeLines();\r\n            const newCurrentMove = alterCurrentPath(this.currentMove, path);\r\n            this.currentMove = newCurrentMove.length === 0 ? [-1] : newCurrentMove;\r\n        },\r\n        getHash(preliminaryHashString) {\r\n            const hash = boardHashes.get(preliminaryHashString);\r\n            if (hash === undefined)\r\n                return 0;\r\n            let totalCount = 0;\r\n            for (const line of hash) {\r\n                for (let i = 0; i < line.length; i++) {\r\n                    if (i + 1 % 2 !== 0 && i === line.length - 1) {\r\n                        totalCount++;\r\n                    }\r\n                    else if (line[i] !== this.currentMove[i])\r\n                        break;\r\n                }\r\n            }\r\n            return totalCount;\r\n        },\r\n        stringifyMove(moveWrapper, dimension) {\r\n            const snapshot = this.getBoardSnapshot(moveWrapper);\r\n            if (!snapshot) {\r\n                console.error(\"No snapshot assigned when moveWrapper is called\");\r\n                return \"\";\r\n            }\r\n            let key;\r\n            for (key in moveNotation) {\r\n                if (!Object.prototype.hasOwnProperty.call(moveNotation, key))\r\n                    continue;\r\n                moveWrapper.cachedNames[key] = moveNotation[key](moveWrapper, snapshot, dimension);\r\n            }\r\n        },\r\n        augmentMoveWithMetadata(parameters) {\r\n            const { move, board, makeMoveFunction } = parameters;\r\n            const standardMove = move.find((m) => verifyStandardMove(m));\r\n            const movingPiece = standardMove\r\n                ? board.board[standardMove.startCoordinates[0]][standardMove.startCoordinates[1]]\r\n                : pawnPieceString;\r\n            const capturedPieces = standardMove ? board.data.getCapturedPieces(standardMove).length !== 0 : false;\r\n            const postMoveResults = makeMoveFunction();\r\n            const deadColors = [...board.data.fenOptions.tag(\"dead\")];\r\n            const currentSideToMove = board.data.sideToMove, currentMove = board.moves.getMove(board.moves.currentMove);\r\n            assertValidMove(currentMove);\r\n            if (board.moves.currentMove[board.moves.currentMove.length - 1] === 0\r\n                || findLastIndex(deadColors, (b) => !b) === currentSideToMove) {\r\n                const lastCurrentMoves = board.moves.getMove(board.moves.currentMove.slice(0, -1));\r\n                if (!Array.isArray(lastCurrentMoves))\r\n                    throw new Error(\"The selected move is not within an array\");\r\n                for (let i = lastCurrentMoves.length - 1; i >= 0; i--) {\r\n                    const lastCurrent = lastCurrentMoves[i].metadata.currentFullMove;\r\n                    if (lastCurrent) {\r\n                        currentMove.metadata.currentFullMove = lastCurrent + 1;\r\n                        break;\r\n                    }\r\n                    else if (i === 0) {\r\n                        if (currentMove.path.length === 1) {\r\n                            currentMove.metadata.currentFullMove = 1;\r\n                        }\r\n                        else {\r\n                            const alternativeLineContainer = board.moves.getMove(board.moves.currentMove.slice(0, -3));\r\n                            if (!Array.isArray(alternativeLineContainer))\r\n                                throw new Error(\"The selected move is not within an array\");\r\n                            currentMove.metadata.currentFullMove = alternativeLineContainer[findLastIndex(alternativeLineContainer, (m) => Boolean(m.metadata.currentFullMove))]\r\n                                .metadata.currentFullMove;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            currentMove.metadata.currentSideToMove = currentSideToMove;\r\n            currentMove.metadata.isCapture = capturedPieces;\r\n            currentMove.metadata.movingPiece = movingPiece;\r\n            for (const color of colors) {\r\n                if (postMoveResults.checkmates[color]) {\r\n                    currentMove.metadata.checkmates++;\r\n                }\r\n                else if (postMoveResults.checks[color]) {\r\n                    currentMove.metadata.checks++;\r\n                }\r\n            }\r\n            this.stringifyMove(currentMove, Math.max(...board.data.fenOptions.tag(\"dim\")));\r\n        }\r\n    };\r\n};\r\n","import { compareCoordinates } from \"../Board/BoardInterface\";\r\nimport { pawnPieceString, PieceString } from \"../GameInformation/GameUnits/PieceString\";\r\nexport var SpecialMove;\r\n(function (SpecialMove) {\r\n    SpecialMove[SpecialMove[\"CastlingKingside\"] = 0] = \"CastlingKingside\";\r\n    SpecialMove[SpecialMove[\"CastlingQueenside\"] = 1] = \"CastlingQueenside\";\r\n    SpecialMove[SpecialMove[\"EnPassant\"] = 2] = \"EnPassant\";\r\n})(SpecialMove || (SpecialMove = {}));\r\nexport var InternalMoveSignature;\r\n(function (InternalMoveSignature) {\r\n    InternalMoveSignature[\"Resign\"] = \"R\";\r\n    InternalMoveSignature[\"Timeout\"] = \"T\";\r\n    InternalMoveSignature[\"ClaimWin\"] = \"C\";\r\n    InternalMoveSignature[\"DrawByAgreement\"] = \"D\";\r\n    InternalMoveSignature[\"Stalemate\"] = \"S\";\r\n    InternalMoveSignature[\"Pass\"] = \"P\";\r\n    InternalMoveSignature[\"TeamsCheckmate\"] = \"#\";\r\n})(InternalMoveSignature || (InternalMoveSignature = {}));\r\nexport const verifyRequiredMove = (move) => move.length > 0;\r\nexport function verifyMoveWrapperProperties(moveWrapper) {\r\n    return Boolean(moveWrapper.alternativeLines && moveWrapper.comment !== undefined && moveWrapper.path\r\n        && moveWrapper.metadata && moveWrapper.moveData);\r\n}\r\nexport function compareMoves(move1, move2) {\r\n    if (verifyStandardMove(move1)) {\r\n        if (!verifyStandardMove(move2))\r\n            return false;\r\n        return compareCoordinates(move1.startCoordinates, move2.startCoordinates)\r\n            && compareCoordinates(move1.endCoordinates, move2.endCoordinates)\r\n            && (move1.specialType === move2.specialType\r\n                || move1.specialType === SpecialMove.EnPassant\r\n                || move2.specialType === SpecialMove.EnPassant);\r\n    }\r\n    else if (verifyDroppingMove(move1)) {\r\n        if (!verifyDroppingMove(move2))\r\n            return false;\r\n        return compareCoordinates(move1.endCoordinates, move2.endCoordinates)\r\n            && PieceString.comparePieceStrings(move1.piece, move2.piece);\r\n    }\r\n    else if (verifyInternalMove(move1)) {\r\n        if (!verifyInternalMove(move2))\r\n            return false;\r\n        return move1.type === move2.type;\r\n    }\r\n    throw new Error(`Unexpected move signature of first move ${JSON.stringify(move1)}`);\r\n}\r\nexport function createDummyMoveMetadata() {\r\n    return {\r\n        isCapture: false, movingPiece: pawnPieceString,\r\n        checks: 0, checkmates: 0, currentSideToMove: 0,\r\n        highlightedArrows: [], highlightedSquares: []\r\n    };\r\n}\r\nexport const createBaseMoveWrapper = (requiredSettings, settings = {}) => {\r\n    const wrapper = {\r\n        path: requiredSettings.path, moveData: requiredSettings.moveData,\r\n        comment: \"\", alternativeLines: [],\r\n        metadata: createDummyMoveMetadata(),\r\n        cachedNames: {\r\n            fullMoveNotation: \"\",\r\n            shortenedMoveNotation: \"\"\r\n        }\r\n    };\r\n    return {\r\n        ...wrapper,\r\n        ...settings\r\n    };\r\n};\r\nexport const verifyInternalMove = (move) => \"type\" in move;\r\nexport const verifyDroppingMove = (move) => \"piece\" in move;\r\nexport const verifyStandardMove = (move) => \"startCoordinates\" in move;\r\nexport const verifyInternalMoveArray = (move) => \"type\" in move[0];\r\nexport const verifyDroppingMoveArray = (move) => \"piece\" in move[0];\r\nexport const verifyStandardMoveArray = (move) => \"startCoordinates\" in move[0];\r\nexport const getMoveFromPathAndTree = (moves, path) => {\r\n    if (path.length === 0)\r\n        return moves;\r\n    const movePath = path.slice();\r\n    if (movePath[0] >= moves.length)\r\n        return;\r\n    let currentSelection = moves[movePath.shift() ?? 0];\r\n    while (movePath.length > 0) {\r\n        const currentIndex = movePath.shift();\r\n        if (currentIndex !== undefined) {\r\n            if (currentIndex >= currentSelection.alternativeLines.length)\r\n                return;\r\n            const alternativeLine = currentSelection.alternativeLines[currentIndex];\r\n            const index = movePath.shift();\r\n            if (index === undefined) {\r\n                return alternativeLine;\r\n            }\r\n            if (index >= alternativeLine.length)\r\n                return;\r\n            currentSelection = alternativeLine[index];\r\n        }\r\n    }\r\n    return currentSelection;\r\n};\r\nexport const getLatestChainedMoves = (move) => {\r\n    if (move.length > 0 && move[0].nextChainedMoves) {\r\n        return getLatestChainedMoves(move[0].nextChainedMoves);\r\n    }\r\n    else\r\n        return move;\r\n};\r\n","import { boardDimension } from \"@moveGeneration/GameInformation/GameData\";\r\nimport { deadColorIndex } from \"../GameInformation/GameUnits/PieceString\";\r\nimport { AttackType } from \"./PieceControlInterface\";\r\nexport class PieceControl {\r\n    color;\r\n    sliding;\r\n    jumping;\r\n    hooks;\r\n    moves;\r\n    rayGenCache;\r\n    baseRankActive;\r\n    immunePieces;\r\n    fenData;\r\n    board;\r\n    i;\r\n    j;\r\n    __baseClass;\r\n    initDecoratorSettings() { }\r\n    /*---------------------------------- INITIALIZATION -----------------------------------------*/\r\n    constructor() {\r\n        this.moves = [];\r\n        this.color = 0;\r\n        this.sliding = [];\r\n        this.jumping = [];\r\n        this.rayGenCache = [];\r\n        this.hooks = {\r\n            useTrajectory: undefined,\r\n            usePerspective: undefined,\r\n            usePawnLogic: undefined,\r\n            useHopping: false\r\n        };\r\n        this.baseRankActive = false;\r\n        this.immunePieces = [false, false, false, false];\r\n        this.__baseClass = this;\r\n    }\r\n    configure(configuration) {\r\n        this.color = configuration.color;\r\n        this.immunePieces = configuration.immunePieces;\r\n        [this.i, this.j] = configuration.coordinates;\r\n        const baseRankCalc = [13 - this.i, this.j, this.i, 13 - this.j][this.color] - this.fenData.fenOptions.tag(\"pawnBaseRank\");\r\n        this.baseRankActive = configuration.baseRank ?? (baseRankCalc === -1 || baseRankCalc === -2);\r\n        this.board = configuration.board;\r\n    }\r\n    setFENData(fenData) {\r\n        this.fenData = fenData;\r\n    }\r\n    isRayTrace(attackType) { return attackType === AttackType.RayTrace || attackType === AttackType.RayTraceLimited; }\r\n    /*---------------------------------- INITIALIZATION -----------------------------------------*/\r\n    /*-------------------------------------------------------------------------------------------*/\r\n    /*--------------------------------- MOVE GENERATION -----------------------------------------*/\r\n    modifyDisplacements(i, j) {\r\n        const baseDisplacements = [[i, j], [j, -i], [-i, -j], [-j, i]];\r\n        return baseDisplacements[this.color];\r\n    }\r\n    pushMove(settings) {\r\n        if (!settings.isRayGen && this.hooks.usePawnLogic && this.hooks.usePawnLogic.promotionRanks\r\n            && this.hooks.usePawnLogic.promotionRanks[this.color] === (this.color % 2 === 0 ? settings.i : settings.j)\r\n            && this.hooks.usePawnLogic.promotionPieces) {\r\n            this.moves.push({\r\n                move: [settings.i, settings.j, this.hooks.usePawnLogic.promotionPieces.join(\"\")],\r\n                irreversible: settings.irreversible ?? false\r\n            });\r\n            return;\r\n        }\r\n        else {\r\n            this.moves.push({\r\n                move: [settings.i, settings.j],\r\n                irreversible: settings.irreversible ?? false\r\n            });\r\n        }\r\n    }\r\n    generateSlidingAttack(settings) {\r\n        let [displacementI, displacementJ] = settings.displacement, limit = settings.limit ?? Infinity;\r\n        const rayGenCache = settings.rayGenCache, special = settings.special ?? AttackType.Normal;\r\n        let rayTraceLimit = 0;\r\n        if (this.hooks.usePerspective?.[this.color]) {\r\n            [displacementI, displacementJ] = this.modifyDisplacements(displacementI, displacementJ);\r\n        }\r\n        let startI = this.i + displacementI, startJ = this.j + displacementJ;\r\n        const iLength = this.board[0].length, jLength = this.board.length;\r\n        const isRayGen = rayGenCache ?? this.isRayTrace(special);\r\n        while (limit > 0 && startI >= 0 && startI < iLength && startJ >= 0 && startJ < jLength) {\r\n            // TODO add trajectories?\r\n            if (this.getMovePossibility({ displacement: [startI, startJ], special, rayGenCache })) {\r\n                this.pushMove({ i: startI, j: startJ, isRayGen: Boolean(isRayGen), irreversible: settings.irreversible });\r\n            }\r\n            if (special === AttackType.RayTraceLimited && !this.board[startI][startJ].isEmpty()) {\r\n                rayTraceLimit++;\r\n                if (rayTraceLimit === 2)\r\n                    break;\r\n            }\r\n            if (!this.isRayTrace(special) && !this.board[startI][startJ].isEmpty()) {\r\n                break;\r\n            }\r\n            startI += displacementI;\r\n            startJ += displacementJ;\r\n            limit--;\r\n        }\r\n    }\r\n    generateJumpAttack(settings) {\r\n        let [displacementI, displacementJ] = settings.displacement;\r\n        const rayGenCache = settings.rayGenCache, squareBlockingIndex = settings.squareBlockingIndex, special = settings.special ?? AttackType.Normal;\r\n        if (this.hooks.usePerspective?.[this.color]) {\r\n            [displacementI, displacementJ] = this.modifyDisplacements(displacementI, displacementJ);\r\n        }\r\n        const startI = this.i + displacementI, startJ = this.j + displacementJ;\r\n        const isRayGen = rayGenCache ?? this.isRayTrace(special);\r\n        let isTestPassed = true;\r\n        if (this.hooks.useTrajectory && squareBlockingIndex !== undefined) {\r\n            const trajectory = this.hooks.useTrajectory[squareBlockingIndex];\r\n            let trajectoryX, trajectoryY;\r\n            if (this.hooks.usePerspective?.[this.color]) {\r\n                [trajectoryX, trajectoryY] = this.modifyDisplacements(trajectory[0], trajectory[1]);\r\n            }\r\n            else {\r\n                trajectoryX = trajectory[0], trajectoryY = trajectory[1];\r\n            }\r\n            if (!this.getMovePossibility({ displacement: [this.i + trajectoryX, this.j + trajectoryY], special, rayGenCache })) {\r\n                isTestPassed = false;\r\n            }\r\n        }\r\n        if (isTestPassed && this.getMovePossibility({ displacement: [startI, startJ], special, rayGenCache })) {\r\n            this.pushMove({ i: startI, j: startJ, isRayGen: Boolean(isRayGen), irreversible: settings.irreversible });\r\n        }\r\n    }\r\n    getMovePossibility(configuration) {\r\n        const { displacement: [i, j], rayGenCache, special } = configuration;\r\n        if (i < 0 || i >= boardDimension || j < 0 || j >= boardDimension)\r\n            return false;\r\n        const piece = this.board[i][j];\r\n        if (!piece.isEmpty() && piece.color !== deadColorIndex && !rayGenCache && !this.isRayTrace(special ?? AttackType.Normal)) {\r\n            if (this.immunePieces[piece.color] || this.fenData.fenOptions.tag(\"zombieImmune\")[piece.color])\r\n                return false;\r\n        }\r\n        const pushTo = () => {\r\n            if (rayGenCache) {\r\n                this.rayGenCache.push(rayGenCache);\r\n            }\r\n            return true;\r\n        };\r\n        if (special === undefined || special === AttackType.Normal) {\r\n            if (!piece.isWall()) {\r\n                return pushTo();\r\n            }\r\n        }\r\n        else if (special === AttackType.RayGen) {\r\n            if (!piece.isEmpty()) {\r\n                return pushTo();\r\n            }\r\n        }\r\n        else if (special === AttackType.AttackOnly) {\r\n            if (!piece.isEmpty() && !piece.isWall()) {\r\n                return pushTo();\r\n            }\r\n        }\r\n        else if (special === AttackType.MoveOnly) {\r\n            if (piece.isEmpty()) {\r\n                return pushTo();\r\n            }\r\n        }\r\n        else if (this.isRayTrace(special)) {\r\n            return pushTo();\r\n        }\r\n        return false;\r\n    }\r\n    /*--------------------------------- MOVE GENERATION -----------------------------------------*/\r\n    /*-------------------------------------------------------------------------------------------*/\r\n    /*------------------------------- OUTPUT GENERATION -----------------------------------------*/\r\n    getPossibleCells() {\r\n        if (this.hooks.useHopping) {\r\n            this.sliding.forEach(displacement => this.generateSlidingAttack({ displacement, special: AttackType.RayGen, rayGenCache: [...displacement] }));\r\n            const moves = this.moves.slice();\r\n            this.moves = [];\r\n            moves.forEach((s, i) => {\r\n                const startI = s.move[0] + this.rayGenCache[i][0];\r\n                const startJ = s.move[1] + this.rayGenCache[i][1];\r\n                if (this.getMovePossibility({ displacement: [startI, startJ] })) {\r\n                    this.pushMove({ i: startI, j: startJ });\r\n                }\r\n            });\r\n            this.rayGenCache = [];\r\n        }\r\n        else {\r\n            this.sliding.forEach(a => this.generateSlidingAttack({ displacement: a }));\r\n            this.jumping.forEach(a => this.generateJumpAttack({ displacement: a }));\r\n        }\r\n    }\r\n    rayGenJumpingAttacks() {\r\n        this.jumping.forEach(a => this.generateJumpAttack({ displacement: a, special: AttackType.RayTrace }));\r\n        return this.moves.splice(0);\r\n    }\r\n    rayGenSlidingAttacks(trace) {\r\n        const slidingLines = [];\r\n        this.sliding.forEach(a => {\r\n            this.generateSlidingAttack({ displacement: a, special: trace });\r\n            if (this.moves.length !== 0) {\r\n                slidingLines.push(this.moves.splice(0));\r\n            }\r\n        });\r\n        return slidingLines;\r\n    }\r\n    getPseudoLegalMoves() {\r\n        this.getPossibleCells();\r\n        return this.moves.splice(0);\r\n    }\r\n}\r\n","import { createTuple } from \"@client/ts/baseTypes\";\r\nimport { totalPlayers } from \"@moveGeneration/GameInformation/GameData\";\r\nimport { initializeBoardSquares } from \"../../BaseInterfaces\";\r\nimport { emptyPieceString } from \"../GameInformation/GameUnits/PieceString\";\r\nimport { decorateClassWithVariants } from \"../VariantRules/VariantRule\";\r\nimport { copyVariantRules } from \"../VariantRules/VariantRuleSetup\";\r\nimport { PieceControl } from \"./PieceControl\";\r\nimport { pieceControlConfigSettings } from \"./PieceControlInterface\";\r\nexport class PieceControlConfigurator {\r\n    _control;\r\n    _isConfigured;\r\n    constructor(control) {\r\n        this._control = control;\r\n        this._isConfigured = {\r\n            coordinates: [0, 0],\r\n            board: initializeBoardSquares(() => emptyPieceString),\r\n            immunePieces: createTuple(false, totalPlayers),\r\n            color: 0\r\n        };\r\n    }\r\n    setCoordinates(x, y) {\r\n        this._isConfigured.coordinates = [x, y];\r\n        return this;\r\n    }\r\n    setBaseImmunePieces(immune) {\r\n        this._isConfigured.immunePieces = immune;\r\n        return this;\r\n    }\r\n    setColor(color) {\r\n        this._isConfigured.color = color;\r\n        return this;\r\n    }\r\n    setBoard(board) {\r\n        this._isConfigured.board = board;\r\n        return this;\r\n    }\r\n    constructPieceControl() {\r\n        this._control.configure(this._isConfigured);\r\n        return this._control;\r\n    }\r\n}\r\nexport class PieceControlBuilder {\r\n    _generalConfig;\r\n    constructor() { this._generalConfig = {}; }\r\n    setFENData(fenData) { this._generalConfig.fenData = fenData; }\r\n    setVariantRules(rules) { this._generalConfig.variantRules = rules; }\r\n    createPieceControlWrap(letter) {\r\n        const information = pieceControlConfigSettings[letter];\r\n        const control = new information.construct();\r\n        if (!this._generalConfig.fenData || !this._generalConfig.variantRules)\r\n            throw new Error(\"PieceControl builder setup is not complete\");\r\n        control.setFENData(this._generalConfig.fenData);\r\n        const decoratedControl = decorateClassWithVariants(control, PieceControl, copyVariantRules(this._generalConfig.variantRules));\r\n        return () => {\r\n            return new PieceControlConfigurator(decoratedControl);\r\n        };\r\n    }\r\n}\r\n","import { PieceControl } from \"./PieceControl\";\r\nimport { AttackType, createPieceDeclaration, defaultPieces, grasshopperPieceLetter, pawnPieceLetter } from \"./PieceControlInterface\";\r\nconst orthogonalMoves = [[-1, 0], [1, 0], [0, 1], [0, -1]];\r\nconst diagonalMoves = [[-1, -1], [1, 1], [-1, 1], [1, -1]];\r\nconst kingDirections = [...orthogonalMoves, ...diagonalMoves];\r\nconst knightHops = [[-1, -2], [-2, -1], [-1, 2], [2, -1], [-2, 1], [1, -2], [1, 2], [2, 1]];\r\nconst camelHops = [[-1, -3], [-3, -1], [-1, 3], [3, -1], [-3, 1], [1, -3], [1, 3], [3, 1]];\r\nconst dabbabaHops = [[-2, 0], [2, 0], [0, 2], [0, -2]];\r\nconst alfilHops = [[-2, -2], [2, 2], [-2, 2], [2, -2]];\r\nexport const initPieceControlDeclarations = () => {\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.sliding = orthogonalMoves;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 5,\r\n                teamsPoints: 5,\r\n                botFFAValue: 7,\r\n                botTeamsValue: 7\r\n            },\r\n            piece: defaultPieces.rook,\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: false,\r\n                isSliding: true,\r\n                isPawn: false,\r\n                isColorBound: false\r\n            },\r\n            naming: {\r\n                name: \"Rook\",\r\n                shortName: defaultPieces.rook.toLowerCase()\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.sliding = diagonalMoves;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 5,\r\n                teamsPoints: 4,\r\n                botFFAValue: 6,\r\n                botTeamsValue: 6\r\n            },\r\n            piece: defaultPieces.bishop,\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: false,\r\n                isSliding: true,\r\n                isPawn: false,\r\n                isColorBound: true\r\n            },\r\n            naming: {\r\n                name: \"Bishop\",\r\n                shortName: defaultPieces.bishop.toLowerCase()\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.jumping = kingDirections;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 3,\r\n                teamsPoints: 0,\r\n                botFFAValue: 3,\r\n                botTeamsValue: 3\r\n            },\r\n            piece: defaultPieces.king,\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: true,\r\n                isSliding: false,\r\n                isPawn: false,\r\n                isColorBound: false\r\n            },\r\n            naming: {\r\n                name: \"King\",\r\n                shortName: defaultPieces.king.toLowerCase()\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.sliding = kingDirections;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 9,\r\n                teamsPoints: 10,\r\n                botFFAValue: 14,\r\n                botTeamsValue: 15\r\n            },\r\n            piece: defaultPieces.queen,\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: false,\r\n                isSliding: true,\r\n                isPawn: false,\r\n                isColorBound: false\r\n            },\r\n            naming: {\r\n                name: \"Queen\",\r\n                shortName: defaultPieces.queen.toLowerCase()\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.sliding = kingDirections;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 9,\r\n                teamsPoints: 10,\r\n                botFFAValue: 13,\r\n                botTeamsValue: 13\r\n            },\r\n            piece: \"D\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: false,\r\n                isSliding: true,\r\n                isPawn: false,\r\n                isColorBound: false\r\n            },\r\n            naming: {\r\n                name: \"1-point queen\",\r\n                shortName: \"d\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.jumping = knightHops;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 3,\r\n                teamsPoints: 3,\r\n                botFFAValue: 4,\r\n                botTeamsValue: 4\r\n            },\r\n            piece: defaultPieces.knight,\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: true,\r\n                isSliding: false,\r\n                isPawn: false,\r\n                isColorBound: false\r\n            },\r\n            naming: {\r\n                name: \"Knight\",\r\n                shortName: defaultPieces.knight.toLowerCase()\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.jumping = [...knightHops, ...kingDirections];\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 5,\r\n                teamsPoints: 5,\r\n                botFFAValue: 7,\r\n                botTeamsValue: 7\r\n            },\r\n            piece: \"M\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: true,\r\n                isSliding: false,\r\n                isPawn: false,\r\n                isColorBound: false\r\n            },\r\n            naming: {\r\n                name: \"General\",\r\n                shortName: \"m\",\r\n                description: \"combines king and knight\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.jumping = diagonalMoves;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 1,\r\n                teamsPoints: 1,\r\n                botFFAValue: 0.6,\r\n                botTeamsValue: 0.6\r\n            },\r\n            piece: \"F\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: true,\r\n                isSliding: false,\r\n                isPawn: false,\r\n                isColorBound: true\r\n            },\r\n            naming: {\r\n                name: \"Ferz\",\r\n                shortName: \"f\",\r\n                description: \"moves one square diagonally\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.jumping = orthogonalMoves;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 1,\r\n                teamsPoints: 1,\r\n                botFFAValue: 0.4,\r\n                botTeamsValue: 0.4\r\n            },\r\n            piece: \"W\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: true,\r\n                isSliding: false,\r\n                isPawn: false,\r\n                isColorBound: false\r\n            },\r\n            naming: {\r\n                name: \"Wazir\",\r\n                shortName: \"w\",\r\n                description: \"moves one square horizontally or vertically\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.jumping = orthogonalMoves;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 1,\r\n                teamsPoints: 1,\r\n                botFFAValue: 0.4,\r\n                botTeamsValue: 0.4\r\n            },\r\n            piece: \"W\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: true,\r\n                isSliding: false,\r\n                isPawn: false,\r\n                isColorBound: false\r\n            },\r\n            naming: {\r\n                name: \"Wazir\",\r\n                shortName: \"w\",\r\n                description: \"moves one square horizontally or vertically\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.jumping = dabbabaHops;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 1,\r\n                teamsPoints: 1,\r\n                botFFAValue: 1.6,\r\n                botTeamsValue: 1.6\r\n            },\r\n            piece: \"S\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: true,\r\n                isSliding: false,\r\n                isPawn: false,\r\n                isColorBound: true\r\n            },\r\n            naming: {\r\n                name: \"Dabbaba\",\r\n                shortName: \"s\",\r\n                description: \"jumps two squares horizontally or vertically\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.sliding = dabbabaHops;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 4,\r\n                teamsPoints: 4,\r\n                botFFAValue: 5.4,\r\n                botTeamsValue: 5.4\r\n            },\r\n            piece: \"T\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: false,\r\n                isSliding: true,\r\n                isPawn: false,\r\n                isColorBound: true\r\n            },\r\n            naming: {\r\n                name: \"Dabbaba-rider\",\r\n                shortName: \"t\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.jumping = alfilHops;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 1,\r\n                teamsPoints: 1,\r\n                botFFAValue: 0.5,\r\n                botTeamsValue: 0.5\r\n            },\r\n            piece: \"I\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: true,\r\n                isSliding: false,\r\n                isPawn: false,\r\n                isColorBound: true\r\n            },\r\n            naming: {\r\n                name: \"Alfil\",\r\n                shortName: \"i\",\r\n                description: \"jumps two squares diagonally\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.sliding = alfilHops;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 3,\r\n                teamsPoints: 3,\r\n                botFFAValue: 4.5,\r\n                botTeamsValue: 4.5\r\n            },\r\n            piece: \"J\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: false,\r\n                isSliding: true,\r\n                isPawn: false,\r\n                isColorBound: true\r\n            },\r\n            naming: {\r\n                name: \"Alfil-rider\",\r\n                shortName: \"j\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.jumping = [...alfilHops, ...dabbabaHops];\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 3,\r\n                teamsPoints: 3,\r\n                botFFAValue: 3,\r\n                botTeamsValue: 3\r\n            },\r\n            piece: \"Y\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: true,\r\n                isSliding: false,\r\n                isPawn: false,\r\n                isColorBound: true\r\n            },\r\n            naming: {\r\n                name: \"Alibaba\",\r\n                shortName: \"y\",\r\n                description: \"combines alfil and dabbaba\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.sliding = [...alfilHops, ...dabbabaHops];\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 6,\r\n                teamsPoints: 6,\r\n                botFFAValue: 6.2,\r\n                botTeamsValue: 6.2\r\n            },\r\n            piece: \"Z\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: false,\r\n                isSliding: true,\r\n                isPawn: false,\r\n                isColorBound: true\r\n            },\r\n            naming: {\r\n                name: \"Alibaba-rider\",\r\n                shortName: \"z\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.jumping = knightHops;\r\n                this.sliding = kingDirections;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 12,\r\n                teamsPoints: 12,\r\n                botFFAValue: 17,\r\n                botTeamsValue: 17\r\n            },\r\n            piece: \"A\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: true,\r\n                isSliding: true,\r\n                isPawn: false,\r\n                isColorBound: false\r\n            },\r\n            naming: {\r\n                name: \"Amazon\",\r\n                shortName: \"a\",\r\n                description: \"combines queen and knight\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.jumping = camelHops;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 3,\r\n                teamsPoints: 3,\r\n                botFFAValue: 4.2,\r\n                botTeamsValue: 4.2\r\n            },\r\n            piece: \"C\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: true,\r\n                isSliding: false,\r\n                isPawn: false,\r\n                isColorBound: true\r\n            },\r\n            naming: {\r\n                name: \"Camel\",\r\n                shortName: \"c\",\r\n                description: \"an elongated 3-1 knight\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.jumping = knightHops;\r\n                this.sliding = orthogonalMoves;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 7,\r\n                teamsPoints: 7,\r\n                botFFAValue: 10,\r\n                botTeamsValue: 10\r\n            },\r\n            piece: \"E\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: true,\r\n                isSliding: true,\r\n                isPawn: false,\r\n                isColorBound: false\r\n            },\r\n            naming: {\r\n                name: \"Chancellor\",\r\n                shortName: \"a\",\r\n                description: \"combines rook and knight\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.jumping = knightHops;\r\n                this.sliding = diagonalMoves;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 7,\r\n                teamsPoints: 7,\r\n                botFFAValue: 9,\r\n                botTeamsValue: 9\r\n            },\r\n            piece: \"H\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: true,\r\n                isSliding: true,\r\n                isPawn: false,\r\n                isColorBound: false\r\n            },\r\n            naming: {\r\n                name: \"Archbishop\",\r\n                shortName: \"h\",\r\n                description: \"combines bishop and knight\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.sliding = knightHops;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 7,\r\n                teamsPoints: 7,\r\n                botFFAValue: 10,\r\n                botTeamsValue: 10\r\n            },\r\n            piece: \"O\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: false,\r\n                isSliding: true,\r\n                isPawn: false,\r\n                isColorBound: false\r\n            },\r\n            naming: {\r\n                name: \"Knight-rider\",\r\n                shortName: \"o\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.sliding = camelHops;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 7,\r\n                teamsPoints: 7,\r\n                botFFAValue: 8,\r\n                botTeamsValue: 8\r\n            },\r\n            piece: \"L\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: false,\r\n                isSliding: true,\r\n                isPawn: false,\r\n                isColorBound: true\r\n            },\r\n            naming: {\r\n                name: \"Camel-rider\",\r\n                shortName: \"l\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.jumping = [...camelHops, ...knightHops];\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 5,\r\n                teamsPoints: 5,\r\n                botFFAValue: 8,\r\n                botTeamsValue: 8\r\n            },\r\n            piece: \"V\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: true,\r\n                isSliding: false,\r\n                isPawn: false,\r\n                isColorBound: false\r\n            },\r\n            naming: {\r\n                name: \"Wildebeest\",\r\n                shortName: \"v\",\r\n                description: \"combines camel and knight\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.hooks.usePerspective = [true, true, true, true];\r\n                this.hooks.usePawnLogic = {};\r\n            }\r\n            getPossibleCells() {\r\n                this.generateJumpAttack({ displacement: [-1, -1], special: AttackType.AttackOnly });\r\n                this.generateJumpAttack({ displacement: [-1, 1], special: AttackType.AttackOnly });\r\n                this.generateSlidingAttack({\r\n                    displacement: [-1, 0],\r\n                    special: AttackType.MoveOnly,\r\n                    limit: this.baseRankActive ? 2 : 1,\r\n                    irreversible: true\r\n                });\r\n                return this.moves;\r\n            }\r\n            rayGenJumpingAttacks() {\r\n                this.generateJumpAttack({ displacement: [-1, -1], special: AttackType.RayTrace });\r\n                this.generateJumpAttack({ displacement: [-1, 1], special: AttackType.RayTrace });\r\n                const moves = this.moves.slice();\r\n                this.moves = [];\r\n                return moves;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 1,\r\n                teamsPoints: 1,\r\n                botFFAValue: 1,\r\n                botTeamsValue: 0.4\r\n            },\r\n            piece: pawnPieceLetter,\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: true,\r\n                isSliding: false,\r\n                isPawn: true,\r\n                isColorBound: false\r\n            },\r\n            naming: {\r\n                name: \"Pawn\",\r\n                shortName: pawnPieceLetter.toLowerCase()\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.hooks.usePerspective = [true, true, true, true];\r\n                this.hooks.usePawnLogic = {};\r\n            }\r\n            getPossibleCells() {\r\n                this.generateSlidingAttack({\r\n                    displacement: [-1, -1],\r\n                    special: AttackType.MoveOnly,\r\n                    limit: this.baseRankActive ? 2 : 1,\r\n                    irreversible: true\r\n                });\r\n                this.generateSlidingAttack({\r\n                    displacement: [-1, 1],\r\n                    special: AttackType.MoveOnly,\r\n                    limit: this.baseRankActive ? 2 : 1,\r\n                    irreversible: true\r\n                });\r\n                this.generateJumpAttack({ displacement: [-1, -1], special: AttackType.AttackOnly });\r\n                return this.moves;\r\n            }\r\n            rayGenJumpingAttacks() {\r\n                this.generateJumpAttack({ displacement: [-1, -1], special: AttackType.RayTrace });\r\n                const moves = this.moves.slice();\r\n                this.moves = [];\r\n                return moves;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 1,\r\n                teamsPoints: 1,\r\n                botFFAValue: 1,\r\n                botTeamsValue: 0.4\r\n            },\r\n            piece: \"\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: true,\r\n                isSliding: false,\r\n                isPawn: true,\r\n                isColorBound: false\r\n            },\r\n            naming: {\r\n                name: \"Berolina\",\r\n                shortName: \"alpha\",\r\n                description: \"a pawn that moves diagonally and captures forwards\"\r\n            }\r\n        }\r\n    });\r\n    const stoneGeneralControl = createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.hooks.usePerspective = [true, true, true, true];\r\n                this.hooks.usePawnLogic = {};\r\n            }\r\n            getPossibleCells() {\r\n                this.generateSlidingAttack({\r\n                    displacement: [-1, -1],\r\n                    special: AttackType.MoveOnly,\r\n                    limit: this.baseRankActive ? 2 : 0,\r\n                    irreversible: true\r\n                });\r\n                this.generateSlidingAttack({\r\n                    displacement: [-1, 1],\r\n                    special: AttackType.MoveOnly,\r\n                    limit: this.baseRankActive ? 2 : 0,\r\n                    irreversible: true\r\n                });\r\n                this.generateJumpAttack({\r\n                    displacement: [-1, -1],\r\n                    irreversible: true\r\n                });\r\n                this.generateJumpAttack({\r\n                    displacement: [-1, 1],\r\n                    irreversible: true\r\n                });\r\n                return this.moves;\r\n            }\r\n            rayGenJumpingAttacks() {\r\n                this.generateJumpAttack({ displacement: [-1, -1], special: AttackType.RayTrace });\r\n                this.generateJumpAttack({ displacement: [-1, 1], special: AttackType.RayTrace });\r\n                const moves = this.moves.slice();\r\n                this.moves = [];\r\n                return moves;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 1,\r\n                teamsPoints: 1,\r\n                botFFAValue: 1,\r\n                botTeamsValue: 0.4\r\n            },\r\n            piece: \"\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: true,\r\n                isSliding: false,\r\n                isPawn: true,\r\n                isColorBound: false\r\n            },\r\n            naming: {\r\n                name: \"Stone General\",\r\n                shortName: \"gamma\",\r\n                description: \"a pawn that moves and captures diagonally\"\r\n            }\r\n        }\r\n    });\r\n    const soldierControl = createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.hooks.usePerspective = [true, true, true, true];\r\n                this.hooks.usePawnLogic = {};\r\n            }\r\n            getPossibleCells() {\r\n                this.generateSlidingAttack({\r\n                    displacement: [-1, 0],\r\n                    special: AttackType.MoveOnly,\r\n                    limit: this.baseRankActive ? 2 : 0,\r\n                    irreversible: true\r\n                });\r\n                this.generateJumpAttack({\r\n                    displacement: [-1, 0],\r\n                    irreversible: true\r\n                });\r\n                return this.moves;\r\n            }\r\n            rayGenJumpingAttacks() {\r\n                this.generateJumpAttack({ displacement: [-1, 0], special: AttackType.RayTrace });\r\n                const moves = this.moves.slice();\r\n                this.moves = [];\r\n                return moves;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 1,\r\n                teamsPoints: 1,\r\n                botFFAValue: 1,\r\n                botTeamsValue: 0.4\r\n            },\r\n            piece: \"\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: true,\r\n                isSliding: false,\r\n                isPawn: true,\r\n                isColorBound: false\r\n            },\r\n            naming: {\r\n                name: \"Soldier\",\r\n                shortName: \"beta\",\r\n                description: \"a pawn that moves and captures forwards only\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.hooks.usePerspective = [true, true, true, true];\r\n                this.hooks.usePawnLogic = {};\r\n            }\r\n            getPossibleCells() {\r\n                stoneGeneralControl.getPossibleCells.call(this);\r\n                soldierControl.getPossibleCells.call(this);\r\n                return this.moves;\r\n            }\r\n            rayGenJumpingAttacks() {\r\n                stoneGeneralControl.rayGenJumpingAttacks.call(this);\r\n                soldierControl.rayGenJumpingAttacks.call(this);\r\n                const moves = this.moves.slice();\r\n                this.moves = [];\r\n                return moves;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 1,\r\n                teamsPoints: 1,\r\n                botFFAValue: 1,\r\n                botTeamsValue: 0.4\r\n            },\r\n            piece: \"\",\r\n            moveGenerationSettings: {\r\n                isComplex: false,\r\n                isJumping: true,\r\n                isSliding: false,\r\n                isPawn: true,\r\n                isColorBound: false\r\n            },\r\n            naming: {\r\n                name: \"Sergeant\",\r\n                shortName: \"delta\",\r\n                description: \"a pawn that moves and captures forwards and diagonally\"\r\n            }\r\n        }\r\n    });\r\n    const xiangqiHorseControl = createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.hooks.useTrajectory = [[-1, 0], [1, 0], [0, 1], [0, -1]];\r\n            }\r\n            getPossibleCells() {\r\n                this.generateJumpAttack({ displacement: [-1, -2], special: AttackType.Normal, squareBlockingIndex: 3 });\r\n                this.generateJumpAttack({ displacement: [1, -2], special: AttackType.Normal, squareBlockingIndex: 3 });\r\n                this.generateJumpAttack({ displacement: [-1, 2], special: AttackType.Normal, squareBlockingIndex: 2 });\r\n                this.generateJumpAttack({ displacement: [1, 2], special: AttackType.Normal, squareBlockingIndex: 2 });\r\n                this.generateJumpAttack({ displacement: [2, -1], special: AttackType.Normal, squareBlockingIndex: 1 });\r\n                this.generateJumpAttack({ displacement: [2, 1], special: AttackType.Normal, squareBlockingIndex: 1 });\r\n                this.generateJumpAttack({ displacement: [-2, -1], special: AttackType.Normal, squareBlockingIndex: 0 });\r\n                this.generateJumpAttack({ displacement: [-2, 1], special: AttackType.Normal, squareBlockingIndex: 0 });\r\n                return this.moves;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 2,\r\n                teamsPoints: 2,\r\n                botFFAValue: 2.1,\r\n                botTeamsValue: 2.1\r\n            },\r\n            piece: \"U\",\r\n            moveGenerationSettings: {\r\n                isComplex: true,\r\n                isJumping: true,\r\n                isSliding: false,\r\n                isPawn: false,\r\n                isColorBound: false\r\n            },\r\n            naming: {\r\n                name: \"Xiangqi horse\",\r\n                shortName: \"u\",\r\n                description: \"moves one square orthogonally and then one diagonally\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.hooks.useTrajectory = [[-1, 0], [1, 0], [0, 1], [0, -1]];\r\n            }\r\n            getPossibleCells() {\r\n                xiangqiHorseControl.getPossibleCells.call(this);\r\n                this.sliding.forEach(displacement => { this.generateSlidingAttack({ displacement }); });\r\n                return this.moves;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 6,\r\n                teamsPoints: 6,\r\n                botFFAValue: 7.5,\r\n                botTeamsValue: 7.5\r\n            },\r\n            piece: \"\",\r\n            moveGenerationSettings: {\r\n                isComplex: true,\r\n                isJumping: true,\r\n                isSliding: true,\r\n                isPawn: false,\r\n                isColorBound: false\r\n            },\r\n            naming: {\r\n                name: \"Dragon bishop\",\r\n                shortName: \"deltaUpper\",\r\n                description: \"combines bishop and xiangqi horse\"\r\n            }\r\n        }\r\n    });\r\n    createPieceDeclaration({\r\n        baseClassRef: class extends PieceControl {\r\n            constructor() {\r\n                super();\r\n                this.hooks.useHopping = true;\r\n                this.sliding = kingDirections;\r\n            }\r\n        },\r\n        configuration: {\r\n            points: {\r\n                singlesPoints: 3,\r\n                teamsPoints: 3,\r\n                botFFAValue: 5.8,\r\n                botTeamsValue: 5.8\r\n            },\r\n            piece: grasshopperPieceLetter,\r\n            moveGenerationSettings: {\r\n                isComplex: true,\r\n                isJumping: true,\r\n                isSliding: false,\r\n                isPawn: false,\r\n                isColorBound: false\r\n            },\r\n            naming: {\r\n                name: \"Grasshopper\",\r\n                shortName: grasshopperPieceLetter.toLowerCase(),\r\n                description: \"jumps in any direction hopping over the first piece, landing immediately behind it\"\r\n            }\r\n        }\r\n    });\r\n};\r\n","import { nonPlayablePieces } from \"../GameInformation/GameUnits/GameUnits\";\r\nexport var AttackType;\r\n(function (AttackType) {\r\n    AttackType[AttackType[\"Normal\"] = 0] = \"Normal\";\r\n    AttackType[AttackType[\"MoveOnly\"] = 1] = \"MoveOnly\";\r\n    AttackType[AttackType[\"AttackOnly\"] = 2] = \"AttackOnly\";\r\n    AttackType[AttackType[\"RayGen\"] = 3] = \"RayGen\";\r\n    AttackType[AttackType[\"RayTrace\"] = 4] = \"RayTrace\";\r\n    AttackType[AttackType[\"RayTraceLimited\"] = 5] = \"RayTraceLimited\";\r\n})(AttackType || (AttackType = {}));\r\nconst nonPlayableValues = Object.values(nonPlayablePieces);\r\nexport const verifyPieceLetter = (piece) => piece in pieceControlConfigSettings || nonPlayableValues.includes(piece);\r\nexport const pieceControlConfigSettings = nonPlayableValues.reduce((p, n) => ({\r\n    ...p, [n]: {\r\n        points: {\r\n            singlesPoints: 1,\r\n            teamsPoints: 1,\r\n            botFFAValue: 1,\r\n            botTeamsValue: 1,\r\n        },\r\n        piece: n,\r\n        moveGenerationSettings: {\r\n            isComplex: false,\r\n            isJumping: false,\r\n            isSliding: false,\r\n            isPawn: false,\r\n        },\r\n        naming: {\r\n            name: \"Wall\",\r\n            shortName: n\r\n        }\r\n    }\r\n}), {});\r\nexport const createPieceDeclaration = (configuration) => {\r\n    pieceControlConfigSettings[configuration.configuration.piece] = {\r\n        ...configuration.configuration,\r\n        construct: configuration.baseClassRef\r\n    };\r\n    return new configuration.baseClassRef();\r\n};\r\nfunction createPredefinedPieceLetter(letter) {\r\n    return letter;\r\n}\r\nexport const pawnPieceLetter = createPredefinedPieceLetter(\"P\");\r\nexport const wallPieceLetter = createPredefinedPieceLetter(nonPlayablePieces.wall);\r\nexport const grasshopperPieceLetter = createPredefinedPieceLetter(\"G\");\r\nexport const defaultPieces = {\r\n    queen: createPredefinedPieceLetter(\"Q\"),\r\n    rook: createPredefinedPieceLetter(\"R\"),\r\n    bishop: createPredefinedPieceLetter(\"B\"),\r\n    knight: createPredefinedPieceLetter(\"N\"),\r\n    king: createPredefinedPieceLetter(\"K\")\r\n};\r\nexport const emptyLetter = createPredefinedPieceLetter(\"\");\r\nexport const duckLetter = createPredefinedPieceLetter(nonPlayablePieces.duck);\r\n","import { copyClass } from \"@client/ts/utils/ObjectUtils\";\r\nimport { verifyFunctionType, importAll } from \"../../../baseTypes\";\r\nconst verifyHandlerProperty = (handler, key) => key in handler;\r\nconst verifyPrototypeProperty = (superClass, key) => key in superClass.prototype;\r\nexport class VariantRule {\r\n    dependencies = new Map();\r\n    static variantRuleList = [];\r\n    static initVariantRule(rv) {\r\n        VariantRule.variantRuleList.push(rv);\r\n    }\r\n    decorator;\r\n    wrappingDecorators = [];\r\n    initializeBaseHandler(handler) {\r\n        this.decorator = handler;\r\n    }\r\n    initializeWrappingHandler(handler) {\r\n        this.wrappingDecorators.push(handler);\r\n    }\r\n    injectIntoBaseClass(callback) {\r\n        return callback.bind(this.decorator);\r\n    }\r\n    callHandler(method, args) {\r\n        for (const decorator of this.wrappingDecorators) {\r\n            if (!verifyHandlerProperty(decorator, method))\r\n                continue;\r\n            const decoratorMethod = decorator[method];\r\n            if (!verifyFunctionType(decoratorMethod))\r\n                continue;\r\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\r\n            return decoratorMethod.call(decorator, ...args);\r\n        }\r\n        const decoratorType = this.getDecoratorType();\r\n        if (!verifyPrototypeProperty(decoratorType, method))\r\n            throw new Error(\"Method called to callHandler is not a part of prototype\");\r\n        const prototypeMethod = decoratorType.prototype[method];\r\n        if (!verifyFunctionType(prototypeMethod))\r\n            throw new Error(\"Method called to callHandler is not a part of prototype\");\r\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\r\n        return prototypeMethod.call(this.decorator, ...args);\r\n    }\r\n}\r\nconst objectPrototype = new Set(Reflect.ownKeys(Reflect.getPrototypeOf({}) ?? []));\r\nexport function decorateClassWithVariants(baseClass, classReference, variants) {\r\n    if (variants.length === 0)\r\n        return baseClass;\r\n    const decoratorProperties = copyClass(baseClass, classReference, true);\r\n    const methods = new Set();\r\n    decoratorProperties.initDecoratorSettings = () => {\r\n        // Do nothing, this method only exists for the purpose of being overridden\r\n    };\r\n    methods.add(\"initDecoratorSettings\");\r\n    const lastInheritedMethods = new Set();\r\n    let basePrototype = null;\r\n    const verifyKeyInDecoratorProperties = (k) => typeof k !== 'number' && k in decoratorProperties && !objectPrototype.has(k) && !lastInheritedMethods.has(k);\r\n    while ((basePrototype = Reflect.getPrototypeOf(basePrototype ?? baseClass))) {\r\n        Reflect.ownKeys(basePrototype).forEach((k) => {\r\n            if (verifyKeyInDecoratorProperties(k)) {\r\n                decoratorProperties[k] = baseClass[k];\r\n                methods.add(k);\r\n                lastInheritedMethods.add(k);\r\n            }\r\n        });\r\n    }\r\n    const verifyOwnProperty = (k) => k in baseClass;\r\n    for (const property of Object.getOwnPropertyNames(baseClass)) {\r\n        if (!verifyOwnProperty(property))\r\n            throw new Error(\"Expected prototype to not be overridden\");\r\n        const localProperty = property;\r\n        Object.defineProperty(decoratorProperties, property, {\r\n            get: function () {\r\n                return baseClass[localProperty];\r\n            },\r\n            set: function (v) {\r\n                baseClass[localProperty] = v;\r\n            },\r\n            enumerable: true, configurable: false\r\n        });\r\n    }\r\n    decoratorProperties.__baseClass = baseClass;\r\n    for (const method of methods) {\r\n        const variantRuleChain = variants.filter(rv => method in rv);\r\n        if (variantRuleChain.length === 0)\r\n            continue;\r\n        variantRuleChain[0].initializeBaseHandler(decoratorProperties);\r\n        const variantDecorator = variantRuleChain.reduce((p, c) => {\r\n            c.initializeBaseHandler(decoratorProperties);\r\n            c.initializeWrappingHandler(p);\r\n            return c;\r\n        });\r\n        if (method in decoratorProperties) {\r\n            const variant = Reflect.get(variantDecorator, method);\r\n            if (typeof variant === 'function') {\r\n                const variantFunc = variant;\r\n                if (verifyFunctionType(decoratorProperties[method])) {\r\n                    Object.defineProperty(decoratorProperties, method, {\r\n                        value: (...args) => {\r\n                            // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-call\r\n                            return variantFunc.bind(variantDecorator)(...args);\r\n                        }, enumerable: false, writable: false, configurable: false\r\n                    });\r\n                }\r\n            }\r\n        }\r\n    }\r\n    decoratorProperties.initDecoratorSettings();\r\n    return decoratorProperties;\r\n}\r\nimportAll(require.context(\"./VariantRuleDefinitions\", true, /\\.ts$/));\r\n","import { Board } from \"../../../Board/Board\";\r\nimport { InternalMoveSignature } from \"../../../MoveTree/MoveTreeInterface\";\r\nimport { VariantRule } from \"../../VariantRule\";\r\nimport { variantRuleColors } from \"../../VariantRuleInterface\";\r\nconst tag = \"allowPassing\";\r\nexport class AllowPassing extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(AllowPassing);\r\n    }\r\n    getDecoratorType() { return Board; }\r\n    getPublicProperties() {\r\n        return {\r\n            parameterValue: true,\r\n            information: {\r\n                name: \"Allow Passing\",\r\n                description: \"Players can pass instead of making a move\",\r\n                tag,\r\n                color: variantRuleColors.minor,\r\n                displayIcon: \"K\"\r\n            }\r\n        };\r\n    }\r\n    matchesPGNDeclaration(match) {\r\n        return /^AllowPassing$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"AllowPassing\";\r\n    }\r\n    isDisabled({ variantDataRules }) {\r\n        return variantDataRules.giveaway;\r\n    }\r\n    getAllowedInternalMoves(sideToMove = this.decorator.data.sideToMove) {\r\n        const passingMoves = this.decorator.isKingInCheck(sideToMove) ? [] : [{ type: InternalMoveSignature.Pass }];\r\n        for (const decorator of this.wrappingDecorators) {\r\n            if (decorator.getAllowedInternalMoves) {\r\n                return [...passingMoves, ...decorator.getAllowedInternalMoves(sideToMove)];\r\n            }\r\n        }\r\n        return [...passingMoves, ...Board.prototype.getAllowedInternalMoves.call(this.decorator, sideToMove)];\r\n    }\r\n}\r\n","import { VariantType } from \"@moveGeneration/GameInformation/GameData\";\r\nimport { Board } from \"../../../Board/Board\";\r\nimport { VariantRule } from \"../../VariantRule\";\r\nimport { variantRuleColors } from \"../../VariantRuleInterface\";\r\nconst tag = \"alternativeTeams\";\r\nexport class AlternativeTeams extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(AlternativeTeams);\r\n    }\r\n    teammate;\r\n    constructor(teammate) {\r\n        super();\r\n        if (typeof teammate === \"number\") {\r\n            this.teammate = teammate;\r\n        }\r\n        else {\r\n            this.teammate = 2;\r\n        }\r\n    }\r\n    getDecoratorType() { return Board; }\r\n    getPublicProperties() {\r\n        const rbTeams = this.teammate === 1;\r\n        const teamOne = rbTeams ? \"Red & Blue\" : \"Red & Green\";\r\n        const teamTwo = rbTeams ? \"Yellow & Green\" : \"Blue & Yellow\";\r\n        return {\r\n            parameterValue: this.teammate,\r\n            information: {\r\n                name: `${teamOne} vs. ${teamTwo}`,\r\n                description: `Alternative Teams: ${teamOne} form a team against ${teamTwo}`,\r\n                tag,\r\n                color: variantRuleColors.autogenous,\r\n                displayIcon: \"\"\r\n            }\r\n        };\r\n    }\r\n    matchesPGNDeclaration(match) {\r\n        const matchArray = match.match(/^Teammate=(1|3)$/);\r\n        if (matchArray) {\r\n            this.teammate = Number(matchArray[1]);\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    serializeToParsingForm() {\r\n        return `Teammate=${this.teammate}`;\r\n    }\r\n    isDisabled({ gameType }) {\r\n        return gameType !== VariantType.Teams;\r\n    }\r\n    initDecoratorSettings() {\r\n        const teamSettings = this.decorator.gameType.teamSettings;\r\n        if (this.teammate === 1) {\r\n            teamSettings.firstTeamColors = [true, true, false, false];\r\n            teamSettings.secondTeamColors = [false, false, true, true];\r\n        }\r\n        else if (this.teammate === 3) {\r\n            teamSettings.firstTeamColors = [true, false, false, true];\r\n            teamSettings.secondTeamColors = [false, true, true, false];\r\n        }\r\n        for (const decorator of this.wrappingDecorators)\r\n            decorator.initDecoratorSettings?.();\r\n    }\r\n}\r\n","import { Board } from \"../../../Board/Board\";\r\nimport { stringifyCoordinate } from \"../../../Board/BoardInterface\";\r\nimport { InternalMoveSignature } from \"../../../MoveTree/MoveTreeInterface\";\r\nimport { VariantRule } from \"../../VariantRule\";\r\nimport { variantRuleColors } from \"../../VariantRuleInterface\";\r\nconst tag = \"barePieceRule\";\r\nexport class BarePieceRule extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(BarePieceRule);\r\n    }\r\n    getDecoratorType() { return Board; }\r\n    getPublicProperties() {\r\n        return {\r\n            parameterValue: true,\r\n            information: {\r\n                name: \"Bare piece rule\",\r\n                description: \"Players with only one remaining piece are forfeit\",\r\n                tag,\r\n                color: variantRuleColors.minor,\r\n                displayIcon: \"\"\r\n            }\r\n        };\r\n    }\r\n    matchesPGNDeclaration(match) {\r\n        return /^BarePieceLoses$/i.test(match);\r\n    }\r\n    isDisabled() {\r\n        return false;\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"BarePieceLoses\";\r\n    }\r\n    makeMove() {\r\n        const { data: { sideToMove }, board, preGeneratedAttacks } = this.decorator;\r\n        const results = this.callHandler(\"makeMove\", arguments);\r\n        const playerPieces = this.decorator.getPlayerPieces()[sideToMove];\r\n        if (playerPieces.length === 1) {\r\n            const pieceMovements = preGeneratedAttacks[sideToMove].pieceMovements.get(stringifyCoordinate(playerPieces[0]));\r\n            if (pieceMovements) {\r\n                for (const { move: coordinate } of pieceMovements) {\r\n                    if (board[coordinate[0]][coordinate[1]].isPiece()) {\r\n                        return results;\r\n                    }\r\n                }\r\n                return this.decorator.makeMove([{ type: InternalMoveSignature.Resign }]);\r\n            }\r\n        }\r\n        return results;\r\n    }\r\n}\r\n","import { Board } from \"../../../Board/Board\";\r\nimport { DisplaySettings } from \"../../../Board/BoardInterface\";\r\nimport { VariantRule } from \"../../VariantRule\";\r\nimport { variantRuleColors } from \"../../VariantRuleInterface\";\r\nconst tag = \"blindfold\";\r\nexport class Blindfold extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(Blindfold);\r\n    }\r\n    getDecoratorType() { return Board; }\r\n    getPublicProperties() {\r\n        return {\r\n            parameterValue: true,\r\n            information: {\r\n                name: \"Blindfold\",\r\n                description: \"Pieces are invisible\",\r\n                tag,\r\n                color: variantRuleColors.visual,\r\n                displayIcon: \"\"\r\n            }\r\n        };\r\n    }\r\n    matchesPGNDeclaration(match) {\r\n        return /^Blindfold$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"Blindfold\";\r\n    }\r\n    isDisabled({ variantDataRules }) {\r\n        return variantDataRules.fogOfWar;\r\n    }\r\n    getSquareVisibility() {\r\n        const squareVisibility = this.callHandler(\"getSquareVisibility\", arguments);\r\n        return squareVisibility.map((r, i) => r.map((v, j) => {\r\n            if (this.decorator.board[i][j].isWall()) {\r\n                return v;\r\n            }\r\n            else {\r\n                return [...v, DisplaySettings.Blindfolded];\r\n            }\r\n        }));\r\n    }\r\n}\r\n","import { Board } from \"../../../Board/Board\";\r\nimport { VariantRule } from \"../../VariantRule\";\r\nimport { variantRuleColors } from \"../../VariantRuleInterface\";\r\nconst tag = \"captureTheKing\";\r\nexport class CaptureTheKing extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(CaptureTheKing);\r\n    }\r\n    getDecoratorType() { return Board; }\r\n    getPublicProperties() {\r\n        return {\r\n            parameterValue: true,\r\n            information: {\r\n                name: \"Capture the King\",\r\n                description: \"To checkmate, kings must be captured\",\r\n                tag,\r\n                color: variantRuleColors.minor,\r\n                displayIcon: \"\"\r\n            }\r\n        };\r\n    }\r\n    matchesPGNDeclaration(match) {\r\n        return /^CaptureTheKing$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"CaptureTheKing\";\r\n    }\r\n    isDisabled({ variantDataRules }) {\r\n        return variantDataRules.giveaway || variantDataRules.taboo;\r\n    }\r\n    isKingInCheck() {\r\n        return false;\r\n    }\r\n    isTheMoveLegal() {\r\n        return true;\r\n    }\r\n}\r\n","import { getVerticalPlacementModulus, isVerticalPlacement } from \"@client/ts/logic/BaseInterfaces\";\r\nimport { Board } from \"../../../Board/Board\";\r\nimport { boardDimension, colors } from \"../../../GameInformation/GameData\";\r\nimport { VariantRule } from \"../../VariantRule\";\r\nimport { variantRuleColors } from \"../../VariantRuleInterface\";\r\nconst tag = \"chess960\";\r\nexport class Chess960 extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(Chess960);\r\n    }\r\n    static chess960ranges = [...Array.from({ length: 9 }, (_, i) => [960 * (i + 1) + 1, 960 + 960 * (i + 1)]),\r\n        ...Array.from({ length: 5 }, (_, i) => [10000 + 960 * (i + 1) + 1, 10960 + 960 * (i + 1)])];\r\n    static minorPieceCache = (function () {\r\n        const minorPieceCache = [];\r\n        for (let i = 0; i < 4; i++) {\r\n            for (let j = i + 1; j < 5; j++) {\r\n                minorPieceCache.push([i, j]);\r\n            }\r\n        }\r\n        return minorPieceCache;\r\n    })();\r\n    static pieceMasks = [\r\n        [404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959],\r\n        [5, 6, 7, 9, 10, 11, 13, 14, 15, 17, 18, 19, 33, 34, 35, 37, 38, 39, 41, 42, 43, 45, 46, 47, 49, 50, 51, 53, 54, 55, 57, 58, 59, 61, 62, 63, 65, 66, 67, 69, 70, 71, 73, 74, 75, 77, 78, 79, 81, 82, 83, 85, 86, 87, 89, 90, 91, 93, 94, 95, 101, 102, 103, 105, 106, 107, 109, 110, 111, 113, 114, 115, 129, 130, 131, 145, 146, 147, 161, 162, 163, 177, 178, 179, 197, 198, 199, 201, 202, 203, 205, 206, 207, 209, 210, 211, 225, 226, 227, 241, 242, 243, 257, 258, 259, 273, 274, 275, 293, 294, 295, 297, 298, 299, 301, 302, 303, 305, 306, 307, 321, 322, 323, 337, 338, 339, 353, 354, 355, 369, 370, 371, 421, 422, 423, 425, 426, 427, 429, 430, 431, 437, 438, 439, 441, 442, 443, 445, 446, 447, 453, 454, 455, 457, 458, 459, 461, 462, 463, 469, 470, 471, 473, 474, 475, 477, 478, 479, 517, 518, 519, 521, 522, 523, 525, 526, 527, 533, 534, 535, 537, 538, 539, 541, 542, 543, 549, 550, 551, 553, 554, 555, 557, 558, 559, 565, 566, 567, 569, 570, 571, 573, 574, 575, 613, 614, 615, 617, 618, 619, 621, 622, 623, 629, 630, 631, 633, 634, 635, 637, 638, 639, 645, 646, 647, 649, 650, 651, 653, 654, 655, 661, 662, 663, 665, 666, 667, 669, 670, 671],\r\n        [4, 5, 6, 7, 20, 21, 22, 23, 36, 37, 38, 39, 52, 53, 54, 55, 68, 69, 70, 71, 84, 85, 86, 87, 100, 101, 102, 103, 116, 117, 118, 119, 132, 133, 134, 135, 148, 149, 150, 151, 164, 165, 166, 167, 180, 181, 182, 183, 196, 197, 198, 199, 212, 213, 214, 215, 228, 229, 230, 231, 244, 245, 246, 247, 260, 261, 262, 263, 276, 277, 278, 279, 292, 293, 294, 295, 308, 309, 310, 311, 324, 325, 326, 327, 340, 341, 342, 343, 356, 357, 358, 359, 372, 373, 374, 375, 388, 389, 390, 391, 404, 405, 406, 407, 420, 421, 422, 423, 436, 437, 438, 439, 452, 453, 454, 455, 468, 469, 470, 471, 484, 485, 486, 487, 500, 501, 502, 503, 516, 517, 518, 519, 532, 533, 534, 535, 548, 549, 550, 551, 564, 565, 566, 567, 580, 581, 582, 583, 596, 597, 598, 599, 612, 613, 614, 615, 628, 629, 630, 631, 644, 645, 646, 647, 660, 661, 662, 663, 676, 677, 678, 679, 692, 693, 694, 695, 708, 709, 710, 711, 724, 725, 726, 727, 740, 741, 742, 743, 756, 757, 758, 759, 772, 773, 774, 775, 788, 789, 790, 791, 804, 805, 806, 807, 820, 821, 822, 823, 836, 837, 838, 839, 852, 853, 854, 855, 868, 869, 870, 871, 884, 885, 886, 887, 900, 901, 902, 903, 916, 917, 918, 919, 932, 933, 934, 935, 948, 949, 950, 951],\r\n        [16, 20, 34, 35, 38, 39, 40, 44, 58, 59, 62, 63, 112, 116, 130, 131, 134, 135, 136, 140, 154, 155, 158, 159, 208, 212, 226, 227, 230, 231, 232, 236, 250, 251, 254, 255, 304, 308, 322, 323, 326, 327, 328, 332, 346, 347, 350, 351, 400, 404, 418, 419, 422, 423, 424, 428, 442, 443, 446, 447, 496, 500, 514, 515, 518, 519, 520, 524, 538, 539, 542, 543, 592, 596, 610, 611, 614, 615, 616, 620, 634, 635, 638, 639, 688, 692, 706, 707, 710, 711, 712, 716, 730, 731, 734, 735, 784, 788, 802, 803, 806, 807, 808, 812, 826, 827, 830, 831, 880, 884, 898, 899, 902, 903, 904, 908, 922, 923, 926, 927],\r\n        [14, 15, 30, 31, 46, 47, 62, 63, 66, 67, 70, 71, 76, 77, 82, 83, 86, 87, 92, 93, 110, 111, 126, 127, 142, 143, 158, 159, 162, 163, 166, 167, 172, 173, 178, 179, 182, 183, 188, 189, 194, 195, 198, 199, 204, 205, 210, 211, 214, 215, 220, 221, 226, 227, 230, 231, 236, 237, 240, 241, 244, 245, 256, 257, 260, 261, 272, 273, 276, 277, 290, 291, 294, 295, 300, 301, 306, 307, 310, 311, 316, 317, 322, 323, 326, 327, 332, 333, 336, 337, 340, 341, 352, 353, 356, 357, 368, 369, 372, 373, 398, 399, 414, 415, 430, 431, 446, 447, 450, 451, 454, 455, 460, 461, 466, 467, 470, 471, 476, 477, 482, 483, 486, 487, 492, 493, 498, 499, 502, 503, 508, 509, 514, 515, 518, 519, 524, 525, 528, 529, 532, 533, 544, 545, 548, 549, 560, 561, 564, 565, 578, 579, 582, 583, 588, 589, 594, 595, 598, 599, 604, 605, 610, 611, 614, 615, 620, 621, 624, 625, 628, 629, 640, 641, 644, 645, 656, 657, 660, 661, 672, 673, 676, 677, 688, 689, 692, 693, 768, 769, 772, 773, 784, 785, 788, 789, 864, 865, 868, 869, 880, 881, 884, 885],\r\n        [2, 6, 10, 14, 18, 22, 26, 30, 34, 38, 42, 46, 50, 54, 58, 62, 66, 70, 74, 78, 82, 86, 90, 94, 98, 102, 106, 110, 114, 118, 122, 126, 130, 134, 138, 142, 146, 150, 154, 158, 162, 166, 170, 174, 178, 182, 186, 190, 194, 198, 202, 206, 210, 214, 218, 222, 226, 230, 234, 238, 242, 246, 250, 254, 258, 262, 266, 270, 274, 278, 282, 286, 290, 294, 298, 302, 306, 310, 314, 318, 322, 326, 330, 334, 338, 342, 346, 350, 354, 358, 362, 366, 370, 374, 378, 382, 386, 390, 394, 398, 402, 406, 410, 414, 418, 422, 426, 430, 434, 438, 442, 446, 450, 454, 458, 462, 466, 470, 474, 478, 482, 486, 490, 494, 498, 502, 506, 510, 514, 518, 522, 526, 530, 534, 538, 542, 546, 550, 554, 558, 562, 566, 570, 574, 578, 582, 586, 590, 594, 598, 602, 606, 610, 614, 618, 622, 626, 630, 634, 638, 642, 646, 650, 654, 658, 662, 666, 670, 674, 678, 682, 686, 690, 694, 698, 702, 706, 710, 714, 718, 722, 726, 730, 734, 738, 742, 746, 750, 754, 758, 762, 766, 770, 774, 778, 782, 786, 790, 794, 798, 802, 806, 810, 814, 818, 822, 826, 830, 834, 838, 842, 846, 850, 854, 858, 862, 866, 870, 874, 878, 882, 886, 890, 894, 898, 902, 906, 910, 914, 918, 922, 926, 930, 934, 938, 942, 946, 950, 954, 958],\r\n        [192, 193, 194, 196, 197, 198, 200, 201, 202, 208, 209, 210, 212, 213, 214, 216, 217, 218, 224, 225, 226, 228, 229, 230, 232, 233, 234, 240, 241, 242, 244, 245, 246, 248, 249, 250, 291, 295, 299, 307, 311, 315, 323, 327, 331, 339, 343, 347, 355, 359, 363, 368, 369, 370, 372, 373, 374, 376, 377, 378, 480, 481, 482, 484, 485, 486, 488, 489, 490, 496, 497, 498, 500, 501, 502, 504, 505, 506, 512, 513, 514, 516, 517, 518, 520, 521, 522, 528, 529, 530, 532, 533, 534, 536, 537, 538, 579, 583, 587, 595, 599, 603, 611, 615, 619, 627, 631, 635, 643, 647, 651, 656, 657, 658, 660, 661, 662, 664, 665, 666, 672, 673, 674, 676, 677, 678, 680, 681, 682, 688, 689, 690, 692, 693, 694, 696, 697, 698, 704, 705, 706, 708, 709, 710, 712, 713, 714, 720, 721, 722, 724, 725, 726, 728, 729, 730, 771, 775, 779, 787, 791, 795, 803, 807, 811, 819, 823, 827, 835, 839, 843, 848, 849, 850, 852, 853, 854, 856, 857, 858, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 931, 935, 939, 944, 945, 946, 948, 949, 950, 952, 953, 954],\r\n        [1, 2, 4, 5, 6, 8, 9, 10, 12, 13, 14, 16, 17, 18, 20, 21, 22, 24, 25, 26, 28, 29, 30, 32, 33, 34, 36, 37, 38, 40, 41, 42, 44, 45, 46, 48, 49, 50, 52, 53, 54, 56, 57, 58, 60, 61, 62, 64, 65, 66, 68, 69, 70, 72, 73, 74, 76, 77, 78, 96, 97, 98, 100, 101, 102, 104, 105, 106, 108, 109, 110, 112, 113, 114, 116, 117, 118, 120, 121, 122, 124, 125, 126, 128, 129, 130, 132, 133, 134, 136, 137, 138, 140, 141, 142, 144, 145, 146, 148, 149, 150, 152, 153, 154, 156, 157, 158, 160, 161, 162, 164, 165, 166, 168, 169, 170, 172, 173, 174, 192, 193, 194, 196, 197, 198, 200, 201, 202, 204, 205, 206, 208, 209, 210, 212, 213, 214, 216, 217, 218, 220, 221, 222, 224, 225, 226, 228, 229, 230, 232, 233, 234, 236, 237, 238, 240, 241, 242, 244, 245, 246, 248, 249, 250, 252, 253, 254, 256, 257, 258, 260, 261, 262, 264, 265, 266, 268, 269, 270, 384, 385, 386, 388, 389, 390, 392, 393, 394, 396, 397, 398, 400, 401, 402, 404, 405, 406, 408, 409, 410, 412, 413, 414, 416, 417, 418, 420, 421, 422, 424, 425, 426, 428, 429, 430, 432, 433, 434, 436, 437, 438, 440, 441, 442, 444, 445, 446, 448, 449, 450, 452, 453, 454, 456, 457, 458, 460, 461, 462, 480, 481, 482, 484, 485, 486, 488, 489, 490, 492, 493, 494, 496, 497, 498, 500, 501, 502, 504, 505, 506, 508, 509, 510, 512, 513, 514, 516, 517, 518, 520, 521, 522, 524, 525, 526, 528, 529, 530, 532, 533, 534, 536, 537, 538, 540, 541, 542, 544, 545, 546, 548, 549, 550, 552, 553, 554, 556, 557, 558, 672, 673, 674, 676, 677, 678, 680, 681, 682, 684, 685, 686, 688, 689, 690, 692, 693, 694, 696, 697, 698, 700, 701, 702, 704, 705, 706, 708, 709, 710, 712, 713, 714, 716, 717, 718, 720, 721, 722, 724, 725, 726, 728, 729, 730, 732, 733, 734, 736, 737, 738, 740, 741, 742, 744, 745, 746, 748, 749, 750]\r\n    ];\r\n    static c960range = (function () {\r\n        const arr = [...Array(961).keys()];\r\n        arr.shift();\r\n        return arr;\r\n    })();\r\n    static twins = [959, 955, 951, 947, 958, 954, 950, 946, 957, 953, 949, 945, 956, 952, 948, 944, 943, 939, 935, 931, 942, 938, 934, 930, 941, 937, 933, 929, 940, 936, 932, 928, 927, 923, 919, 915, 926, 922, 918, 914, 925, 921, 917, 913, 924, 920, 916, 912, 911, 907, 903, 899, 910, 906, 902, 898, 909, 905, 901, 897, 908, 904, 900, 896, 895, 891, 887, 883, 894, 890, 886, 882, 893, 889, 885, 881, 892, 888, 884, 880, 879, 875, 871, 867, 878, 874, 870, 866, 877, 873, 869, 865, 876, 872, 868, 864, 863, 859, 855, 851, 862, 858, 854, 850, 861, 857, 853, 849, 860, 856, 852, 848, 847, 843, 839, 835, 846, 842, 838, 834, 845, 841, 837, 833, 844, 840, 836, 832, 831, 827, 823, 819, 830, 826, 822, 818, 829, 825, 821, 817, 828, 824, 820, 816, 815, 811, 807, 803, 814, 810, 806, 802, 813, 809, 805, 801, 812, 808, 804, 800, 799, 795, 791, 787, 798, 794, 790, 786, 797, 793, 789, 785, 796, 792, 788, 784, 783, 779, 775, 771, 782, 778, 774, 770, 781, 777, 773, 769, 780, 776, 772, 768, 671, 667, 663, 659, 670, 666, 662, 658, 669, 665, 661, 657, 668, 664, 660, 656, 655, 651, 647, 643, 654, 650, 646, 642, 653, 649, 645, 641, 652, 648, 644, 640, 639, 635, 631, 627, 638, 634, 630, 626, 637, 633, 629, 625, 636, 632, 628, 624, 623, 619, 615, 611, 622, 618, 614, 610, 621, 617, 613, 609, 620, 616, 612, 608, 607, 603, 599, 595, 606, 602, 598, 594, 605, 601, 597, 593, 604, 600, 596, 592, 591, 587, 583, 579, 590, 586, 582, 578, 589, 585, 581, 577, 588, 584, 580, 576, 383, 379, 375, 371, 382, 378, 374, 370, 381, 377, 373, 369, 380, 376, 372, 368, 367, 363, 359, 355, 366, 362, 358, 354, 365, 361, 357, 353, 364, 360, 356, 352, 351, 347, 343, 339, 350, 346, 342, 338, 349, 345, 341, 337, 348, 344, 340, 336, 335, 331, 327, 323, 334, 330, 326, 322, 333, 329, 325, 321, 332, 328, 324, 320, 319, 315, 311, 307, 318, 314, 310, 306, 317, 313, 309, 305, 316, 312, 308, 304, 303, 299, 295, 291, 302, 298, 294, 290, 301, 297, 293, 289, 300, 296, 292, 288, 767, 763, 759, 755, 766, 762, 758, 754, 765, 761, 757, 753, 764, 760, 756, 752, 751, 747, 743, 739, 750, 746, 742, 738, 749, 745, 741, 737, 748, 744, 740, 736, 735, 731, 727, 723, 734, 730, 726, 722, 733, 729, 725, 721, 732, 728, 724, 720, 719, 715, 711, 707, 718, 714, 710, 706, 717, 713, 709, 705, 716, 712, 708, 704, 703, 699, 695, 691, 702, 698, 694, 690, 701, 697, 693, 689, 700, 696, 692, 688, 687, 683, 679, 675, 686, 682, 678, 674, 685, 681, 677, 673, 684, 680, 676, 672, 575, 571, 567, 563, 574, 570, 566, 562, 573, 569, 565, 561, 572, 568, 564, 560, 559, 555, 551, 547, 558, 554, 550, 546, 557, 553, 549, 545, 556, 552, 548, 544, 543, 539, 535, 531, 542, 538, 534, 530, 541, 537, 533, 529, 540, 536, 532, 528, 527, 523, 519, 515, 526, 522, 518, 514, 525, 521, 517, 513, 524, 520, 516, 512, 511, 507, 503, 499, 510, 506, 502, 498, 509, 505, 501, 497, 508, 504, 500, 496, 495, 491, 487, 483, 494, 490, 486, 482, 493, 489, 485, 481, 492, 488, 484, 480, 287, 283, 279, 275, 286, 282, 278, 274, 285, 281, 277, 273, 284, 280, 276, 272, 271, 267, 263, 259, 270, 266, 262, 258, 269, 265, 261, 257, 268, 264, 260, 256, 255, 251, 247, 243, 254, 250, 246, 242, 253, 249, 245, 241, 252, 248, 244, 240, 239, 235, 231, 227, 238, 234, 230, 226, 237, 233, 229, 225, 236, 232, 228, 224, 223, 219, 215, 211, 222, 218, 214, 210, 221, 217, 213, 209, 220, 216, 212, 208, 207, 203, 199, 195, 206, 202, 198, 194, 205, 201, 197, 193, 204, 200, 196, 192, 479, 475, 471, 467, 478, 474, 470, 466, 477, 473, 469, 465, 476, 472, 468, 464, 463, 459, 455, 451, 462, 458, 454, 450, 461, 457, 453, 449, 460, 456, 452, 448, 447, 443, 439, 435, 446, 442, 438, 434, 445, 441, 437, 433, 444, 440, 436, 432, 431, 427, 423, 419, 430, 426, 422, 418, 429, 425, 421, 417, 428, 424, 420, 416, 415, 411, 407, 403, 414, 410, 406, 402, 413, 409, 405, 401, 412, 408, 404, 400, 399, 395, 391, 387, 398, 394, 390, 386, 397, 393, 389, 385, 396, 392, 388, 384, 191, 187, 183, 179, 190, 186, 182, 178, 189, 185, 181, 177, 188, 184, 180, 176, 175, 171, 167, 163, 174, 170, 166, 162, 173, 169, 165, 161, 172, 168, 164, 160, 159, 155, 151, 147, 158, 154, 150, 146, 157, 153, 149, 145, 156, 152, 148, 144, 143, 139, 135, 131, 142, 138, 134, 130, 141, 137, 133, 129, 140, 136, 132, 128, 127, 123, 119, 115, 126, 122, 118, 114, 125, 121, 117, 113, 124, 120, 116, 112, 111, 107, 103, 99, 110, 106, 102, 98, 109, 105, 101, 97, 108, 104, 100, 96, 95, 91, 87, 83, 94, 90, 86, 82, 93, 89, 85, 81, 92, 88, 84, 80, 79, 75, 71, 67, 78, 74, 70, 66, 77, 73, 69, 65, 76, 72, 68, 64, 63, 59, 55, 51, 62, 58, 54, 50, 61, 57, 53, 49, 60, 56, 52, 48, 47, 43, 39, 35, 46, 42, 38, 34, 45, 41, 37, 33, 44, 40, 36, 32, 31, 27, 23, 19, 30, 26, 22, 18, 29, 25, 21, 17, 28, 24, 20, 16, 15, 11, 7, 3, 14, 10, 6, 2, 13, 9, 5, 1, 12, 8, 4, 0];\r\n    static legacy = {\r\n        legacy2PThreshold: 1000,\r\n        legacy2PRank: 3, legacy4Prank: 0,\r\n        legacy2PTakeaway: 6160\r\n    };\r\n    static displacement = [3, 11];\r\n    static createBaseChess960mappings() {\r\n        return {\r\n            colorBoundPieces: [2, 5],\r\n            supermajorPieces: [3],\r\n            minorPieces: [1, 6],\r\n            royalPiece: [4],\r\n            edgePieces: [0, 7]\r\n        };\r\n    }\r\n    static regExp = /Chess960=(\\d{1,5})/i;\r\n    positionID;\r\n    constructor(positionID) {\r\n        super();\r\n        if (typeof positionID === \"number\") {\r\n            this.positionID = positionID;\r\n        }\r\n        else {\r\n            this.positionID = -1;\r\n        }\r\n    }\r\n    getDecoratorType() { return Board; }\r\n    getPublicProperties() {\r\n        return {\r\n            parameterValue: this.positionID,\r\n            information: {\r\n                name: \"Chess960\",\r\n                description: \"Initial position with randomly shuffled pieces on home ranks\",\r\n                tag,\r\n                color: variantRuleColors.startingPosition,\r\n                displayIcon: \"\"\r\n            }\r\n        };\r\n    }\r\n    matchesPGNDeclaration(match) {\r\n        const matchArray = match.match(Chess960.regExp);\r\n        if (matchArray) {\r\n            const newID = Number(matchArray[1]);\r\n            if (newID < 0 || newID > 15760)\r\n                return false;\r\n            this.positionID = newID;\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    serializeToParsingForm() {\r\n        return `Chess960=${this.positionID}`;\r\n    }\r\n    isDisabled() {\r\n        return false;\r\n    }\r\n    initDecoratorSettings() {\r\n        if (this.positionID === -1)\r\n            throw new Error(\"Position ID for Chess960 is not defined\");\r\n        let nr = this.positionID;\r\n        const boardSquares = this.decorator.board;\r\n        let rank = Chess960.chess960ranges.findIndex((r) => nr >= r[0] && nr <= r[1]);\r\n        if (rank === -1) {\r\n            if (nr > Chess960.legacy.legacy2PThreshold) {\r\n                rank = Chess960.legacy.legacy2PRank;\r\n                nr -= Chess960.legacy.legacy2PTakeaway;\r\n            }\r\n            else {\r\n                rank = Chess960.legacy.legacy4Prank;\r\n            }\r\n        }\r\n        const pieceArrays = [[], [], [], []];\r\n        const ranks = [13 - rank, rank, rank, 13 - rank];\r\n        pieceArrays[0] = boardSquares[ranks[0]].slice(Chess960.displacement[0], Chess960.displacement[1]);\r\n        pieceArrays[1] = boardSquares.map((row) => row[ranks[1]]).slice(Chess960.displacement[0], Chess960.displacement[1]);\r\n        pieceArrays[2] = boardSquares[ranks[2]].slice(Chess960.displacement[0], Chess960.displacement[1]);\r\n        pieceArrays[3] = boardSquares.map((row) => row[ranks[3]]).slice(Chess960.displacement[0], Chess960.displacement[1]);\r\n        const walls = pieceArrays.map(a => a.map(p => p.isWall() ? true : false));\r\n        const intersections = [];\r\n        for (const wall of walls) {\r\n            intersections.push(wall.reduce((p, c, i) => {\r\n                if (c) {\r\n                    return p.filter(v => Chess960.pieceMasks[i].includes(v));\r\n                }\r\n                else\r\n                    return p;\r\n            }, Chess960.c960range));\r\n        }\r\n        const calcNr = nr - Chess960.chess960ranges[rank][0];\r\n        const positions = [];\r\n        const generatePositionIndexes = (calcNr) => {\r\n            const colorBoundIndexes = [2 * Math.floor((calcNr % 16 / 4)), 1 + 2 * (calcNr % 16 % 4)].sort();\r\n            const supermajorIndex = Math.floor(calcNr / 16) % 6;\r\n            const minorPieceIndexes = Chess960.minorPieceCache[Math.floor(calcNr / 96) % 10];\r\n            const position = {\r\n                colorBoundPieces: Array(8).fill(false),\r\n                supermajorPieces: Array(8).fill(false),\r\n                minorPieces: Array(8).fill(false),\r\n                royalPiece: Array(8).fill(false),\r\n                edgePieces: Array(8).fill(false)\r\n            };\r\n            let edgeSet = false, royalSet = false, colorDelta = 0, majorDelta = 0;\r\n            for (let i = 0; i < boardDimension - Chess960.displacement[0] * 2; i++) {\r\n                if (i === colorBoundIndexes[0] || i === colorBoundIndexes[1]) {\r\n                    position.colorBoundPieces[i] = true;\r\n                    colorDelta++;\r\n                }\r\n                else if (i === supermajorIndex + colorDelta) {\r\n                    position.supermajorPieces[i] = true;\r\n                    majorDelta++;\r\n                }\r\n                else if (i === minorPieceIndexes[0] + colorDelta + majorDelta || i === minorPieceIndexes[1] + colorDelta + majorDelta) {\r\n                    position.minorPieces[i] = true;\r\n                }\r\n                else {\r\n                    position[edgeSet ? royalSet ? \"edgePieces\" : \"royalPiece\" : \"edgePieces\"][i] = true;\r\n                    royalSet = edgeSet;\r\n                    edgeSet = true;\r\n                }\r\n            }\r\n            return position;\r\n        };\r\n        for (const intersection of intersections) {\r\n            if (intersection.length === 0)\r\n                return null;\r\n            let calcTempNr = calcNr;\r\n            let cycles = 0;\r\n            while (cycles < 2) {\r\n                if (intersection.includes(calcTempNr)) {\r\n                    positions.push(generatePositionIndexes(calcTempNr));\r\n                    break;\r\n                }\r\n                else if (intersection.includes(Chess960.twins[calcTempNr - 1])) {\r\n                    positions.push(generatePositionIndexes(Chess960.twins[calcTempNr - 1]));\r\n                    break;\r\n                }\r\n                calcTempNr++;\r\n                if (calcTempNr === 960)\r\n                    calcTempNr = 0, cycles++;\r\n            }\r\n            if (cycles === 2)\r\n                intersections.push([]);\r\n        }\r\n        const fenData = this.decorator.data;\r\n        const royalPieces = fenData.fenOptions.tag(\"royal\");\r\n        const royalOnCorrectRank = royalPieces.map((r, i) => r !== null\r\n            ? r[getVerticalPlacementModulus(i)] === ranks[i]\r\n                ? r[getVerticalPlacementModulus(i)] : -1 : -1);\r\n        const replaceRow = (player) => {\r\n            const pieces = Chess960.createBaseChess960mappings();\r\n            const royal = royalPieces[player];\r\n            if (!royal)\r\n                return;\r\n            const r = royal[getVerticalPlacementModulus(player)];\r\n            const supermajorOverRoyal = royalOnCorrectRank[player] ? r <= 6 : false;\r\n            for (let i = Chess960.displacement[0]; i < Chess960.displacement[1]; i++) {\r\n                let k;\r\n                for (k in pieces) {\r\n                    if (!Object.prototype.hasOwnProperty.call(pieces, k) || !positions[player][k][i - 3])\r\n                        continue;\r\n                    if (royalOnCorrectRank[player] !== -1 && k === 'royalPiece' && r !== i) {\r\n                        royal[getVerticalPlacementModulus(player)] = i;\r\n                    }\r\n                    const mI = supermajorOverRoyal ? intersections[player].length === 960 ? boardDimension - 1 - i : i : i;\r\n                    const piece = pieces[k].shift();\r\n                    if (piece !== undefined) {\r\n                        boardSquares[isVerticalPlacement(player) ? ranks[player] : mI][isVerticalPlacement(player) ? mI : ranks[player]] =\r\n                            pieceArrays[player][piece];\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        for (const color of colors)\r\n            replaceRow(color);\r\n        for (const decorator of this.wrappingDecorators)\r\n            decorator.initDecoratorSettings?.();\r\n    }\r\n}\r\n","import { Board } from \"../../../Board/Board\";\r\nimport { boardDimension } from \"../../../GameInformation/GameData\";\r\nimport { VariantRule } from \"../../VariantRule\";\r\nimport { variantRuleColors } from \"../../VariantRuleInterface\";\r\nimport { pieceControlConfigSettings } from \"@moveGeneration/PieceControl/PieceControlInterface\";\r\nimport { FiftyMoveRule } from \"../FENDataDecorators/FiftyMoveRule\";\r\nimport { isVerticalPlacement } from \"@client/ts/logic/BaseInterfaces\";\r\nconst tag = \"crazyhouse\";\r\nexport class Crazyhouse extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(Crazyhouse);\r\n    }\r\n    dependencies = new Map([[FiftyMoveRule, [Infinity]]]);\r\n    getDecoratorType() { return Board; }\r\n    getPublicProperties() {\r\n        return {\r\n            parameterValue: true,\r\n            information: {\r\n                name: \"Crazyhouse\",\r\n                description: \"You can drop pieces from banks\",\r\n                tag,\r\n                color: variantRuleColors.extending,\r\n                displayIcon: \"\"\r\n            }\r\n        };\r\n    }\r\n    matchesPGNDeclaration(match) {\r\n        return /^Crazyhouse$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"Crazyhouse\";\r\n    }\r\n    isDisabled() {\r\n        return false;\r\n    }\r\n    initDecoratorSettings() {\r\n        this.decorator.data.fenOptions.setTag(\"areBanksEnabled\", [true, true, true, true]);\r\n        for (const decorator of this.wrappingDecorators)\r\n            decorator.initDecoratorSettings?.();\r\n    }\r\n    getDroppingMoves(piece, color = this.decorator.data.sideToMove) {\r\n        if (piece.color !== color)\r\n            return [];\r\n        const royal = this.decorator.data.fenOptions.tag(\"royal\")[color];\r\n        if (royal && this.decorator.preGeneratedAttacks[color].hoppingPieces[royal[0]][royal[1]])\r\n            return [];\r\n        const isPawn = pieceControlConfigSettings[piece.piece].moveGenerationSettings.isPawn;\r\n        const resultingMoveDrops = [];\r\n        const isRY = isVerticalPlacement(color);\r\n        const pawnPromotionRank = this.decorator.variantData.promotionRank === false ? -1 : this.decorator.variantData.promotionRank;\r\n        const pawnBaseRank = this.decorator.data.fenOptions.tag(\"pawnBaseRank\");\r\n        for (let i = 0; i < boardDimension; i++) {\r\n            if (isPawn && isRY && (pawnPromotionRank === i || pawnBaseRank === i)) {\r\n                continue;\r\n            }\r\n            for (let j = 0; j < boardDimension; j++) {\r\n                if (isPawn && !isRY && (pawnPromotionRank === j || pawnBaseRank === j)) {\r\n                    continue;\r\n                }\r\n                const square = this.decorator.board[i][j];\r\n                if (!square.isEmpty())\r\n                    continue;\r\n                resultingMoveDrops.push({ piece, endCoordinates: [i, j] });\r\n            }\r\n        }\r\n        if (this.decorator.isKingInCheck(color)) {\r\n            return resultingMoveDrops.filter(moveDrop => {\r\n                const { checks, checkmates } = this.decorator.makeMove([moveDrop], true);\r\n                return !checks[color] || checkmates[color] || this.decorator.isKingInCheck(color);\r\n            });\r\n        }\r\n        else {\r\n            return resultingMoveDrops;\r\n        }\r\n    }\r\n}\r\n","import { Board } from \"../../../Board/Board\";\r\nimport { getLatestChainedMoves } from \"../../../MoveTree/MoveTreeInterface\";\r\nimport { VariantRule } from \"../../VariantRule\";\r\nimport { variantRuleColors } from \"../../VariantRuleInterface\";\r\nimport { CaptureTheKing } from \"./CaptureTheKing\";\r\nimport { duckPieceString } from \"../../../GameInformation/GameUnits/PieceString\";\r\nimport { boardDimension } from \"../../../GameInformation/GameData\";\r\nimport { nonPlayablePieces } from \"../../../GameInformation/GameUnits/GameUnits\";\r\nconst tag = \"duckChess\";\r\nexport class DuckChess extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(DuckChess);\r\n    }\r\n    dependencies = new Map([[CaptureTheKing, []]]);\r\n    getDecoratorType() { return Board; }\r\n    getPublicProperties() {\r\n        return {\r\n            parameterValue: true,\r\n            information: {\r\n                name: \"Duck Chess\",\r\n                description: \"The duck must be moved to an empty square after every move\",\r\n                tag,\r\n                color: variantRuleColors.extending,\r\n                displayIcon: \"\"\r\n            }\r\n        };\r\n    }\r\n    matchesPGNDeclaration(match) {\r\n        return /^DuckChess$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"DuckChess\";\r\n    }\r\n    isDisabled({ variantDataRules }) {\r\n        return variantDataRules.taboo;\r\n    }\r\n    getLegalMoves(i, j) {\r\n        const moves = this.callHandler(\"getLegalMoves\", arguments);\r\n        const latestMoves = getLatestChainedMoves(moves);\r\n        const ducks = [], emptySquares = [];\r\n        for (let i = 0; i < boardDimension; i++) {\r\n            for (let j = 0; j < boardDimension; j++) {\r\n                const pieceString = this.decorator.board[i][j];\r\n                if (pieceString.isWall() && pieceString.piece === nonPlayablePieces.duck) {\r\n                    ducks.push([i, j]);\r\n                }\r\n                else if (pieceString.isEmpty()) {\r\n                    emptySquares.push([i, j]);\r\n                }\r\n            }\r\n        }\r\n        const droppingChainedMoves = [];\r\n        const duckChainedMoves = [];\r\n        if (ducks.length === 0) {\r\n            for (const emptySquare of emptySquares) {\r\n                droppingChainedMoves.push({ piece: duckPieceString, endCoordinates: emptySquare });\r\n            }\r\n            droppingChainedMoves.push({ piece: duckPieceString, endCoordinates: [i, j] });\r\n        }\r\n        else {\r\n            for (const duck of ducks) {\r\n                for (const emptySquare of emptySquares) {\r\n                    duckChainedMoves.push({ startCoordinates: duck, endCoordinates: emptySquare });\r\n                }\r\n                duckChainedMoves.push({ startCoordinates: duck, endCoordinates: [i, j] });\r\n            }\r\n        }\r\n        for (const move of latestMoves) {\r\n            move.nextChainedMoves = droppingChainedMoves.length > 0 ? droppingChainedMoves : duckChainedMoves;\r\n        }\r\n        return moves;\r\n    }\r\n}\r\n","import { initializeBoardSquares } from \"../../../../BaseInterfaces\";\r\nimport { Board } from \"../../../Board/Board\";\r\nimport { DisplaySettings, unstringifyCoordinate } from \"../../../Board/BoardInterface\";\r\nimport { VariantRule } from \"../../VariantRule\";\r\nimport { variantRuleColors } from \"../../VariantRuleInterface\";\r\nimport { CaptureTheKing } from \"./CaptureTheKing\";\r\nconst tag = \"fogOfWar\";\r\nexport class FogOfWar extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(FogOfWar);\r\n    }\r\n    dependencies = new Map([[CaptureTheKing, []]]);\r\n    getDecoratorType() { return Board; }\r\n    getPublicProperties() {\r\n        return {\r\n            parameterValue: true,\r\n            information: {\r\n                name: \"Fog of War\",\r\n                description: \"Players can only see their pieces and the squares they can legally move to\",\r\n                tag,\r\n                color: variantRuleColors.widespread,\r\n                displayIcon: \"\"\r\n            }\r\n        };\r\n    }\r\n    matchesPGNDeclaration(match) {\r\n        return /^FogOfWar$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"FogOfWar\";\r\n    }\r\n    isDisabled({ variantDataRules }) {\r\n        return variantDataRules.taboo;\r\n    }\r\n    getSquareVisibility() {\r\n        const currentPlayerMoves = initializeBoardSquares(() => false);\r\n        const preGeneratedAttacks = this.decorator.preGeneratedAttacks[this.decorator.data.sideToMove];\r\n        for (const [piece, moves] of preGeneratedAttacks.pieceMovements) {\r\n            const startingCoordinate = unstringifyCoordinate(piece);\r\n            currentPlayerMoves[startingCoordinate[0]][startingCoordinate[1]] = true;\r\n            for (const { move } of moves) {\r\n                currentPlayerMoves[move[0]][move[1]] = true;\r\n            }\r\n        }\r\n        for (const drop of [...preGeneratedAttacks.pieceDrops.pawn, ...preGeneratedAttacks.pieceDrops.piece]) {\r\n            currentPlayerMoves[drop.endCoordinates[0]][drop.endCoordinates[1]] = true;\r\n        }\r\n        const squareVisibility = this.callHandler(\"getSquareVisibility\", arguments);\r\n        return squareVisibility.map((r, i) => r.map((v, j) => {\r\n            if (this.decorator.board[i][j].isWall() || currentPlayerMoves[i][j]) {\r\n                return v;\r\n            }\r\n            else {\r\n                return [...v, DisplaySettings.Fogged];\r\n            }\r\n        }));\r\n    }\r\n}\r\n","import { Board } from \"../../../Board/Board\";\r\nimport { stringifyCoordinate } from \"../../../Board/BoardInterface\";\r\nimport { VariantRule } from \"../../VariantRule\";\r\nimport { variantRuleColors } from \"../../VariantRuleInterface\";\r\nconst tag = \"forcedCapture\";\r\nexport class ForcedCapture extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(ForcedCapture);\r\n    }\r\n    getDecoratorType() { return Board; }\r\n    getPublicProperties() {\r\n        return {\r\n            parameterValue: true,\r\n            information: {\r\n                name: \"Forced Capture\",\r\n                description: \"Capturing is always compulsory\",\r\n                tag,\r\n                color: variantRuleColors.widespread,\r\n                displayIcon: \"\"\r\n            }\r\n        };\r\n    }\r\n    matchesPGNDeclaration(match) {\r\n        return /^ForcedCapture$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"ForcedCapture\";\r\n    }\r\n    isDisabled() {\r\n        return false;\r\n    }\r\n    pregenerateAttacks() {\r\n        const { data: { sideToMove }, board, preGeneratedAttacks } = this.decorator;\r\n        this.callHandler(\"pregenerateAttacks\", arguments);\r\n        for (const piece of this.decorator.getPlayerPieces()[sideToMove]) {\r\n            const moves = preGeneratedAttacks[sideToMove].pieceMovements.get(stringifyCoordinate(piece));\r\n            if (moves) {\r\n                for (const { move: coordinate } of moves) {\r\n                    if (board[coordinate[0]][coordinate[1]].isPiece()) {\r\n                        preGeneratedAttacks[sideToMove].variantRuleCache.hasCaptures = true;\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        preGeneratedAttacks[sideToMove].variantRuleCache.hasCaptures = false;\r\n    }\r\n    isTheMoveLegal(_, moveData) {\r\n        const isCapturing = this.decorator.data.getCapturedPieces(moveData).length > 0;\r\n        if (!isCapturing && this.decorator.preGeneratedAttacks[this.decorator.data.sideToMove].variantRuleCache.hasCaptures)\r\n            return false;\r\n        return this.callHandler(\"isTheMoveLegal\", arguments);\r\n    }\r\n}\r\n","import { shuffleArray } from \"../../../../../utils/ArrayUtils\";\r\nimport { Board } from \"../../../Board/Board\";\r\nimport { totalPlayers, VariantType } from \"../../../GameInformation/GameData\";\r\nimport { verifyNumericColor } from \"../../../GameInformation/GameUnits/GameUnits\";\r\nimport { VariantRule } from \"../../VariantRule\";\r\nimport { variantRuleColors } from \"../../VariantRuleInterface\";\r\nconst tag = \"anonymous\";\r\nexport class Anonymous extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(Anonymous);\r\n    }\r\n    getDecoratorType() { return Board; }\r\n    getPublicProperties() {\r\n        return {\r\n            parameterValue: true,\r\n            information: {\r\n                name: \"Anonymous\",\r\n                description: \"Players' names and ratings are hidden\",\r\n                tag,\r\n                color: variantRuleColors.metadata,\r\n                displayIcon: \"-\"\r\n            }\r\n        };\r\n    }\r\n    matchesPGNDeclaration(match) {\r\n        return /^Anonymous$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"Anonymous\";\r\n    }\r\n    isDisabled() {\r\n        return false;\r\n    }\r\n    initDecoratorSettings() {\r\n        for (let i = 0; i < totalPlayers; i++) {\r\n            this.decorator.gameData.players[i].name = \"Anonymous\";\r\n            this.decorator.gameData.players[i].elo = undefined;\r\n        }\r\n        for (const decorator of this.wrappingDecorators)\r\n            decorator.initDecoratorSettings?.();\r\n    }\r\n}\r\nconst semiAnonTag = \"semiAnonymous\";\r\nexport class SemiAnonymous extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(Anonymous);\r\n    }\r\n    getDecoratorType() { return Board; }\r\n    getPublicProperties() {\r\n        return {\r\n            parameterValue: true,\r\n            information: {\r\n                name: \"Semi-Anonymous\",\r\n                description: \"Players's colors are hidden\",\r\n                tag: semiAnonTag,\r\n                color: variantRuleColors.metadata,\r\n                displayIcon: \"v\"\r\n            }\r\n        };\r\n    }\r\n    matchesPGNDeclaration(match) {\r\n        return /^Semi-Anonymous$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"Semi-Anonymous\";\r\n    }\r\n    isDisabled() {\r\n        return false;\r\n    }\r\n    initDecoratorSettings() {\r\n        shuffleArray(this.decorator.gameData.players);\r\n        for (const decorator of this.wrappingDecorators)\r\n            decorator.initDecoratorSettings?.();\r\n    }\r\n}\r\nconst spTag = \"selfPartner\";\r\nexport class SelfPartner extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(SelfPartner);\r\n    }\r\n    getDecoratorType() { return Board; }\r\n    getPublicProperties() {\r\n        return {\r\n            parameterValue: true,\r\n            information: {\r\n                name: \"Self-Partner\",\r\n                description: \"Both sides of the team were played by one player\",\r\n                tag: spTag,\r\n                color: variantRuleColors.metadata,\r\n                displayIcon: \"\"\r\n            }\r\n        };\r\n    }\r\n    matchesPGNDeclaration(match) {\r\n        return /^SelfPartner$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"SelfPartner\";\r\n    }\r\n    isDisabled({ gameType, fenTags }) {\r\n        return gameType !== VariantType.Teams || fenTags.resigned.value.filter(Boolean).length !== 0;\r\n    }\r\n    initDecoratorSettings() {\r\n        for (const decorator of this.wrappingDecorators)\r\n            decorator.initDecoratorSettings?.();\r\n        const gameType = this.decorator.gameType;\r\n        const firstTeamPlayer = gameType.teamSettings.firstTeamColors.indexOf(true), secondTeamPlayer = gameType.teamSettings.secondTeamColors.indexOf(true);\r\n        if (verifyNumericColor(firstTeamPlayer)) {\r\n            this.decorator.gameData.players[gameType.getTeammateColor(firstTeamPlayer)].name\r\n                = this.decorator.gameData.players[firstTeamPlayer].name;\r\n        }\r\n        if (verifyNumericColor(secondTeamPlayer)) {\r\n            this.decorator.gameData.players[gameType.getTeammateColor(secondTeamPlayer)].name\r\n                = this.decorator.gameData.players[secondTeamPlayer].name;\r\n        }\r\n    }\r\n}\r\n","import { Board } from \"../../../Board/Board\";\r\nimport { DisplaySettings } from \"../../../Board/BoardInterface\";\r\nimport { VariantRule } from \"../../VariantRule\";\r\nimport { variantRuleColors } from \"../../VariantRuleInterface\";\r\nconst tag = \"ghostboard\";\r\nexport class Ghostboard extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(Ghostboard);\r\n    }\r\n    getDecoratorType() { return Board; }\r\n    getPublicProperties() {\r\n        return {\r\n            parameterValue: true,\r\n            information: {\r\n                name: \"Ghostboard\",\r\n                description: \"Board, clocks and players are invisible\",\r\n                tag,\r\n                color: variantRuleColors.visual,\r\n                displayIcon: \"\"\r\n            }\r\n        };\r\n    }\r\n    matchesPGNDeclaration(match) {\r\n        return /^Ghostboard$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"Ghostboard\";\r\n    }\r\n    isDisabled() {\r\n        return false;\r\n    }\r\n    getSquareVisibility() {\r\n        const squareVisibility = this.callHandler(\"getSquareVisibility\", arguments);\r\n        return squareVisibility.map(r => r.map(v => [...v, DisplaySettings.Ghosted]));\r\n    }\r\n}\r\n","import { Board } from \"../../../Board/Board\";\r\nimport { VariantRule } from \"../../VariantRule\";\r\nimport { variantRuleColors } from \"../../VariantRuleInterface\";\r\nconst tag = \"paradigmChess30\";\r\nexport class ParadigmChess30 extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(ParadigmChess30);\r\n    }\r\n    static paradigmRanges = [...Array.from({ length: 14 }, (_, i) => [30 * (i + 1) + 1, 30 + 30 * (i + 1)])];\r\n    // 0 = color bound, 1 = minor, 2 = major\r\n    static permutations = [[0, 0, 1, 1, 2], [0, 0, 1, 2, 1], [0, 0, 2, 1, 1], [0, 1, 0, 1, 2], [0, 1, 0, 2, 1], [0, 1, 1, 0, 2],\r\n        [0, 1, 1, 2, 0], [0, 1, 2, 0, 1], [0, 1, 2, 1, 0], [0, 2, 0, 1, 1], [0, 2, 1, 0, 1], [0, 2, 1, 1, 0],\r\n        [1, 0, 0, 1, 2], [1, 0, 0, 2, 1], [1, 0, 1, 0, 2], [1, 0, 1, 2, 0], [1, 0, 2, 0, 1], [1, 0, 2, 1, 0],\r\n        [1, 1, 0, 0, 2], [1, 1, 0, 2, 0], [1, 1, 2, 0, 0], [1, 2, 0, 0, 1], [1, 2, 0, 1, 0], [1, 2, 1, 0, 0],\r\n        [2, 0, 0, 1, 1], [2, 0, 1, 0, 1], [2, 0, 1, 1, 0], [2, 1, 0, 0, 1], [2, 1, 0, 1, 0], [2, 1, 1, 0, 0]];\r\n    static legacy = {\r\n        twoPlayerRank: 3,\r\n        twoPlayerAdjustment: 30 * 4\r\n    };\r\n    preMethodExecution = false;\r\n    positionId;\r\n    constructor(positionId) {\r\n        super();\r\n        if (typeof positionId === \"number\") {\r\n            this.positionId = positionId;\r\n        }\r\n        else {\r\n            this.positionId = -1;\r\n        }\r\n    }\r\n    getPublicProperties() {\r\n        return {\r\n            parameterValue: this.positionId,\r\n            information: {\r\n                name: \"Paradigm Chess30\",\r\n                description: \"Paradigm Chess30: Dragon bishops combine the movement of bishop and xiangqi horse. 30 semi-random starting positions\",\r\n                tag,\r\n                color: variantRuleColors.startingPosition,\r\n                displayIcon: \"\"\r\n            }\r\n        };\r\n    }\r\n    getDecoratorType() { return Board; }\r\n    matchesPGNDeclaration(match) {\r\n        const matchArray = match.match(/^ParadigmChess30=((\\d{1,3}))$/i);\r\n        if (matchArray) {\r\n            const newID = Number(matchArray[1]);\r\n            if (newID < 0 || newID > 450)\r\n                return false;\r\n            this.positionId = newID;\r\n            return true;\r\n        }\r\n        else\r\n            return false;\r\n    }\r\n    serializeToParsingForm() {\r\n        return `ParadigmChess30=${this.positionId}`;\r\n    }\r\n    isDisabled() {\r\n        return false;\r\n    }\r\n    getInformation() {\r\n        return { name: \"Paradigm Chess30\", description: \"Paradigm Chess30: Dragon bishops combine the movement of bishop and xiangqi horse. 30 semi-random starting positions\", tag };\r\n    }\r\n    initDecoratorSettings() {\r\n        if (this.positionId === -1)\r\n            throw new Error(\"Position ID for Paradigm Chess30 is not defined\");\r\n        let nr = this.positionId;\r\n        const boardSquares = this.decorator.board;\r\n        const data = this.decorator.data;\r\n        let rank = ParadigmChess30.paradigmRanges.findIndex((r) => nr >= r[0] && nr <= r[1]);\r\n        if (rank === -1) {\r\n            rank = ParadigmChess30.legacy.twoPlayerRank;\r\n            nr += ParadigmChess30.legacy.twoPlayerAdjustment;\r\n        }\r\n        const calcNr = nr - ParadigmChess30.paradigmRanges[rank][0];\r\n        const ranks = [13 - rank, rank, rank, 13 - rank];\r\n        const pieceArrays = [[], [], [], []];\r\n        pieceArrays[0] = boardSquares[ranks[0]].slice(4, 10);\r\n        pieceArrays[1] = boardSquares.map((row) => row[ranks[1]]).slice(4, 10);\r\n        pieceArrays[2] = boardSquares[ranks[2]].slice(4, 10);\r\n        pieceArrays[3] = boardSquares.map((row) => row[ranks[3]]).slice(4, 10);\r\n        const royalPieces = data.fenOptions.tag(\"royal\"), dead = data.fenOptions.tag(\"dead\");\r\n        const replaceRow = (player) => {\r\n            const r = royalPieces[player]?.[player % 2 === 0 ? 1 : 0];\r\n            const pieceCoordinates = [[5, 8], [4, 9], [r === undefined || r >= 7 ? 6 : 7]];\r\n            const moveCoordinate = (i, iter) => {\r\n                if (dead[player])\r\n                    return;\r\n                const coordinateA = player % 2 === 0 ? ranks[player] : iter;\r\n                const coordinateB = player % 2 === 0 ? iter : ranks[player];\r\n                if (pieceArrays[player][pieceCoordinates[i][0] - 4].isWall()\r\n                    || boardSquares[coordinateA][coordinateB].isWall())\r\n                    return;\r\n                royalPieces.some((r) => {\r\n                    if (r && r[0] === coordinateA && r[1] === coordinateB) {\r\n                        r[0] = coordinateB, r[1] = coordinateA;\r\n                        return true;\r\n                    }\r\n                    return false;\r\n                });\r\n                boardSquares[coordinateA][coordinateB] = pieceArrays[player][(pieceCoordinates[i].shift() ?? 4) - 4];\r\n            };\r\n            let c = 0;\r\n            const rp = r === undefined || r >= 7 ? 7 : 6;\r\n            const permutations = rp === 6 ? ParadigmChess30.permutations[calcNr].slice().reverse() : ParadigmChess30.permutations[calcNr];\r\n            for (let i = 4; i < 10; i++) {\r\n                if (i === rp)\r\n                    continue;\r\n                moveCoordinate(permutations[c++], i);\r\n            }\r\n        };\r\n        for (let i = 0; i < 4; i++)\r\n            replaceRow(i);\r\n        for (const decorator of this.wrappingDecorators)\r\n            decorator.initDecoratorSettings?.();\r\n    }\r\n}\r\n","import { Board } from \"../../../Board/Board\";\r\nimport { DisplaySettings } from \"../../../Board/BoardInterface\";\r\nimport { VariantRule } from \"../../VariantRule\";\r\nimport { variantRuleColors } from \"../../VariantRuleInterface\";\r\nconst tag = \"piecesFaceCenter\";\r\nexport class PiecesFaceCenter extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(PiecesFaceCenter);\r\n    }\r\n    getDecoratorType() { return Board; }\r\n    getPublicProperties() {\r\n        return {\r\n            parameterValue: true,\r\n            information: {\r\n                name: \"Pieces Face Center\",\r\n                description: \"Pieces are rotated to face center\",\r\n                tag,\r\n                color: variantRuleColors.visual,\r\n                displayIcon: \"\"\r\n            }\r\n        };\r\n    }\r\n    matchesPGNDeclaration(match) {\r\n        return /^PiecesFaceCenter$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"PiecesFaceCenter\";\r\n    }\r\n    isDisabled() {\r\n        return false;\r\n    }\r\n    getSquareVisibility() {\r\n        const squareVisibility = this.callHandler(\"getSquareVisibility\", arguments);\r\n        return squareVisibility.map((r, i) => r.map((v, j) => {\r\n            if (!this.decorator.board[i][j].isPiece()) {\r\n                return v;\r\n            }\r\n            else {\r\n                return [...v, DisplaySettings.PieceFacesCenter];\r\n            }\r\n        }));\r\n    }\r\n}\r\n","import { Board } from \"../../../Board/Board\";\r\nimport { stringifyCoordinate } from \"../../../Board/BoardInterface\";\r\nimport { colors } from \"../../../GameInformation/GameData\";\r\nimport { verifyRequiredMove, verifyStandardMove } from \"../../../MoveTree/MoveTreeInterface\";\r\nimport { VariantRule } from \"../../VariantRule\";\r\nimport { variantRuleColors } from \"../../VariantRuleInterface\";\r\nconst tag = \"seirawanSetup\";\r\nexport class SeirawanSetup extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(SeirawanSetup);\r\n    }\r\n    getDecoratorType() { return Board; }\r\n    getPublicProperties() {\r\n        return {\r\n            parameterValue: true,\r\n            information: {\r\n                name: \"Seirawan Setup\",\r\n                description: \"When moving a piece for the first time, a piece from the bank can be placed on the vacated square, as part of the move\",\r\n                tag,\r\n                color: variantRuleColors.extending,\r\n                displayIcon: \"\"\r\n            }\r\n        };\r\n    }\r\n    matchesPGNDeclaration(match) {\r\n        return /^SeirawanSetup$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"SeirawanSetup\";\r\n    }\r\n    isDisabled({ variantDataRules }) {\r\n        return variantDataRules.crazyhouse || variantDataRules.setupChess !== false;\r\n    }\r\n    initDecoratorSettings() {\r\n        const fenOptions = this.decorator.data.fenOptions;\r\n        const areBanksEnabled = fenOptions.tag(\"areBanksEnabled\"), dead = fenOptions.tag(\"dead\"), seirawanDrops = fenOptions.tag(\"seirawanDrops\"), bank = fenOptions.tag(\"bank\");\r\n        for (const color of colors) {\r\n            if (!dead[color] && seirawanDrops[color].size > 0 && bank[color].size > 0) {\r\n                areBanksEnabled[color] = true;\r\n            }\r\n        }\r\n        for (const decorator of this.wrappingDecorators)\r\n            decorator.initDecoratorSettings?.();\r\n    }\r\n    makeMove(move) {\r\n        const { fenOptions, sideToMove } = this.decorator.data;\r\n        const areBanksEnabled = fenOptions.tag(\"areBanksEnabled\"), seirawanDrops = fenOptions.tag(\"seirawanDrops\"), bank = fenOptions.tag(\"bank\");\r\n        let disabledIndex = false;\r\n        if (verifyStandardMove(move[0])) {\r\n            seirawanDrops[sideToMove].delete(stringifyCoordinate(move[0].startCoordinates));\r\n            if (seirawanDrops[sideToMove].size === 0 || bank[sideToMove].size === 0) {\r\n                disabledIndex = true;\r\n            }\r\n        }\r\n        const returnValue = this.callHandler(\"makeMove\", arguments);\r\n        if (disabledIndex) {\r\n            seirawanDrops[sideToMove].clear();\r\n            bank[sideToMove].clear();\r\n            areBanksEnabled[sideToMove] = false;\r\n        }\r\n        return returnValue;\r\n    }\r\n    getLegalMoves(i, j) {\r\n        const { fenOptions, sideToMove } = this.decorator.data;\r\n        const seirawanDrops = fenOptions.tag(\"seirawanDrops\"), bank = fenOptions.tag(\"bank\");\r\n        const startCoordinates = [i, j];\r\n        const stringifiedCoordinate = stringifyCoordinate(startCoordinates);\r\n        const coordinate = [...seirawanDrops[sideToMove]].find(c => c === stringifiedCoordinate);\r\n        const validateWithDrops = bank[sideToMove].size !== 0 && coordinate !== undefined;\r\n        const moves = this.callHandler(\"getLegalMoves\", arguments);\r\n        const continuations = [];\r\n        for (const piece of bank[sideToMove].keys()) {\r\n            continuations.push({ piece, endCoordinates: startCoordinates });\r\n        }\r\n        if (validateWithDrops && verifyRequiredMove(continuations)) {\r\n            for (const move of moves) {\r\n                move.nextChainedMoves = continuations;\r\n            }\r\n        }\r\n        return moves;\r\n    }\r\n}\r\n","import { Board } from \"../../../Board/Board\";\r\nimport { compareCoordinates, stringifyCoordinate } from \"../../../Board/BoardInterface\";\r\nimport { VariantRule } from \"../../VariantRule\";\r\nimport { variantRuleColors } from \"../../VariantRuleInterface\";\r\nconst tag = \"selfCheck\";\r\nexport class SelfCheck extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(SelfCheck);\r\n    }\r\n    getDecoratorType() { return Board; }\r\n    getPublicProperties() {\r\n        return {\r\n            parameterValue: true,\r\n            information: {\r\n                name: \"Self-checks cost lives\",\r\n                description: \"Self-checks cost lives. Checkmate yourself to earn points\",\r\n                tag,\r\n                color: variantRuleColors.minor,\r\n                displayIcon: \"\"\r\n            }\r\n        };\r\n    }\r\n    matchesPGNDeclaration(match) {\r\n        return /^SelfCheck$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"SelfCheck\";\r\n    }\r\n    isDisabled({ variantDataRules }) {\r\n        return !variantDataRules.nCheck || !variantDataRules.captureTheKing;\r\n    }\r\n    getCurrentChecks(baseColor = this.decorator.data.sideToMove) {\r\n        const { data: { fenOptions, sideToMove }, preGeneratedAttacks } = this.decorator;\r\n        const baseChecks = this.callHandler(\"getCurrentChecks\", arguments);\r\n        const royal = fenOptions.tag(\"royal\")[baseColor];\r\n        const newCoordinates = [];\r\n        if (royal) {\r\n            for (const [attackingPiece, attackCoordinates] of preGeneratedAttacks[sideToMove].hoppingPieceLines) {\r\n                if (compareCoordinates(attackCoordinates, royal)) {\r\n                    newCoordinates.push(stringifyCoordinate(attackingPiece));\r\n                }\r\n            }\r\n            for (const [attackingPiece, attackLine] of preGeneratedAttacks[sideToMove].slidingPiecesLines) {\r\n                for (const attackCoordinates of attackLine) {\r\n                    if (compareCoordinates(attackCoordinates, royal)) {\r\n                        newCoordinates.push(stringifyCoordinate(attackingPiece));\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        baseChecks[baseColor] = newCoordinates;\r\n        return baseChecks;\r\n    }\r\n}\r\n","import { pieceControlConfigSettings } from \"@moveGeneration/PieceControl/PieceControlInterface\";\r\nimport { createTupleFromCallback } from \"../../../../../baseTypes\";\r\nimport { Board } from \"../../../Board/Board\";\r\nimport { boardDimension, colors } from \"../../../GameInformation/GameData\";\r\nimport { InternalMoveSignature, verifyDroppingMove } from \"../../../MoveTree/MoveTreeInterface\";\r\nimport { VariantRule } from \"../../VariantRule\";\r\nimport { variantRuleColors } from \"../../VariantRuleInterface\";\r\nconst tag = \"setupChess\";\r\nexport class SetupChess extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(SetupChess);\r\n    }\r\n    disabled = false;\r\n    setupPoints;\r\n    wereBanksEnabled = [false, false, false, false];\r\n    permutationCoordinates = [[], [], [], []];\r\n    pawnPermutationCoordinates = [[], [], [], []];\r\n    constructor(setupPoints) {\r\n        super();\r\n        if (typeof setupPoints === \"number\") {\r\n            this.setupPoints = setupPoints;\r\n        }\r\n        else {\r\n            this.setupPoints = 39;\r\n        }\r\n    }\r\n    getDecoratorType() { return Board; }\r\n    getPublicProperties() {\r\n        return {\r\n            parameterValue: this.setupPoints,\r\n            information: {\r\n                name: `Setup ${this.setupPoints}`,\r\n                description: `Set up ${this.setupPoints} points before the game starts`,\r\n                tag,\r\n                color: variantRuleColors.phased,\r\n                displayIcon: \"\"\r\n            }\r\n        };\r\n    }\r\n    matchesPGNDeclaration(match) {\r\n        const matchArray = match.match(/^Setup=(\\d+)$/);\r\n        if (matchArray) {\r\n            this.setupPoints = Number(matchArray[1]);\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    serializeToParsingForm() {\r\n        return `Setup=${this.setupPoints}`;\r\n    }\r\n    isDisabled() {\r\n        return false;\r\n    }\r\n    initDecoratorSettings() {\r\n        const fenOptions = this.decorator.data.fenOptions;\r\n        const areBanksEnabled = fenOptions.tag(\"areBanksEnabled\"), dead = fenOptions.tag(\"dead\"), setupComplete = fenOptions.tag(\"setupComplete\"), setupPoints = fenOptions.tag(\"setupPoints\"), pawnBaseRank = fenOptions.tag(\"pawnBaseRank\"), royal = fenOptions.tag(\"royal\"), castleKingside = fenOptions.tag(\"castleKingside\"), castleQueenside = fenOptions.tag(\"castleQueenside\");\r\n        const areSetupPointsUnset = setupPoints === null;\r\n        const modifyDisplacements = (i, j, color) => {\r\n            const baseDisplacements = [[13 - i, j], [j, i], [i, j], [13 - j, i]];\r\n            return baseDisplacements[color];\r\n        };\r\n        for (const color of colors) {\r\n            let bankEnabled = false;\r\n            if (areBanksEnabled[color]) {\r\n                this.wereBanksEnabled[color] = true;\r\n                bankEnabled = true;\r\n            }\r\n            else if (!setupComplete[color]) {\r\n                areBanksEnabled[color] = true;\r\n                bankEnabled = true;\r\n            }\r\n            if (bankEnabled) {\r\n                const files = createTupleFromCallback((_, i) => i, boardDimension);\r\n                const pawnRanks = [pawnBaseRank, pawnBaseRank + 1].filter(rank => rank >= 0 && rank <= 13);\r\n                const ranks = [pawnBaseRank - 1, ...pawnRanks];\r\n                this.permutationCoordinates[color] = files.flatMap(file => ranks.map((rank) => modifyDisplacements(rank, file, color)));\r\n                this.pawnPermutationCoordinates[color] = files.flatMap(file => pawnRanks.map((rank) => modifyDisplacements(rank, file, color)));\r\n            }\r\n            if (!areSetupPointsUnset && !dead[color]) {\r\n                setupPoints[color] = this.setupPoints;\r\n            }\r\n            if (!royal[color]) {\r\n                castleKingside[color] = false;\r\n                castleQueenside[color] = false;\r\n            }\r\n        }\r\n        for (const decorator of this.wrappingDecorators)\r\n            decorator.initDecoratorSettings?.();\r\n    }\r\n    getLegalMoves() {\r\n        if (!this.disabled)\r\n            return [];\r\n        return this.callHandler(\"getLegalMoves\", arguments);\r\n    }\r\n    getCoordinateList(piece) {\r\n        return pieceControlConfigSettings[piece.piece].moveGenerationSettings.isPawn\r\n            ? this.pawnPermutationCoordinates\r\n            : this.permutationCoordinates;\r\n    }\r\n    getDroppingMoves(piece, color = this.decorator.data.sideToMove) {\r\n        if (piece.color !== color)\r\n            return [];\r\n        if (!this.disabled && !this.decorator.data.fenOptions.tag(\"setupComplete\")[color]) {\r\n            const coordinateList = this.getCoordinateList(piece);\r\n            const resultingMoveDrops = [];\r\n            for (const coordinate of coordinateList[color]) {\r\n                if (this.decorator.board[coordinate[0]][coordinate[1]].isEmpty()) {\r\n                    resultingMoveDrops.push({ piece, endCoordinates: coordinate });\r\n                }\r\n            }\r\n            return resultingMoveDrops;\r\n        }\r\n        else\r\n            return this.callHandler(\"getDroppingMoves\", arguments);\r\n    }\r\n    makeMove(move, ignoreNextMoves = false) {\r\n        const fenOptions = this.decorator.data.fenOptions;\r\n        const areBanksEnabled = fenOptions.tag(\"areBanksEnabled\"), dead = fenOptions.tag(\"dead\"), setupComplete = fenOptions.tag(\"setupComplete\"), setupPoints = fenOptions.tag(\"setupPoints\"), bank = fenOptions.tag(\"bank\"), royal = fenOptions.tag(\"royal\");\r\n        const color = this.decorator.data.sideToMove, moveData = move[0];\r\n        const results = this.callHandler(\"makeMove\", arguments);\r\n        if (!this.disabled && !setupComplete[color] && verifyDroppingMove(moveData)\r\n            && setupPoints) {\r\n            const pointValue = pieceControlConfigSettings[moveData.piece.piece].points.singlesPoints;\r\n            if (moveData.piece.piece === \"K\") {\r\n                bank[color].delete(moveData.piece);\r\n                royal[color] = moveData.endCoordinates;\r\n            }\r\n            else {\r\n                setupPoints[color] -= pointValue;\r\n            }\r\n            const pointsLeft = setupPoints[color];\r\n            for (const [piece] of bank[color]) {\r\n                if (piece.piece !== \"K\" && pointValue > pointsLeft) {\r\n                    bank[color].delete(piece);\r\n                }\r\n            }\r\n            if (bank[color].size === 0) {\r\n                setupComplete[color] = true;\r\n            }\r\n            else {\r\n                const coordinateList = this.getCoordinateList(moveData.piece);\r\n                let anyDrop = false;\r\n                for (const coordinate of coordinateList[color]) {\r\n                    if (this.decorator.board[coordinate[0]][coordinate[1]].isEmpty()) {\r\n                        anyDrop = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!anyDrop) {\r\n                    setupComplete[color] = true;\r\n                }\r\n            }\r\n        }\r\n        if (setupComplete.every((v, i) => v || dead[i])) {\r\n            this.disabled = true;\r\n            for (const color of colors) {\r\n                if (!this.wereBanksEnabled[color]) {\r\n                    areBanksEnabled[color] = false;\r\n                    bank[color].clear();\r\n                }\r\n            }\r\n        }\r\n        if (!this.disabled && !ignoreNextMoves && setupComplete[this.decorator.data.sideToMove]) {\r\n            Board.prototype.makeMove.call(this.decorator, [{ type: InternalMoveSignature.Pass }]);\r\n        }\r\n        return results;\r\n    }\r\n}\r\n","import { Board } from \"../../../Board/Board\";\r\nimport { colors } from \"../../../GameInformation/GameData\";\r\nimport { VariantRule } from \"../../VariantRule\";\r\nimport { variantRuleColors } from \"../../VariantRuleInterface\";\r\nconst tag = \"taboo\";\r\nexport class Taboo extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(Taboo);\r\n    }\r\n    getDecoratorType() { return Board; }\r\n    getPublicProperties() {\r\n        return {\r\n            parameterValue: true,\r\n            information: {\r\n                name: \"Taboo\",\r\n                description: \"Giving check is forbidden\",\r\n                tag,\r\n                color: variantRuleColors.widespread,\r\n                displayIcon: \"=\"\r\n            }\r\n        };\r\n    }\r\n    matchesPGNDeclaration(match) {\r\n        return /^Taboo$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"Taboo\";\r\n    }\r\n    isDisabled() {\r\n        return false;\r\n    }\r\n    isSetupComplex() { return true; }\r\n    isTheMoveLegal(_, moveData) {\r\n        const initialDead = this.decorator.data.fenOptions.tag(\"dead\").slice();\r\n        const snapshot = this.decorator.createSnapshot();\r\n        try {\r\n            this.decorator.makeMove([moveData], true);\r\n            const newDead = this.decorator.data.fenOptions.tag(\"dead\").slice();\r\n            for (const color of colors) {\r\n                if ((!initialDead[color] && newDead[color]) || this.decorator.isKingInCheck(color))\r\n                    return false;\r\n            }\r\n            return true;\r\n        }\r\n        finally {\r\n            this.decorator.loadSnapshot(snapshot);\r\n        }\r\n    }\r\n}\r\n","import { createTuple } from \"@client/ts/baseTypes\";\r\nimport { initializeBoardSquares } from \"@client/ts/logic/BaseInterfaces\";\r\nimport { stringifyCoordinate } from \"@moveGeneration/Board/BoardInterface\";\r\nimport { totalPlayers, colors, VariantType, boardDimension } from \"@moveGeneration/GameInformation/GameData\";\r\nimport { pawnPieceString } from \"@moveGeneration/GameInformation/GameUnits/PieceString\";\r\nimport { InternalMoveSignature, SpecialMove, verifyInternalMove, verifyStandardMove } from \"@moveGeneration/MoveTree/MoveTreeInterface\";\r\nimport { pieceControlConfigSettings } from \"@moveGeneration/PieceControl/PieceControlInterface\";\r\nimport { createBotAlgorithm, ZombieType } from \"../BotInterface\";\r\nimport { randomlyPickNextChainedMoves } from \"./RandomEvaluation\";\r\nconst onlyUnique = (value, index, self) => self.indexOf(value) === index;\r\nconst stringifyKey = (i, j, color) => `${i},${j}/${color ?? \"\"}`;\r\nfunction getPieceInFront(i, j, color) {\r\n    switch (color) {\r\n        case 0:\r\n            return [i - 1, j];\r\n        case 1:\r\n            return [i, j + 1];\r\n        case 2:\r\n            return [i + 1, j];\r\n        case 3:\r\n            return [i, j - 1];\r\n    }\r\n}\r\nfunction createComfuterAlgorithm() {\r\n    let boardAccessors;\r\n    function augmentBoardAccessorsFromBoard(board) {\r\n        return {\r\n            board,\r\n            boardSquares: board.board, data: board.data, remainingReal: board.data.getRealPlayers(),\r\n            remaining: board.data.fenOptions.tag(\"dead\").map((v, i) => v ? false : i).filter(v => v === false),\r\n            coverage: initializeBoardSquares(() => []),\r\n            pieces: board.getPlayerPieces(), controls: board.controls, royal: board.data.fenOptions.tag(\"royal\"),\r\n            hangingCache: new Map(), coverageCache: new Map(), pieceValueCache: new Map()\r\n        };\r\n    }\r\n    function initializeBoardAccessorsFromBoard(board) {\r\n        const promotionRank = board.variantData.promotionRank !== false\r\n            ? [boardDimension - board.variantData.promotionRank,\r\n                board.variantData.promotionRank - 1, board.variantData.promotionRank - 1,\r\n                boardDimension - board.variantData.promotionRank]\r\n            : createTuple(99, totalPlayers);\r\n        boardAccessors = {\r\n            ...augmentBoardAccessorsFromBoard(board),\r\n            variantData: board.variantData, promotionRank,\r\n            isFFA: board.gameType.isFFA(), isTeams: !board.gameType.isFFA(),\r\n            zombieType: board.data.fenOptions.tag(\"zombieType\"), defaultSideToMove: board.data.sideToMove\r\n        };\r\n    }\r\n    function getDistanceFromPromotion(color, i, j) {\r\n        if (i === -1)\r\n            return 99;\r\n        return Math.abs(boardAccessors.promotionRank[color] - (color & 1 ? i : j)) || 99;\r\n    }\r\n    function getDistanceFromKing(i, j, color) {\r\n        if (i === -1)\r\n            return 999;\r\n        const royalPiece = boardAccessors.royal[color];\r\n        if (!royalPiece)\r\n            return 999;\r\n        const x = Math.abs(i - royalPiece[0]), y = Math.abs(j - royalPiece[1]);\r\n        if (x === 0 && y === 0)\r\n            return 999;\r\n        return Math.max(x, y);\r\n    }\r\n    function inspectCoverage() {\r\n        const { board, boardSquares, pieces, coverage } = boardAccessors;\r\n        for (const color of colors) {\r\n            for (const coordinate of pieces[color]) {\r\n                const pc = boardSquares[coordinate[0]][coordinate[1]];\r\n                if (!pc.isPiece())\r\n                    continue;\r\n                const destinations = board.preGeneratedAttacks[color].pieceMovements.get(stringifyCoordinate(coordinate));\r\n                if (!destinations)\r\n                    continue;\r\n                for (const dest of destinations) {\r\n                    coverage[dest.move[0]][dest.move[1]].push(coordinate);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function getCoverage(i, j, color) {\r\n        const { coverageCache, coverage, boardSquares, data, board, zombieType, defaultSideToMove } = boardAccessors;\r\n        const resigned = data.fenOptions.tag(\"resigned\");\r\n        const key = stringifyKey(i, j, color);\r\n        if (coverageCache.has(key))\r\n            return coverageCache.get(key);\r\n        const attackers = [], defenders = [];\r\n        const cvg = coverage[i][j];\r\n        if (cvg.length) {\r\n            for (const pieceC of cvg) {\r\n                const piece = boardSquares[pieceC[0]][pieceC[1]];\r\n                if (!piece.isPiece())\r\n                    continue;\r\n                const pieceColor = piece.color;\r\n                if (resigned[pieceColor] && zombieType[pieceColor] === ZombieType.Rando)\r\n                    continue;\r\n                if (board.gameType.isSameTeam(pieceColor, defaultSideToMove)) {\r\n                    defenders.push(pieceC);\r\n                }\r\n                else {\r\n                    attackers.push(pieceC);\r\n                }\r\n            }\r\n        }\r\n        const cache = color === defaultSideToMove ? { attackers, defenders } : { defenders: attackers, attackers: defenders };\r\n        coverageCache.set(key, cache);\r\n        return cache;\r\n    }\r\n    function getPieceValue(i, j) {\r\n        const { boardSquares, pieceValueCache, isFFA, isTeams, remainingReal, royal, board } = boardAccessors;\r\n        const coordinates = [i, j];\r\n        const pieceString = boardSquares[i][j];\r\n        if (!pieceString.isPiece())\r\n            return 0;\r\n        const piece = pieceString.piece;\r\n        const key = `${coordinates[0]},${coordinates[1]}/${pieceString.color}`;\r\n        if (pieceValueCache.has(key))\r\n            return pieceValueCache.get(key);\r\n        let value = 0;\r\n        const controlSetting = pieceControlConfigSettings[piece];\r\n        if (!controlSetting.moveGenerationSettings.isPawn) {\r\n            value = isTeams ? controlSetting.points.botTeamsValue : controlSetting.points.botFFAValue;\r\n        }\r\n        else {\r\n            value = isFFA ? 1 : 0.4;\r\n            const promotionDistance = getDistanceFromPromotion(pieceString.color, ...coordinates);\r\n            value += 2 / (getDistanceFromKing(...coordinates, pieceString.color) * 3) * (remainingReal / 4);\r\n            value += 3 / (promotionDistance * 3);\r\n            if (promotionDistance < 2) {\r\n                const inFront = getPieceInFront(...coordinates, pieceString.color);\r\n                const { attackers, defenders } = getCoverage(...inFront, pieceString.color);\r\n                if (!defenders.length) {\r\n                    value += 3 / promotionDistance;\r\n                }\r\n                if (attackers.length < defenders.length) {\r\n                    value += 2 / promotionDistance;\r\n                }\r\n            }\r\n        }\r\n        let isRoyal = false;\r\n        for (const royalPiece of royal) {\r\n            if (!royalPiece)\r\n                continue;\r\n            if (royalPiece[0] === coordinates[0] && royalPiece[1] === coordinates[1]) {\r\n                isRoyal = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!isRoyal && piece !== pawnPieceString.piece) {\r\n            for (const color of colors) {\r\n                if (!board.gameType.isSameTeam(color, pieceString.color)) {\r\n                    let d = getDistanceFromKing(...coordinates, color);\r\n                    if (d < 3)\r\n                        d = 2;\r\n                    value += (5 - remainingReal) / d;\r\n                }\r\n            }\r\n        }\r\n        pieceValueCache.set(key, value);\r\n        return value;\r\n    }\r\n    function getCoordinationEval(player) {\r\n        const { pieces, remainingReal } = boardAccessors;\r\n        let e = 0;\r\n        for (const piece of pieces[player]) {\r\n            const { defenders } = getCoverage(piece[0], piece[1], player);\r\n            for (const d of defenders)\r\n                e += 30 / (getPieceValue(d[0], d[1]) * 2);\r\n        }\r\n        if (remainingReal === 2) {\r\n            e *= 0.4;\r\n        }\r\n        else if (remainingReal === 3) {\r\n            e *= 0.7;\r\n        }\r\n        return e / 55;\r\n    }\r\n    function firstPlayerMovesBefore(p1, p2) {\r\n        const { data, defaultSideToMove } = boardAccessors;\r\n        let next = data.nextTurn();\r\n        do {\r\n            if (p1 === next)\r\n                return true;\r\n            if (p2 === next)\r\n                return false;\r\n            next = data.nextTurn(next);\r\n        } while (next !== defaultSideToMove);\r\n        return true;\r\n    }\r\n    function canRespondDirectlyToThreat(player, attackers) {\r\n        const { boardSquares } = boardAccessors;\r\n        let attackingPlayers = [];\r\n        for (const pc of attackers) {\r\n            const square = boardSquares[pc[0]][pc[1]];\r\n            if (!square.isPiece())\r\n                continue;\r\n            attackingPlayers.push(square.color);\r\n        }\r\n        attackingPlayers = attackingPlayers.filter(onlyUnique);\r\n        for (const a of attackingPlayers) {\r\n            if (firstPlayerMovesBefore(player, a))\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n    function hanging(i, j, pieceValue = getPieceValue(i, j)) {\r\n        const { hangingCache, boardSquares, remaining, data } = boardAccessors;\r\n        const key = stringifyKey(i, j);\r\n        if (hangingCache.has(key))\r\n            return hangingCache.get(key);\r\n        const square = boardSquares[i][j];\r\n        if (!square.isPiece())\r\n            return 0;\r\n        const { attackers, defenders } = getCoverage(i, j, square.color);\r\n        let attackerValue = 999;\r\n        for (const pc of attackers) {\r\n            attackerValue = Math.min(attackerValue, getPieceValue(pc[0], pc[1]));\r\n        }\r\n        let attackedFromLeft = false;\r\n        const nextTurn = data.nextTurn(square.color);\r\n        if (remaining.length > 2) {\r\n            for (const pc of attackers) {\r\n                if (boardSquares[pc[0]][pc[1]].color === nextTurn) {\r\n                    attackedFromLeft = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        const threatened = pieceValue - attackerValue;\r\n        let pawnDefends;\r\n        for (const pc of defenders) {\r\n            if (boardSquares[pc[0]][pc[1]].piece === pawnPieceString.piece) {\r\n                pawnDefends = pc;\r\n                break;\r\n            }\r\n        }\r\n        let h = 0;\r\n        const underDefended = attackers.length - defenders.length > 0;\r\n        if (underDefended)\r\n            h = pieceValue;\r\n        if (underDefended && pawnDefends)\r\n            h = 0;\r\n        if (pawnDefends && attackers.length - defenders.length > 1) {\r\n            h = getPieceValue(pawnDefends[0], pawnDefends[1]);\r\n        }\r\n        if (!h && threatened > 0)\r\n            h = threatened;\r\n        if (!h && attackedFromLeft && threatened >= -2) {\r\n            h = -threatened;\r\n        }\r\n        if (h && canRespondDirectlyToThreat(square.color, attackers)) {\r\n            h /= 6;\r\n        }\r\n        hangingCache.set(key, h);\r\n        return h;\r\n    }\r\n    function getMobilityEval(player) {\r\n        const { pieces, boardSquares, isTeams, royal, defaultSideToMove, board } = boardAccessors;\r\n        let e = 0;\r\n        for (const coordinate of pieces[player]) {\r\n            if (hanging(coordinate[0], coordinate[1]) > 2)\r\n                continue;\r\n            const piece = boardSquares[coordinate[0]][coordinate[1]];\r\n            if (!piece.isPiece())\r\n                continue;\r\n            let destinations = board.preGeneratedAttacks[player].pieceMovements.get(stringifyCoordinate(coordinate))?.length ?? 0;\r\n            if (/[QDAEH]/.test(piece.piece))\r\n                destinations /= isTeams ? 2 : 3;\r\n            if (/[RBV]]/.test(piece.piece))\r\n                destinations /= isTeams ? 1.5 : 2;\r\n            e += destinations / (isTeams ? 10 : board.gameType.type === VariantType.Solo ? 21 : 16);\r\n            let isRoyal = false;\r\n            for (const royalPiece of royal) {\r\n                if (!royalPiece)\r\n                    continue;\r\n                if (royalPiece[0] === coordinate[0] && royalPiece[1] === coordinate[1]) {\r\n                    isRoyal = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!isRoyal && !isTeams && piece.piece === pawnPieceString.piece) {\r\n                const blockedBy = getPieceInFront(coordinate[0], coordinate[1], player);\r\n                const bSqr = boardSquares[blockedBy[0]][blockedBy[1]];\r\n                if (bSqr.isEmpty())\r\n                    continue;\r\n                if (!bSqr.isPiece()) {\r\n                    e -= 2;\r\n                }\r\n                else if (board.gameType.isSameTeam(bSqr.color, defaultSideToMove)) {\r\n                    e -= 0.5;\r\n                }\r\n                else if (bSqr.piece === pawnPieceString.piece) {\r\n                    e -= 1.8;\r\n                }\r\n                else if (player === bSqr.color) {\r\n                    e -= 0.5;\r\n                }\r\n            }\r\n        }\r\n        return e;\r\n    }\r\n    function getDistFromHill(player) {\r\n        const royalPiece = boardAccessors.royal[player];\r\n        if (!royalPiece)\r\n            return 999;\r\n        const x = Math.abs(6.5 - royalPiece[0]);\r\n        const y = Math.abs(6.5 - royalPiece[1]);\r\n        const d = (x + y) / 2 + Math.max(x, y) / 2;\r\n        if (!d)\r\n            return 999;\r\n        return d;\r\n    }\r\n    function getMatesEval() {\r\n        const { board, variantData, data, pieces, remainingReal } = boardAccessors;\r\n        board.data.sideToMove = board.data.previousTurn();\r\n        const { checkmates, stalemates, checks } = board.getCheckmatesAndStalemates();\r\n        board.data.sideToMove = board.data.nextTurn();\r\n        let e = 0;\r\n        for (const color of colors) {\r\n            if (checkmates[color]) {\r\n                e += 500;\r\n            }\r\n            else if (stalemates[color])\r\n                e -= 300;\r\n        }\r\n        const checksLength = checks.filter(Boolean).length;\r\n        if (checksLength === 3) {\r\n            e += 10;\r\n        }\r\n        else if (checksLength === 2) {\r\n            e += 1;\r\n        }\r\n        else if (checksLength === 1) {\r\n            const prev = data.previousTurn();\r\n            if (remainingReal > 2 && checks[prev]) {\r\n                e += 1.2;\r\n            }\r\n            else if (remainingReal === 2) {\r\n                e += 0.1;\r\n            }\r\n            else {\r\n                e += 0.4;\r\n            }\r\n        }\r\n        if (checksLength && variantData.nCheck) {\r\n            for (const color of colors) {\r\n                const lives = data.fenOptions.tag(\"lives\")[color];\r\n                if (lives && checks[color])\r\n                    e += 4 / (lives + 1);\r\n            }\r\n            e += 0.3;\r\n        }\r\n        if (variantData.barePieceRule) {\r\n            for (const color of colors) {\r\n                if (pieces[color].length <= 1)\r\n                    e += 300;\r\n            }\r\n        }\r\n        return e;\r\n    }\r\n    function getMaterialEval() {\r\n        const { board, pieces, isTeams, remainingReal, defaultSideToMove, variantData } = boardAccessors;\r\n        let myMaterial = 0, oppMaterial = 0;\r\n        for (const color of colors) {\r\n            if (board.gameType.isSameTeam(color, defaultSideToMove)) {\r\n                for (const pc of pieces[color]) {\r\n                    let pieceValue = getPieceValue(pc[0], pc[1]);\r\n                    pieceValue -= hanging(pc[0], pc[1]);\r\n                    myMaterial += pieceValue;\r\n                }\r\n            }\r\n            else {\r\n                for (const pc of pieces[color]) {\r\n                    let pcVal = getPieceValue(pc[0], pc[1]);\r\n                    if (!isTeams && remainingReal === 4 && Math.abs(color - defaultSideToMove) === 2 && !variantData.giveaway) {\r\n                        pcVal /= board.gameType.type === VariantType.Solo ? 2 : 3;\r\n                    }\r\n                    pcVal -= hanging(pc[0], pc[1], pcVal);\r\n                    oppMaterial -= pcVal;\r\n                }\r\n            }\r\n        }\r\n        if (!isTeams && remainingReal === 4) {\r\n            oppMaterial /= 1.4;\r\n            myMaterial *= 1.2;\r\n        }\r\n        if (!isTeams && remainingReal === 3) {\r\n            oppMaterial /= 1.25;\r\n            myMaterial *= 1.1;\r\n        }\r\n        myMaterial *= 2;\r\n        oppMaterial *= 2;\r\n        return { myMaterial, oppMaterial };\r\n    }\r\n    function getPinsEval() {\r\n        const { board, royal, pieces, defaultSideToMove, remainingReal } = boardAccessors;\r\n        let pinnedEval = 0, discovsEval = 0;\r\n        for (const i of colors) {\r\n            const discovered = [];\r\n            const pins = [];\r\n            for (const piece of pieces[i]) {\r\n                const royalPiece = royal[i];\r\n                if (!royalPiece)\r\n                    break;\r\n                if (royalPiece[0] === piece[0] && royalPiece[1] === piece[1])\r\n                    continue;\r\n                const [royalX, royalY] = royalPiece;\r\n                const pieceX = piece[0], pieceY = piece[1];\r\n                for (const [attackPiece, attackLine] of board.preGeneratedAttacks[i].slidingPiecesRayTracing) {\r\n                    let isPieceUnderAttack = false, isRoyalUnderAttack = false;\r\n                    for (const [attackedX, attackedY] of attackLine) {\r\n                        if (!isPieceUnderAttack && attackedX === pieceX && attackedY === pieceY)\r\n                            isPieceUnderAttack = true;\r\n                        if (!isRoyalUnderAttack && attackedX === royalX && attackedY === royalY)\r\n                            isRoyalUnderAttack = true;\r\n                        if (isPieceUnderAttack && isRoyalUnderAttack) {\r\n                            pins.push(piece);\r\n                        }\r\n                        else if (isRoyalUnderAttack && !isPieceUnderAttack) {\r\n                            discovered.push([attackPiece[0], attackPiece[1]]);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            for (const coordinate of pins) {\r\n                if (hanging(coordinate[0], coordinate[1]) > 2)\r\n                    continue;\r\n                const pieceValue = Math.sqrt(getPieceValue(coordinate[0], coordinate[1]));\r\n                if (!board.gameType.isSameTeam(i, defaultSideToMove)) {\r\n                    pinnedEval += pieceValue / 2;\r\n                }\r\n                else {\r\n                    pinnedEval -= pieceValue;\r\n                }\r\n            }\r\n            for (const coordinate of discovered) {\r\n                if (hanging(coordinate[0], coordinate[1]) > 2)\r\n                    continue;\r\n                const pieceValue = Math.sqrt(getPieceValue(coordinate[0], coordinate[1]));\r\n                if (board.gameType.isSameTeam(i, defaultSideToMove)) {\r\n                    discovsEval += pieceValue / 2;\r\n                }\r\n                else {\r\n                    discovsEval -= pieceValue;\r\n                }\r\n            }\r\n        }\r\n        pinnedEval *= remainingReal / 6;\r\n        discovsEval *= remainingReal / 6;\r\n        if (discovsEval < 0)\r\n            discovsEval /= 10;\r\n        return { pinnedEval, discovsEval };\r\n    }\r\n    function getKingSafetyEval(player) {\r\n        const { board, royal, boardSquares, remainingReal, data, variantData, defaultSideToMove } = boardAccessors;\r\n        let kingEval = 0, checkableEval = 0, exposedEval = 0;\r\n        if (variantData.giveaway)\r\n            return { kingEval, checkableEval, exposedEval };\r\n        const baseReferences = initializeBoardSquares(() => []);\r\n        for (const [coordinate, attack] of board.preGeneratedAttacks[player].hoppingPieceLines) {\r\n            baseReferences[attack[0]][attack[1]].push([coordinate[0], coordinate[1]]);\r\n        }\r\n        for (const [coordinate, line] of board.preGeneratedAttacks[player].slidingPiecesLines) {\r\n            for (const attack of line) {\r\n                baseReferences[attack[0]][attack[1]].push([coordinate[0], coordinate[1]]);\r\n            }\r\n        }\r\n        const royalPiece = royal[player];\r\n        const squareAccessDefinitions = new Set();\r\n        if (royalPiece) {\r\n            const isChecked = Boolean(board.preGeneratedAttacks[player].slidingPieces[royalPiece[0]][royalPiece[1]]\r\n                || board.preGeneratedAttacks[player].hoppingPieces[royalPiece[0]][royalPiece[1]]);\r\n            for (let i = 0; i < boardDimension; i++) {\r\n                for (let j = 0; j < boardDimension; j++) {\r\n                    if (isChecked) {\r\n                        let checkableSq = 0;\r\n                        if (remainingReal === 2) {\r\n                            checkableSq -= 0.8;\r\n                        }\r\n                        else {\r\n                            const players = baseReferences[i][j].map(coord => {\r\n                                const piece = boardSquares[coord[0]][coord[1]];\r\n                                if (!piece.isPiece())\r\n                                    return player;\r\n                                return piece.color;\r\n                            });\r\n                            const prev = data.nextTurn(player);\r\n                            const next = data.previousTurn(player);\r\n                            for (const player of players) {\r\n                                if (remainingReal === 3) {\r\n                                    checkableSq -= player === next ? 3 : 2;\r\n                                }\r\n                                else if (remainingReal === 4) {\r\n                                    checkableSq -= player === next ? 5 : player === prev ? 2 : 3;\r\n                                }\r\n                            }\r\n                        }\r\n                        const { defenders } = getCoverage(i, j, player);\r\n                        if (defenders.length)\r\n                            checkableSq += 2.5;\r\n                        if (checkableSq > 0)\r\n                            checkableSq = 0;\r\n                        const accessKey = stringifyKey(i, j);\r\n                        if (!squareAccessDefinitions.has(accessKey)) {\r\n                            exposedEval -= 0.123;\r\n                            squareAccessDefinitions.add(accessKey);\r\n                        }\r\n                        checkableEval += checkableSq;\r\n                    }\r\n                }\r\n            }\r\n            const ki = royalPiece[0], kj = royalPiece[1];\r\n            for (let d = 1; d < 3; d++) {\r\n                const x = [ki, ki + d, ki - d];\r\n                const y = [kj, kj + d, kj - d];\r\n                for (const i of x) {\r\n                    for (const j of y) {\r\n                        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\r\n                        if (!boardSquares[i]?.[j])\r\n                            continue;\r\n                        if (i === ki && j === kj)\r\n                            continue;\r\n                        const pieceString = boardSquares[i][j];\r\n                        if (!pieceString.isPiece())\r\n                            continue;\r\n                        if (board.gameType.isSameTeam(pieceString.color, player)) {\r\n                            kingEval += pieceString.piece === pawnPieceString.piece ? 2 : 1;\r\n                        }\r\n                        else {\r\n                            kingEval -= getPieceValue(i, j);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            for (let k = -1; k < 2; k++) {\r\n                for (let h = -1; h < 2; h++) {\r\n                    const i = ki + k;\r\n                    const j = kj + h;\r\n                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\r\n                    if (!boardSquares[i]?.[j])\r\n                        continue;\r\n                    const { attackers, defenders } = getCoverage(i, j, player);\r\n                    kingEval -= 2 * attackers.length;\r\n                    kingEval += 1 * defenders.length;\r\n                }\r\n            }\r\n            kingEval /= 10;\r\n        }\r\n        if (variantData.nCheck && !board.gameType.isSameTeam(board.data.sideToMove, defaultSideToMove)) {\r\n            const lives = data.fenOptions.tag(\"lives\")[board.data.sideToMove];\r\n            switch (lives) {\r\n                case null:\r\n                    break;\r\n                case 2:\r\n                    checkableEval *= 1.5;\r\n                    break;\r\n                case 1:\r\n                    checkableEval *= 3;\r\n                    break;\r\n                default:\r\n                    checkableEval *= 1.3;\r\n            }\r\n        }\r\n        return { kingEval, checkableEval, exposedEval };\r\n    }\r\n    function isZombieEatZombie(move) {\r\n        if (!verifyStandardMove(move))\r\n            return false;\r\n        const { data, defaultSideToMove, boardSquares, variantData } = boardAccessors;\r\n        if (variantData.giveaway)\r\n            return false;\r\n        const resigned = data.fenOptions.tag(\"resigned\");\r\n        if (!resigned[defaultSideToMove])\r\n            return false;\r\n        const targetPiece = boardSquares[move.endCoordinates[0]][move.endCoordinates[1]];\r\n        if (!targetPiece.isPiece())\r\n            return false;\r\n        if (resigned[targetPiece.color])\r\n            return true;\r\n        return false;\r\n    }\r\n    function getEval(move) {\r\n        let totalEval = 0;\r\n        const { board, data, defaultSideToMove, variantData, royal, isTeams } = boardAccessors;\r\n        const snapshot = board.createSnapshot();\r\n        const isKingsideCastle = data.fenOptions.isKingsideCastlingAvailable(data.sideToMove, board), isQueensideCastle = data.fenOptions.isQueensideCastlingAvailable(data.sideToMove, board);\r\n        board.makeMove([move], true);\r\n        board.pregenerateAttacks();\r\n        boardAccessors = { ...boardAccessors, ...augmentBoardAccessorsFromBoard(board) };\r\n        inspectCoverage();\r\n        const { myMaterial, oppMaterial } = getMaterialEval();\r\n        const hillEval = variantData.kingOfTheHill ? 416 / (3 * getDistFromHill(defaultSideToMove)) : 0;\r\n        if (variantData.giveaway) {\r\n            totalEval = -3 * myMaterial - oppMaterial - (getCoordinationEval(defaultSideToMove) * 10) + hillEval;\r\n        }\r\n        else {\r\n            totalEval += getMatesEval();\r\n            const royalPiece = royal[defaultSideToMove];\r\n            if (royalPiece) {\r\n                const { attackers } = getCoverage(royalPiece[0], royalPiece[1], defaultSideToMove);\r\n                if (attackers.length)\r\n                    totalEval -= 700;\r\n            }\r\n            totalEval += getMobilityEval(defaultSideToMove);\r\n            totalEval += getCoordinationEval(defaultSideToMove);\r\n            if (isTeams) {\r\n                const partner = colors.find(v => v !== defaultSideToMove && board.gameType.isSameTeam(defaultSideToMove, v));\r\n                if (partner)\r\n                    Object.values(getKingSafetyEval(partner)).forEach(v => totalEval += v);\r\n            }\r\n            Object.values(getPinsEval()).forEach(v => totalEval += v);\r\n            Object.values(getKingSafetyEval(defaultSideToMove)).forEach(v => totalEval += v);\r\n            totalEval += myMaterial + oppMaterial + hillEval;\r\n        }\r\n        const isCastling = \"specialType\" in move && (move.specialType === SpecialMove.CastlingKingside || move.specialType === SpecialMove.CastlingQueenside);\r\n        if (!isCastling && (isKingsideCastle || isQueensideCastle))\r\n            totalEval -= 0.5;\r\n        if (isZombieEatZombie(move)) {\r\n            totalEval -= 10000;\r\n        }\r\n        switch (board.moves.getHash(board.data.constructPreliminaryHashString())) {\r\n            case 1:\r\n                totalEval -= 10000;\r\n                break;\r\n            case 2:\r\n                totalEval -= 20000;\r\n                break;\r\n        }\r\n        if (variantData.fiftyMoveRule && variantData.fiftyMoveRule - board.data.plyCount < 8)\r\n            totalEval -= 150000;\r\n        board.loadSnapshot(snapshot);\r\n        return totalEval;\r\n    }\r\n    return {\r\n        stringifiedType: ZombieType.Futer,\r\n        evaluate(moves, board) {\r\n            initializeBoardAccessorsFromBoard(board.createClone());\r\n            const moveValues = new Map();\r\n            for (const move of moves) {\r\n                if (verifyInternalMove(move)) {\r\n                    switch (move.type) {\r\n                        case InternalMoveSignature.Resign:\r\n                        case InternalMoveSignature.Timeout:\r\n                            moveValues.set(move, -Infinity);\r\n                            break;\r\n                        case InternalMoveSignature.ClaimWin:\r\n                            moveValues.set(move, Infinity);\r\n                            break;\r\n                    }\r\n                }\r\n                else\r\n                    moveValues.set(move, getEval(move));\r\n            }\r\n            return moveValues;\r\n        },\r\n        pickPreferredMove(evaluations) {\r\n            const sorted = [...evaluations.entries()].sort((a, b) => b[1] - a[1]);\r\n            const best = [];\r\n            for (const [move, evaluated] of sorted) {\r\n                if (sorted[0][1] - evaluated > 0.5)\r\n                    break;\r\n                best.push(move);\r\n            }\r\n            if (best.length > 5)\r\n                best.length = 5;\r\n            let pick = Math.floor(Math.random() * best.length);\r\n            if (pick > 0 && Math.random() > 0.8)\r\n                pick = 0;\r\n            if (pick > 1 && Math.random() > 0.8)\r\n                pick = 1;\r\n            if (pick > 2 && Math.random() > 0.8)\r\n                pick = 2;\r\n            return randomlyPickNextChainedMoves(best[pick]);\r\n        }\r\n    };\r\n}\r\nexport const comfuterAlgorithm = createBotAlgorithm(createComfuterAlgorithm());\r\n","import { verifyStandardMove, SpecialMove, verifyInternalMove } from \"@moveGeneration/MoveTree/MoveTreeInterface\";\r\nimport { pieceControlConfigSettings } from \"@moveGeneration/PieceControl/PieceControlInterface\";\r\nimport { createBotAlgorithm, ZombieType } from \"../BotInterface\";\r\nimport { comfuterAlgorithm } from \"./ComfuterEvaluation\";\r\nexport const createComfuterBasedAlgorithm = (algorithm) => ({\r\n    ...algorithm,\r\n    pickPreferredMove(...args) {\r\n        return comfuterAlgorithm.pickPreferredMove.apply(this, args);\r\n    }\r\n});\r\nexport const comfuterCheckerAlgorithm = createBotAlgorithm(createComfuterBasedAlgorithm({\r\n    stringifiedType: ZombieType.F_Checker,\r\n    evaluate(moves, board) {\r\n        const baseEvaluations = comfuterAlgorithm.evaluate.call(this, moves, board);\r\n        for (const [move, evaluation] of baseEvaluations) {\r\n            if (verifyInternalMove(move))\r\n                continue;\r\n            const snapshot = board.createSnapshot();\r\n            const { checks, checkmates } = board.makeMove([move]);\r\n            const checksLength = checks.filter(Boolean).length;\r\n            baseEvaluations.set(move, evaluation + (checkmates.includes(true)\r\n                ? checksLength * 500\r\n                : checksLength * 1500));\r\n            board.moves.deleteMove(board.moves.currentMove);\r\n            board.loadSnapshot(snapshot);\r\n        }\r\n        return baseEvaluations;\r\n    }\r\n}));\r\nexport const comfuterMuncherAlgorithm = createBotAlgorithm(createComfuterBasedAlgorithm({\r\n    stringifiedType: ZombieType.F_Muncher,\r\n    evaluate(moves, board) {\r\n        const baseEvaluations = comfuterAlgorithm.evaluate.call(this, moves, board);\r\n        for (const [move, evaluation] of baseEvaluations) {\r\n            if (!verifyStandardMove(move))\r\n                continue;\r\n            if (move.specialType === SpecialMove.EnPassant\r\n                || board.board[move.endCoordinates[0]][move.endCoordinates[1]].isEmpty())\r\n                continue;\r\n            baseEvaluations.set(move, evaluation + 5000);\r\n        }\r\n        return baseEvaluations;\r\n    }\r\n}));\r\nexport const comfuterPusherAlgorithm = createBotAlgorithm(createComfuterBasedAlgorithm({\r\n    stringifiedType: ZombieType.F_Pusher,\r\n    evaluate(moves, board) {\r\n        const baseEvaluations = comfuterAlgorithm.evaluate.call(this, moves, board);\r\n        for (const [move, evaluation] of baseEvaluations) {\r\n            if (!verifyStandardMove(move))\r\n                continue;\r\n            const pieceString = board.board[move.startCoordinates[0]][move.startCoordinates[1]];\r\n            if (pieceString.isPiece() && !pieceControlConfigSettings[pieceString.piece].moveGenerationSettings.isPawn) {\r\n                baseEvaluations.set(move, evaluation + 5000);\r\n            }\r\n        }\r\n        return baseEvaluations;\r\n    }\r\n}));\r\nexport const patzerAlgorithm = createBotAlgorithm(createComfuterBasedAlgorithm({\r\n    stringifiedType: ZombieType.Patzer,\r\n    evaluate(moves, defaultBoard) {\r\n        const baseEvaluations = comfuterAlgorithm.evaluate.call(this, moves, defaultBoard);\r\n        for (const [move, evaluation] of baseEvaluations) {\r\n            baseEvaluations.set(move, -evaluation);\r\n        }\r\n        return baseEvaluations;\r\n    }\r\n}));\r\n","import { createBotAlgorithm, ZombieType } from \"../BotInterface\";\r\nimport { comfuterAlgorithm } from \"./ComfuterEvaluation\";\r\nimport { createComfuterBasedAlgorithm } from \"./ComfuterEvaluationExtensions\";\r\nimport { randoBotAlgorithm } from \"./RandomEvaluation\";\r\nexport const RanterAlgorithm = createBotAlgorithm(createComfuterBasedAlgorithm({\r\n    stringifiedType: ZombieType.Ranter,\r\n    evaluate(...args) {\r\n        if (Math.random() < 0.5) {\r\n            return randoBotAlgorithm.evaluate.apply(this, args);\r\n        }\r\n        else\r\n            return comfuterAlgorithm.evaluate.apply(this, args);\r\n    }\r\n}));\r\n","import { verifyRequiredMove, verifyStandardMove } from \"@moveGeneration/MoveTree/MoveTreeInterface\";\r\nimport { createBotAlgorithm, ZombieType } from \"../BotInterface\";\r\nexport function randomlyPickNextChainedMoves(move, resultingMove = []) {\r\n    const newMove = [...resultingMove, move];\r\n    if (move.nextChainedMoves && (!move.isForcedContinuation && Math.random() > 0.5)) {\r\n        return randomlyPickNextChainedMoves(move.nextChainedMoves[Math.floor(Math.random() * move.nextChainedMoves.length)], newMove);\r\n    }\r\n    else {\r\n        if (!verifyRequiredMove(newMove))\r\n            throw new Error(\"Required move length is 0\");\r\n        return newMove;\r\n    }\r\n}\r\nexport const randoBotAlgorithm = createBotAlgorithm({\r\n    stringifiedType: ZombieType.Rando,\r\n    evaluate(moves, board) {\r\n        const copyOfMoves = moves.slice();\r\n        for (let i = moves.length - 1; i > 0; i--) {\r\n            const j = Math.floor(Math.random() * (i + 1));\r\n            [copyOfMoves[i], copyOfMoves[j]] = [moves[j], moves[i]];\r\n        }\r\n        const data = board.data, boardSquares = board.board;\r\n        const zombieEatZombieMoves = [];\r\n        const otherMoves = [];\r\n        for (const move of copyOfMoves) {\r\n            if (verifyStandardMove(move)) {\r\n                const targetPiece = boardSquares[move.endCoordinates[1]][move.endCoordinates[0]];\r\n                if (targetPiece.isPiece() && data.fenOptions.tag(\"resigned\")[targetPiece.color]) {\r\n                    zombieEatZombieMoves.push(move);\r\n                    continue;\r\n                }\r\n            }\r\n            otherMoves.push(move);\r\n        }\r\n        let startingEvaluation = 0;\r\n        return new Map([\r\n            ...otherMoves.reduce((p, n) => (p.push([n, --startingEvaluation]), p), []),\r\n            ...zombieEatZombieMoves.reduce((p, n) => (p.push([n, --startingEvaluation / 2]), p), [])\r\n        ]);\r\n    },\r\n    pickPreferredMove(evaluations) {\r\n        return randomlyPickNextChainedMoves([...evaluations.entries()].reduce((p, n) => n[1] > p[1] ? n : p)[0]);\r\n    }\r\n});\r\n","import { verifyStandardMove, SpecialMove } from \"@moveGeneration/MoveTree/MoveTreeInterface\";\r\nimport { pieceControlConfigSettings } from \"@moveGeneration/PieceControl/PieceControlInterface\";\r\nimport { createBotAlgorithm, ZombieType } from \"../BotInterface\";\r\nimport { randoBotAlgorithm } from \"./RandomEvaluation\";\r\nexport const createRandomBasedAlgorithm = (algorithm) => ({\r\n    ...algorithm,\r\n    pickPreferredMove(...args) {\r\n        return randoBotAlgorithm.pickPreferredMove.apply(this, args);\r\n    }\r\n});\r\nexport const checkerAlgorithm = createBotAlgorithm(createRandomBasedAlgorithm({\r\n    stringifiedType: ZombieType.Checker,\r\n    evaluate(moves, board) {\r\n        const baseEvaluations = randoBotAlgorithm.evaluate.call(this, moves, board);\r\n        for (const [move, evaluation] of baseEvaluations) {\r\n            const snapshot = board.createSnapshot();\r\n            const { checks, checkmates } = board.makeMove([move]);\r\n            if (checks.filter((c, i) => c && !checkmates[i] === c).length === 0) {\r\n                baseEvaluations.set(move, evaluation / (evaluation / 2));\r\n            }\r\n            board.loadSnapshot(snapshot);\r\n        }\r\n        return baseEvaluations;\r\n    }\r\n}));\r\nexport const muncherAlgorithm = createBotAlgorithm(createRandomBasedAlgorithm({\r\n    stringifiedType: ZombieType.Muncher,\r\n    evaluate(moves, board) {\r\n        const baseEvaluations = randoBotAlgorithm.evaluate.call(this, moves, board);\r\n        for (const [move, evaluation] of baseEvaluations) {\r\n            if (!verifyStandardMove(move))\r\n                continue;\r\n            if (move.specialType === SpecialMove.EnPassant\r\n                || board.board[move.endCoordinates[0]][move.endCoordinates[1]].isEmpty())\r\n                continue;\r\n            baseEvaluations.set(move, evaluation / (evaluation / 2));\r\n        }\r\n        return baseEvaluations;\r\n    }\r\n}));\r\nexport const pusherAlgorithm = createBotAlgorithm(createRandomBasedAlgorithm({\r\n    stringifiedType: ZombieType.Pusher,\r\n    evaluate(moves, board) {\r\n        const baseEvaluations = randoBotAlgorithm.evaluate.call(this, moves, board);\r\n        for (const [move, evaluation] of baseEvaluations) {\r\n            if (!verifyStandardMove(move))\r\n                continue;\r\n            const pieceString = board.board[move.startCoordinates[0]][move.startCoordinates[1]];\r\n            if (pieceString.isPiece() && !pieceControlConfigSettings[pieceString.piece].moveGenerationSettings.isPawn) {\r\n                baseEvaluations.set(move, evaluation / (evaluation / 2));\r\n            }\r\n        }\r\n        return baseEvaluations;\r\n    }\r\n}));\r\n","export var ZombieType;\r\n(function (ZombieType) {\r\n    ZombieType[\"Rando\"] = \"rando\";\r\n    ZombieType[\"Futer\"] = \"comfuter\";\r\n    ZombieType[\"Ranter\"] = \"ranter\";\r\n    ZombieType[\"Patzer\"] = \"patzer\";\r\n    ZombieType[\"Pusher\"] = \"pusher\";\r\n    ZombieType[\"Checker\"] = \"checker\";\r\n    ZombieType[\"Muncher\"] = \"muncher\";\r\n    ZombieType[\"F_Pusher\"] = \"pusher_comfuter\";\r\n    ZombieType[\"F_Checker\"] = \"checker_comfuter\";\r\n    ZombieType[\"F_Muncher\"] = \"muncher_comfuter\";\r\n})(ZombieType || (ZombieType = {}));\r\nexport const verifyZombieType = (zombieType) => zombieType in ZombieType;\r\nexport const botAlgorithms = new Map();\r\nexport function createBotAlgorithm(algorithm) {\r\n    botAlgorithms.set(algorithm.stringifiedType, algorithm);\r\n    return algorithm;\r\n}\r\n","import { compareCoordinates, stringifyCoordinate } from \"@moveGeneration/Board/BoardInterface\";\r\nimport { defaultPieces, grasshopperPieceLetter, pieceControlConfigSettings, verifyPieceLetter } from \"@moveGeneration/PieceControl/PieceControlInterface\";\r\nimport { assertNonUndefined, createTuple, createTupleFromCallback } from \"@client/ts/baseTypes\";\r\nimport { initializeBoardSquares } from \"@client/ts/logic/BaseInterfaces\";\r\nimport { bitCount } from \"@client/ts/utils/NumberUtils\";\r\nimport { boardDimension, colors, totalPlayers } from \"../../../../GameInformation/GameData\";\r\nimport { createPieceFromData, emptyPieceString } from \"../../../../GameInformation/GameUnits/PieceString\";\r\nimport { stalemateOptionsValues } from \"../../FENDataDecorators/StalemateOptions\";\r\nimport { disabledRank } from \"../../PieceControlDecorators/PromotionRank\";\r\nconst binaryMasks = Array(boardDimension).fill(1).map((v, i) => v << boardDimension | v << (boardDimension - 1 - i));\r\nconst oneBitMask = 1 << boardDimension;\r\nconst maxSafeCheckingPieces = 9;\r\nexport function countBitsOnBoard(board) {\r\n    let setBits = 0;\r\n    for (let x = 0; x < boardDimension; x++) {\r\n        setBits += bitCount(board[x] ^ oneBitMask);\r\n    }\r\n    return setBits;\r\n}\r\nfunction findMinimumOnBoardSquares(board) {\r\n    let minimum = Infinity;\r\n    for (let i = 0; i < boardDimension; i++) {\r\n        for (let j = 0; j < boardDimension; j++) {\r\n            const setBits = countBitsOnBoard(board[i][j]);\r\n            if (setBits !== 0 && setBits < minimum) {\r\n                minimum = setBits;\r\n            }\r\n        }\r\n    }\r\n    return minimum;\r\n}\r\nfunction optimizePieceSet(possiblePieces, maximumTarget) {\r\n    const optimalRoyalMoveSets = [\r\n        [\"\", \"W\", \"R\", \"E\", \"M\", \"Q\", \"D\", \"A\"],\r\n        [\"\", \"F\", \"B\", \"H\", \"M\", \"Q\", \"D\", \"A\", \"\"],\r\n        [\"Y\", \"Z\"], [\"I\", \"J\"], [\"S\", \"T\"], [\"S\", \"Y\"], [\"I\", \"Y\"],\r\n        [\"U\", \"N\", \"O\"], [\"H\", \"A\"], [\"E\", \"A\"], [\"\", \"H\"], [\"C\", \"L\"], [\"C\", \"V\"]\r\n    ];\r\n    const moveSet = new Set();\r\n    for (const optimalMoveSet of optimalRoyalMoveSets) {\r\n        const detractionSet = maximumTarget ? optimalMoveSet.slice().reverse() : optimalMoveSet;\r\n        for (const piece of possiblePieces) {\r\n            if (detractionSet.includes(piece)) {\r\n                const target = detractionSet.slice(0, -detractionSet.indexOf(piece)); // ! NOT A BUG\r\n                target.forEach(t => { if (possiblePieces.includes(t) && verifyPieceLetter(t))\r\n                    moveSet.add(t); });\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    if (moveSet.size === 0) {\r\n        possiblePieces.forEach(p => { if (verifyPieceLetter(p))\r\n            moveSet.add(p); });\r\n    }\r\n    return moveSet;\r\n}\r\nexport function generateInsufficientMatingPieces(baseBoard) {\r\n    const board = baseBoard.createClone();\r\n    // Step 1. Initialize the royals, get the optimal royal piece configuration.\r\n    performance.mark(\"insufficientMaterialStart\");\r\n    const possibleRoyals = [[], [], [], []];\r\n    const boardSquares = board.board, options = board.data, controls = board.controls, royals = options.fenOptions.tag(\"royal\");\r\n    const promotionPieces = board.variantData.promotionPieces || [];\r\n    const promotionRank = board.variantData.promotionRank || disabledRank;\r\n    royals.forEach((r, i) => {\r\n        if (r) {\r\n            const coordinate = boardSquares[r[0]][r[1]];\r\n            if (pieceControlConfigSettings[coordinate.piece].moveGenerationSettings.isPawn) {\r\n                possibleRoyals[i] = [coordinate.piece, ...promotionPieces];\r\n            }\r\n            else\r\n                possibleRoyals[i] = [coordinate.piece];\r\n        }\r\n        else if (promotionPieces.includes(defaultPieces.king)) {\r\n            possibleRoyals[i] = [defaultPieces.king];\r\n        }\r\n    });\r\n    const royalPieceSets = Array.from({ length: 4 }, () => new Set());\r\n    for (let i = 0; i < possibleRoyals.length; i++) {\r\n        if (possibleRoyals[i].length > 1) {\r\n            royalPieceSets[i] = optimizePieceSet(possibleRoyals[i], false);\r\n        }\r\n        else if (possibleRoyals[i].length === 1) {\r\n            royalPieceSets[i].add(possibleRoyals[i][0]);\r\n        }\r\n    }\r\n    // Step 2. Get all coordinates individual pieces can reach, for swift move generation.\r\n    const boardDestinations = new Map();\r\n    const emptyBoard = boardSquares.map(row => row.map(square => square.isWall() ? square : emptyPieceString));\r\n    const walls = emptyBoard.map(row => row.map(square => square.isWall() ? true : false));\r\n    const pieceMoveRegistry = {};\r\n    const baseImmune = [false, false, false, false];\r\n    const getAllSquaresRecursively = (x, y, piece) => {\r\n        const currentSquares = new Set(), unvisitedSquares = new Set();\r\n        if (!piece.isPiece())\r\n            throw new TypeError(`Wrong piece signature detected at ${piece.value}`);\r\n        const baseBuilder = controls[piece.piece]().setColor(piece.color).setBoard(emptyBoard).setBaseImmunePieces(baseImmune);\r\n        const registryResult = initializeBoardSquares(() => new Uint16Array(boardDimension).fill(oneBitMask));\r\n        const recurse = (x, y) => {\r\n            const control = baseBuilder.setCoordinates(x, y).constructPieceControl();\r\n            const moves = control.getPseudoLegalMoves();\r\n            const moveLength = moves.length;\r\n            if (moveLength === 0)\r\n                return;\r\n            for (let i = 0; i < moveLength; i++) {\r\n                const move = moves[i].move;\r\n                const moveString = stringifyCoordinate(move);\r\n                registryResult[x][y][move[0]] |= binaryMasks[move[1]];\r\n                if (!currentSquares.has(moveString)) {\r\n                    unvisitedSquares.add(moveString);\r\n                }\r\n            }\r\n            for (const value of unvisitedSquares) {\r\n                const [x, y] = value.split(\":\");\r\n                if (!currentSquares.has(value)) {\r\n                    currentSquares.add(value);\r\n                    recurse(parseInt(x, 10), parseInt(y, 10));\r\n                }\r\n            }\r\n        };\r\n        recurse(x, y);\r\n        if (!(piece.piece in pieceMoveRegistry))\r\n            pieceMoveRegistry[piece.piece] = {};\r\n        pieceMoveRegistry[piece.piece][Symbol()] = registryResult;\r\n        const permutations = new Uint16Array(14).fill(oneBitMask);\r\n        currentSquares.forEach(value => {\r\n            const valueArr = value.split(\":\");\r\n            permutations[parseInt(valueArr[0], 10)] |= binaryMasks[parseInt(valueArr[1], 10)];\r\n        });\r\n        unvisitedSquares.forEach(value => {\r\n            const valueArr = value.split(\":\");\r\n            permutations[parseInt(valueArr[0], 10)] |= binaryMasks[parseInt(valueArr[1], 10)];\r\n        });\r\n        return permutations;\r\n    };\r\n    function addToBoardDestinations(i, j, piece) {\r\n        const permutations = getAllSquaresRecursively(i, j, piece);\r\n        const boardPiece = boardDestinations.get(piece.piece);\r\n        if (boardPiece) {\r\n            boardDestinations.set(piece.piece, boardPiece.concat(permutations));\r\n        }\r\n        else {\r\n            boardDestinations.set(piece.piece, [permutations]);\r\n        }\r\n    }\r\n    for (let i = 0; i < boardDimension; i++) {\r\n        for (let j = 0; j < boardDimension; j++) {\r\n            if (boardSquares[i][j].isPiece())\r\n                addToBoardDestinations(i, j, boardSquares[i][j]);\r\n        }\r\n    }\r\n    const hasPromotion = promotionRank !== disabledRank && promotionPieces.some(p => verifyPieceLetter(p));\r\n    const promotionRanks = [boardDimension - promotionRank,\r\n        promotionRank - 1, promotionRank - 1, boardDimension - promotionRank];\r\n    const optimizedPieces = optimizePieceSet(promotionPieces, true);\r\n    if (hasPromotion) {\r\n        for (const color of colors) {\r\n            for (let x = 0; x < boardDimension; x++) {\r\n                const [i, j] = [color & 1 ? promotionRanks[color] : x, color & 1 ? x : promotionRanks[color]];\r\n                if (walls[i][j])\r\n                    continue;\r\n                for (const piece of optimizedPieces) {\r\n                    addToBoardDestinations(i, j, createPieceFromData(0, piece));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    const backwardsPieceRegistry = {};\r\n    const entries = boardDestinations.entries();\r\n    for (const [entry, uintArray] of entries) {\r\n        if (/[PG]/.test(entry) || !verifyPieceLetter(entry))\r\n            continue;\r\n        let isAlwaysIntersecting = true;\r\n        const permutationArray = [];\r\n        for (const permutationEntry of uintArray) {\r\n            if (permutationArray.length === 0) {\r\n                permutationArray.push(permutationEntry);\r\n            }\r\n            else {\r\n                const index = permutationArray.findIndex(uintArr => {\r\n                    if (typeof uintArr !== \"number\")\r\n                        return uintArr.every((n, j) => n === permutationEntry[j]);\r\n                });\r\n                if (~index) {\r\n                    permutationArray.push(index);\r\n                }\r\n                else {\r\n                    permutationArray.push(permutationEntry);\r\n                    isAlwaysIntersecting = false;\r\n                }\r\n            }\r\n        }\r\n        if (isAlwaysIntersecting) {\r\n            pieceMoveRegistry[entry] = {\r\n                [Symbol()]: pieceMoveRegistry[entry][Object.getOwnPropertySymbols(pieceMoveRegistry[entry])[0]]\r\n            };\r\n        }\r\n        else {\r\n            if (!(entry in backwardsPieceRegistry)) {\r\n                backwardsPieceRegistry[entry] = initializeBoardSquares(() => null);\r\n            }\r\n            const remappedSymbols = [];\r\n            for (const squares of permutationArray) {\r\n                let remappedSymbol;\r\n                if (typeof squares === 'number') {\r\n                    remappedSymbols.push(squares);\r\n                    continue;\r\n                }\r\n                for (let i = 0; i < boardDimension; i++) {\r\n                    for (let j = 0; j < boardDimension; j++) {\r\n                        if (squares[i] & binaryMasks[j] ^ oneBitMask) {\r\n                            if (!remappedSymbol) {\r\n                                remappedSymbol = Symbol();\r\n                                remappedSymbols.push(remappedSymbol);\r\n                            }\r\n                            backwardsPieceRegistry[entry][i][j] ??= remappedSymbol;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            const uintValues = Object.getOwnPropertySymbols(pieceMoveRegistry[entry]).map(sym => pieceMoveRegistry[entry][sym]);\r\n            pieceMoveRegistry[entry] = {};\r\n            for (let i = 0; i < uintValues.length; i++) {\r\n                const remapped = remappedSymbols[i];\r\n                if (typeof remapped === 'number')\r\n                    continue;\r\n                if (typeof remapped === 'undefined')\r\n                    break;\r\n                pieceMoveRegistry[entry][remapped] = uintValues[i];\r\n            }\r\n        }\r\n    }\r\n    // Step 3. Generate the opposition squares for the royal pieces, since royal cannot attack each other.\r\n    const royalMoves = createTuple(initializeBoardSquares(() => new Uint16Array(boardDimension).fill(oneBitMask)), totalPlayers);\r\n    const royalMoveMedians = createTuple(0, totalPlayers);\r\n    const oppositionDiagonalRowEchelon = createTuple(undefined, totalPlayers);\r\n    royals.forEach((r, x) => {\r\n        if (r) {\r\n            const royalPiece = boardSquares[r[0]][r[1]];\r\n            const controlBuilder = controls[royalPiece.piece];\r\n            const builder = controlBuilder().setColor(0).setBaseImmunePieces(baseImmune).setBoard(emptyBoard);\r\n            const finalArray = Array.from({ length: 14 }, () => Array.from({ length: 14 }, () => new Uint16Array(14).fill(oneBitMask)));\r\n            for (let i = 0; i < boardSquares.length; i++) {\r\n                for (let j = 0; j < boardSquares[0].length; j++) {\r\n                    if (emptyBoard[i][j].isWall())\r\n                        continue;\r\n                    const control = builder.setCoordinates(i, j).constructPieceControl();\r\n                    const moves = control.getPseudoLegalMoves();\r\n                    const permutationArray = new Uint16Array(14).fill(oneBitMask);\r\n                    for (const { move } of moves) {\r\n                        permutationArray[move[0]] |= binaryMasks[move[1]];\r\n                    }\r\n                    finalArray[i][j] = permutationArray;\r\n                    royalMoves[x][i][j] = permutationArray;\r\n                }\r\n            }\r\n            oppositionDiagonalRowEchelon[x] = finalArray;\r\n        }\r\n    });\r\n    const oppositionMedians = createTupleFromCallback(() => createTuple(0, totalPlayers), totalPlayers);\r\n    for (let i = 0; i < totalPlayers; i++) {\r\n        for (let j = 0; j < totalPlayers; j++) {\r\n            if (i === j || oppositionDiagonalRowEchelon[i] === undefined)\r\n                continue;\r\n            const royalPieceA = royals[i], royalPieceB = royals[j];\r\n            if (!royalPieceA || !royalPieceB)\r\n                continue;\r\n            const finalArray = Array.from({ length: 14 }, () => Array.from({ length: 14 }, () => 0));\r\n            for (let i2 = 0; i2 < boardDimension; i2++) {\r\n                for (let j2 = 0; j2 < boardDimension; j2++) {\r\n                    if (emptyBoard[i2][j2].isWall())\r\n                        continue;\r\n                    const jjIndex = oppositionDiagonalRowEchelon[j];\r\n                    const iiIndex = oppositionDiagonalRowEchelon[i];\r\n                    if (!jjIndex || !iiIndex)\r\n                        throw new Error(`Central opposition matrix indexes are undefined: ${jjIndex?.toString() ?? \"undefined\"}  ${iiIndex?.toString() ?? \"undefined\"}`);\r\n                    if (jjIndex[i2][j2][royalPieceA[1]] & binaryMasks[royalPieceA[0]] ^ oneBitMask\r\n                        && iiIndex[i2][j2][royalPieceB[1]] & binaryMasks[royalPieceB[0]] ^ oneBitMask) {\r\n                        continue;\r\n                    }\r\n                    const uintArray = jjIndex[i2][j2].map((e, x) => e & iiIndex[i2][j2][x]);\r\n                    let newResultingSquares = 0;\r\n                    for (let dimSquare = 0; dimSquare < boardDimension; dimSquare++) {\r\n                        newResultingSquares += bitCount(uintArray[dimSquare]) - 1;\r\n                    }\r\n                    finalArray[i2][j2] = newResultingSquares;\r\n                }\r\n            }\r\n            let minimum = Infinity;\r\n            for (let i2 = 0; i2 < boardDimension; i2++) {\r\n                for (let j2 = 0; j2 < boardDimension; j2++) {\r\n                    if (finalArray[i2][j2] !== 0 && finalArray[i2][j2] < minimum) {\r\n                        minimum = finalArray[i2][j2];\r\n                    }\r\n                }\r\n            }\r\n            oppositionMedians[i][j] = minimum - 1;\r\n        }\r\n    }\r\n    for (const color of colors) {\r\n        royalMoveMedians[color] = findMinimumOnBoardSquares(royalMoves[color]);\r\n    }\r\n    // Step 4. Finally, generate all squares pieces can cover from default royal moves for each player.\r\n    const nonIndexedPieceSymbol = Symbol();\r\n    const pieceSquareMedians = {\r\n        [grasshopperPieceLetter]: { [nonIndexedPieceSymbol]: [2, 2, 2, 2] }\r\n    };\r\n    let currentMessages = 0, requiredMessages = 0;\r\n    for (const pieceLetter in pieceMoveRegistry) {\r\n        if (!verifyPieceLetter(pieceLetter) || !Object.prototype.hasOwnProperty.call(pieceMoveRegistry, pieceLetter))\r\n            continue;\r\n        if (pieceLetter in pieceSquareMedians)\r\n            continue;\r\n        pieceSquareMedians[pieceLetter] = {};\r\n        const registeredSymbols = Object.getOwnPropertySymbols(pieceMoveRegistry[pieceLetter]);\r\n        for (const registeredSymbol of registeredSymbols) {\r\n            const pieceMedianCounter = new Worker(new URL(\"./PieceMedianCounter.ts\", import.meta.url));\r\n            pieceMedianCounter.postMessage({\r\n                walls,\r\n                moveRegistryArray: pieceMoveRegistry[pieceLetter][registeredSymbol].map(r => r.map(uint => uint.buffer)),\r\n                royalMoves: royalMoves.map(board => board.map(r => r.map(uint => uint.buffer))),\r\n                royalPieceSet: royalPieceSets.map(s => [...s])\r\n            });\r\n            requiredMessages++;\r\n            pieceMedianCounter.onmessage = (e) => {\r\n                pieceSquareMedians[pieceLetter][registeredSymbol] = e.data;\r\n                currentMessages++;\r\n            };\r\n        }\r\n    }\r\n    const obtainPieceSymbolFromCoordinate = (board, coordinate) => {\r\n        const piece = board.board[coordinate[0]][coordinate[1]];\r\n        if (pieceControlConfigSettings[piece.piece].moveGenerationSettings.isPawn && hasPromotion) {\r\n            const availableSymbols = [...optimizedPieces]\r\n                .filter(p => verifyPieceLetter(p)\r\n                && !pieceControlConfigSettings[p].moveGenerationSettings.isPawn).map(p => pieceSquareMedians[p]);\r\n            if (availableSymbols.length === 0) {\r\n                return { selectedSymbol: nonIndexedPieceSymbol, piece };\r\n            }\r\n            else {\r\n                const candidates = availableSymbols.map(s => {\r\n                    return s[Object.getOwnPropertySymbols(s)[0]].reduce((p, n) => p + (n ?? 0), 0);\r\n                });\r\n                const candidateIndex = candidates.indexOf(Math.max(...candidates));\r\n                const symbol = Object.getOwnPropertySymbols(availableSymbols[candidateIndex])[0];\r\n                return {\r\n                    selectedSymbol: symbol,\r\n                    piece\r\n                };\r\n            }\r\n        }\r\n        else {\r\n            const availableSymbols = Object.getOwnPropertySymbols(pieceSquareMedians[piece.piece]);\r\n            const selectedSymbol = availableSymbols.length === 1\r\n                ? availableSymbols[0]\r\n                : backwardsPieceRegistry[piece.piece][coordinate[0]][coordinate[1]];\r\n            assertNonUndefined(selectedSymbol);\r\n            return { selectedSymbol, piece };\r\n        }\r\n    };\r\n    const noRoyalsToMate = board.variantData.forcedCapture\r\n        || board.variantData.captureTheKing || board.variantData.barePieceRule\r\n        || board.variantData.nCheck;\r\n    return (board) => {\r\n        const fenOptions = board.data.fenOptions;\r\n        const areBanksEnabled = fenOptions.tag(\"areBanksEnabled\"), dead = fenOptions.tag(\"dead\"), royal = fenOptions.tag(\"royal\");\r\n        const pieces = board.getPlayerPieces();\r\n        const resultingInsufficientPieces = createTuple(false, totalPlayers);\r\n        if (board.variantData.kingOfTheHill || currentMessages !== requiredMessages\r\n            || areBanksEnabled.some((b, i) => !dead[i] && b)) {\r\n            return resultingInsufficientPieces;\r\n        }\r\n        const extraWalls = board.board.reduce((accumulator, row, i) => {\r\n            return accumulator + row.reduce((accumulator, square, j) => {\r\n                if (square.isWall() && !walls[i][j]) {\r\n                    return accumulator + 1;\r\n                }\r\n                else\r\n                    return accumulator;\r\n            }, 0);\r\n        }, 0);\r\n        const royalPieceMedians = royalMoveMedians.map((median, i) => {\r\n            if (!royal[i])\r\n                return;\r\n            let minimumMedian;\r\n            if (board.variantData.stalemateOptions === stalemateOptionsValues.stalemateLoses) {\r\n                minimumMedian = 1;\r\n                median--;\r\n            }\r\n            else {\r\n                median++;\r\n                minimumMedian = 2;\r\n            }\r\n            median -= extraWalls;\r\n            if (median < minimumMedian)\r\n                median = minimumMedian;\r\n            return median;\r\n        });\r\n        const squaresPlayerCanOutrange = createTupleFromCallback(() => createTuple(0, totalPlayers), totalPlayers);\r\n        for (const color of colors) {\r\n            const army = pieces[color];\r\n            if (army.length > maxSafeCheckingPieces || dead[color])\r\n                continue;\r\n            for (const royalColor of colors) {\r\n                if (pieces[royalColor].length > maxSafeCheckingPieces\r\n                    || color === royalColor || dead[royalColor])\r\n                    continue;\r\n                if (!royal[royalColor] || noRoyalsToMate) {\r\n                    intersectionCheckLoop: for (const coordinate of army) {\r\n                        const { piece, selectedSymbol } = obtainPieceSymbolFromCoordinate(board, coordinate);\r\n                        const symbolsLength = Object.getOwnPropertySymbols(pieceSquareMedians[piece.piece]).length;\r\n                        if (symbolsLength > 1 || pieceControlConfigSettings[piece.piece].moveGenerationSettings.isColorBound) {\r\n                            for (const enemyCoordinate of pieces[royalColor]) {\r\n                                const { selectedSymbol: enemySymbol } = obtainPieceSymbolFromCoordinate(board, enemyCoordinate);\r\n                                if (selectedSymbol === enemySymbol) {\r\n                                    squaresPlayerCanOutrange[royalColor][color] = Infinity;\r\n                                    break intersectionCheckLoop;\r\n                                }\r\n                            }\r\n                        }\r\n                        else {\r\n                            squaresPlayerCanOutrange[royalColor][color] = Infinity;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (squaresPlayerCanOutrange[royalColor][color] !== Infinity) {\r\n                        squaresPlayerCanOutrange[royalColor][color] = -1;\r\n                    }\r\n                }\r\n                else {\r\n                    const royalSquares = royalPieceMedians[royalColor];\r\n                    if (royalSquares === undefined)\r\n                        continue;\r\n                    const fenRoyal = royal[color];\r\n                    const currentColorBounds = [];\r\n                    for (const coordinate of army) {\r\n                        if (fenRoyal && compareCoordinates(coordinate, fenRoyal)) {\r\n                            if (board.variantData.royalsCannotCapture) {\r\n                                squaresPlayerCanOutrange[color][royalColor]++;\r\n                            }\r\n                            else {\r\n                                squaresPlayerCanOutrange[color][royalColor] += oppositionMedians[color][royalColor];\r\n                            }\r\n                        }\r\n                        else {\r\n                            const { piece, selectedSymbol } = obtainPieceSymbolFromCoordinate(board, coordinate);\r\n                            if (hasPromotion && pieceControlConfigSettings[piece.piece].moveGenerationSettings.isPawn) {\r\n                                const medians = promotionPieces.map(piece => {\r\n                                    const subSymbol = Object.getOwnPropertySymbols(pieceSquareMedians[piece])[0];\r\n                                    return pieceSquareMedians[piece][subSymbol][royalColor] ?? 0;\r\n                                });\r\n                                squaresPlayerCanOutrange[color][royalColor] += Math.max(...medians);\r\n                            }\r\n                            else {\r\n                                if (pieceControlConfigSettings[piece.piece].moveGenerationSettings.isColorBound) {\r\n                                    if (currentColorBounds.includes(selectedSymbol))\r\n                                        continue;\r\n                                    currentColorBounds.push(selectedSymbol);\r\n                                }\r\n                                squaresPlayerCanOutrange[color][royalColor] += pieceSquareMedians[piece.piece][selectedSymbol][royalColor] ?? 0;\r\n                            }\r\n                        }\r\n                    }\r\n                    squaresPlayerCanOutrange[color][royalColor] += pieces[royalColor].length - 1;\r\n                }\r\n            }\r\n        }\r\n        for (const color of colors) {\r\n            if (dead[color])\r\n                continue;\r\n            let sum = 0;\r\n            for (let i = 0; i < totalPlayers; i++) {\r\n                if (i === color)\r\n                    continue;\r\n                sum += squaresPlayerCanOutrange[i][color];\r\n            }\r\n            const royal = royalPieceMedians[color];\r\n            if ((royal !== undefined && sum <= royal && pieces[color].length <= maxSafeCheckingPieces)\r\n                || sum < 0) {\r\n                resultingInsufficientPieces[color] = true;\r\n            }\r\n        }\r\n        return resultingInsufficientPieces;\r\n    };\r\n}\r\n","import { createTupleFromCallback } from \"@client/ts/baseTypes\";\r\nimport { initializeBoardSquares } from \"@client/ts/logic/BaseInterfaces\";\r\nimport { boardDimension, colors, totalPlayers } from \"@moveGeneration/GameInformation/GameData\";\r\nimport { verifyPieceLetter } from \"@moveGeneration/PieceControl/PieceControlInterface\";\r\nimport { countMinimumOf2DArrayExcludingZero } from \"@client/ts/utils/ArrayUtils\";\r\nimport { countBitsOnBoard } from \"./InsufficientMaterialGeneration\";\r\nself.onmessage = (e) => {\r\n    const { walls, royalPieceSet, royalMoves, moveRegistryArray } = e.data;\r\n    const resultingMedianArray = createTupleFromCallback(() => initializeBoardSquares(() => 0), totalPlayers);\r\n    for (let i = 0; i < boardDimension; i++) {\r\n        for (let j = 0; j < boardDimension; j++) {\r\n            if (walls[i][j])\r\n                continue;\r\n            const moves = new Uint16Array(moveRegistryArray[i][j]);\r\n            for (const color of colors) {\r\n                if (royalPieceSet[color].length === 0) {\r\n                    resultingMedianArray[color] = undefined;\r\n                    continue;\r\n                }\r\n                else {\r\n                    let resultingSquares = 0;\r\n                    for (const royal of royalPieceSet[color]) {\r\n                        if (!verifyPieceLetter(royal))\r\n                            continue;\r\n                        for (let royalI = 0; royalI < boardDimension; royalI++) {\r\n                            for (let royalJ = 0; royalJ < boardDimension; royalJ++) {\r\n                                const royalMoveSet = new Uint16Array(royalMoves[color][royalI][royalJ]);\r\n                                const result = moves.map((e, x) => e & royalMoveSet[x]);\r\n                                const newResultingSquares = countBitsOnBoard(result);\r\n                                if (newResultingSquares > resultingSquares) {\r\n                                    resultingSquares = newResultingSquares;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    const resultingMedian = resultingMedianArray[color];\r\n                    if (resultingMedian)\r\n                        resultingMedian[i][j] = resultingSquares;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    postMessage(resultingMedianArray.map(arr => {\r\n        if (arr) {\r\n            const minimum = countMinimumOf2DArrayExcludingZero(arr);\r\n            return minimum === Infinity ? 0 : minimum;\r\n        }\r\n        else\r\n            return arr;\r\n    }));\r\n};\r\n","import { boardDimension } from \"@moveGeneration/GameInformation/GameData\";\r\nimport { pieceControlConfigSettings } from \"@moveGeneration/PieceControl/PieceControlInterface\";\r\nimport { FENData } from \"../../../FENData/FENData\";\r\nimport { VariantRule } from \"../../VariantRule\";\r\nimport { variantRuleColors } from \"../../VariantRuleInterface\";\r\nimport { RoyalsCannotCapture } from \"../PieceControlDecorators/RoyalsCannotCapture\";\r\nconst tag = \"atomic\";\r\nexport class Atomic extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(Atomic);\r\n    }\r\n    dependencies = new Map([[RoyalsCannotCapture, []]]);\r\n    static atomicCoordinates = [[-1, -1], [-1, 0], [0, -1], [-1, 1], [1, -1], [1, 0], [0, 1], [1, 1]];\r\n    getDecoratorType() { return FENData; }\r\n    getPublicProperties() {\r\n        return {\r\n            parameterValue: true,\r\n            information: {\r\n                name: \"Atomic\",\r\n                description: \"Captures cause all surrounding pieces except pawns to explode\",\r\n                tag,\r\n                color: variantRuleColors.extending,\r\n                displayIcon: \"\"\r\n            }\r\n        };\r\n    }\r\n    matchesPGNDeclaration(match) {\r\n        return /^Atomic$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"Atomic\";\r\n    }\r\n    isDisabled() {\r\n        return false;\r\n    }\r\n    isComplexEvaluation() {\r\n        return true;\r\n    }\r\n    getCapturedPieces(moveData) {\r\n        const baseCoordinates = this.callHandler(\"getCapturedPieces\", arguments);\r\n        const addCoordinate = (disI, disJ) => {\r\n            const coordinateI = moveData.endCoordinates[0] + disI;\r\n            const coordinateJ = moveData.endCoordinates[1] + disJ;\r\n            if (coordinateI >= 0 && coordinateI <= boardDimension\r\n                && coordinateJ >= 0 && coordinateJ <= boardDimension) {\r\n                const pieceString = this.decorator.board.board[coordinateI][coordinateJ];\r\n                if ((pieceString.isPiece() || pieceString.isDead())\r\n                    && !pieceControlConfigSettings[pieceString.piece].moveGenerationSettings.isPawn) {\r\n                    baseCoordinates.push([coordinateI, coordinateJ]);\r\n                }\r\n            }\r\n        };\r\n        if (baseCoordinates.length !== 0) {\r\n            for (const [i, j] of Atomic.atomicCoordinates) {\r\n                addCoordinate(i, j);\r\n            }\r\n            baseCoordinates.push([...moveData.startCoordinates]);\r\n        }\r\n        return baseCoordinates;\r\n    }\r\n}\r\n","import { FENData } from \"@moveGeneration/FENData/FENData\";\r\nimport { totalPlayers, VariantType } from \"@moveGeneration/GameInformation/GameData\";\r\nimport { verifyNumericColor } from \"@moveGeneration/GameInformation/GameUnits/GameUnits\";\r\nimport { createPieceFromData, deadColorIndex } from \"@moveGeneration/GameInformation/GameUnits/PieceString\";\r\nimport { InternalMoveSignature } from \"@moveGeneration/MoveTree/MoveTreeInterface\";\r\nimport { pieceControlConfigSettings } from \"@moveGeneration/PieceControl/PieceControlInterface\";\r\nimport { VariantRule } from \"@moveGeneration/VariantRules/VariantRule\";\r\nimport { variantRuleColors } from \"@moveGeneration/VariantRules/VariantRuleInterface\";\r\nconst tag = \"deadKingWalking\";\r\nexport class DeadKingWalking extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(DeadKingWalking);\r\n    }\r\n    getDecoratorType() { return FENData; }\r\n    getPublicProperties() {\r\n        return {\r\n            parameterValue: true,\r\n            information: {\r\n                name: \"Dead King Walking\",\r\n                description: \"Resigned players are controlled by a bot\",\r\n                tag,\r\n                color: variantRuleColors.autogenous,\r\n                displayIcon: \"\"\r\n            }\r\n        };\r\n    }\r\n    matchesPGNDeclaration(match) {\r\n        return /^DeadKingWalking$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"DeadKingWalking\";\r\n    }\r\n    isDisabled({ variantDataRules, gameType, fenTags }) {\r\n        return gameType === VariantType.Teams\r\n            || fenTags.dead.value.reduce((p, n, i) => p + (Number(n || fenTags.resigned.value[i])), 0) <= totalPlayers - 1\r\n            || variantDataRules.pointsForMate !== false && variantDataRules.pointsForMate < 6;\r\n    }\r\n    processInternalMove(internalMove) {\r\n        if (internalMove.type === InternalMoveSignature.Resign\r\n            || internalMove.type === InternalMoveSignature.ClaimWin\r\n            || internalMove.type === InternalMoveSignature.Timeout) {\r\n            const { sideToMove, fenOptions, board } = this.decorator;\r\n            const dead = fenOptions.tag(\"dead\"), resigned = fenOptions.tag(\"resigned\");\r\n            resigned[sideToMove] = true;\r\n            dead[sideToMove] = true;\r\n            for (const coordinate of board.getPlayerPieces()[sideToMove]) {\r\n                const piece = board.board[coordinate[0]][coordinate[1]].piece;\r\n                if (pieceControlConfigSettings[piece].moveGenerationSettings.isPawn) {\r\n                    board.board[coordinate[0]][coordinate[1]] = createPieceFromData(deadColorIndex, piece);\r\n                }\r\n            }\r\n            const deadPlayers = dead.map((d, i) => d || resigned[i]).filter(Boolean);\r\n            if (deadPlayers.length === totalPlayers - 1) {\r\n                const alivePlayer = deadPlayers.findIndex(d => !d);\r\n                if (verifyNumericColor(alivePlayer)) {\r\n                    this.decorator.assignPoints(alivePlayer, this.decorator.countTotalPointsOnBoard()\r\n                        .reduce((p, n, i) => p + (i === alivePlayer ? n : 0), 0));\r\n                }\r\n            }\r\n            return { stalemates: [false, false, false, false] };\r\n        }\r\n        else\r\n            return this.callHandler(\"processInternalMove\", arguments);\r\n    }\r\n}\r\n","import { SpecialMove } from \"../../../MoveTree/MoveTreeInterface\";\r\nimport { FENData } from \"../../../FENData/FENData\";\r\nimport { emptyPieceString } from \"../../../GameInformation/GameUnits/PieceString\";\r\nimport { VariantRule } from \"../../VariantRule\";\r\nimport { variantRuleColors } from \"../../VariantRuleInterface\";\r\nimport { pieceControlConfigSettings } from \"@moveGeneration/PieceControl/PieceControlInterface\";\r\nimport { nonPlayablePieces } from \"../../../GameInformation/GameUnits/GameUnits\";\r\nimport { assertNonUndefined } from \"@client/ts/baseTypes\";\r\nimport { isVerticalPlacement } from \"@client/ts/logic/BaseInterfaces\";\r\nconst tag = \"enPassant\";\r\nexport class EnPassant extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(EnPassant);\r\n    }\r\n    getDecoratorType() { return FENData; }\r\n    getPublicProperties() {\r\n        return {\r\n            parameterValue: true,\r\n            information: {\r\n                name: \"En Passant\",\r\n                description: \"Pawns can capture en passant\",\r\n                tag,\r\n                color: variantRuleColors.minor,\r\n                displayIcon: \"\"\r\n            }\r\n        };\r\n    }\r\n    matchesPGNDeclaration(match) {\r\n        return /^EnPassant$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"EnPassant\";\r\n    }\r\n    isDisabled() {\r\n        return false;\r\n    }\r\n    processStandardMove(moveData) {\r\n        const enPassants = this.decorator.fenOptions.tag(\"enPassant\");\r\n        const { startCoordinates: [startI, startJ], endCoordinates: [endI, endJ] } = moveData;\r\n        if (moveData.specialType === SpecialMove.EnPassant) {\r\n            const eligibleEnPassants = [];\r\n            enPassants.forEach((e, i) => {\r\n                if (!e)\r\n                    return;\r\n                if (e[0][0] === endI && e[0][1] === endJ)\r\n                    eligibleEnPassants.push(i);\r\n            });\r\n            for (const enPassantCoordinate of eligibleEnPassants) {\r\n                const enPassant = enPassants[enPassantCoordinate];\r\n                assertNonUndefined(enPassant);\r\n                this.decorator.board.board[enPassant[1][0]][enPassant[1][1]] = emptyPieceString;\r\n                enPassants[enPassantCoordinate] = null;\r\n            }\r\n        }\r\n        else {\r\n            const pieceString = this.decorator.board.board[startI][startJ];\r\n            if (!pieceString.isEmpty() && pieceString.piece !== nonPlayablePieces.duck) {\r\n                enPassants[this.decorator.sideToMove] = null;\r\n                const setting = pieceControlConfigSettings[pieceString.piece];\r\n                if (setting.moveGenerationSettings.isPawn\r\n                    && Math.abs(isVerticalPlacement(this.decorator.sideToMove) ? startI - endI : startJ - endJ) === 2) {\r\n                    const enPassantInfo = [\r\n                        [Math.ceil((startI + endI) / 2), Math.ceil((startJ + endJ) / 2)],\r\n                        [endI, endJ]\r\n                    ];\r\n                    enPassants[this.decorator.sideToMove] = enPassantInfo;\r\n                }\r\n            }\r\n        }\r\n        return this.callHandler(\"processStandardMove\", arguments);\r\n    }\r\n}\r\n","import { createTuple } from \"../../../../../baseTypes\";\r\nimport { FENData } from \"../../../FENData/FENData\";\r\nimport { totalPlayers } from \"../../../GameInformation/GameData\";\r\nimport { createPieceFromData, deadColorIndex } from \"../../../GameInformation/GameUnits/PieceString\";\r\nimport { VariantRule } from \"../../VariantRule\";\r\nimport { variantRuleColors } from \"../../VariantRuleInterface\";\r\nimport { RoyalsCannotCapture } from \"../PieceControlDecorators/RoyalsCannotCapture\";\r\nimport { pieceControlConfigSettings } from \"@moveGeneration/PieceControl/PieceControlInterface\";\r\nimport { verifyStandardMove } from \"../../../MoveTree/MoveTreeInterface\";\r\nconst tag = \"fatalCapture\";\r\nexport class FatalCapture extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(FatalCapture);\r\n    }\r\n    dependencies = new Map([[RoyalsCannotCapture, []]]);\r\n    getDecoratorType() { return FENData; }\r\n    getPublicProperties() {\r\n        return {\r\n            parameterValue: true,\r\n            information: {\r\n                name: \"Fatal Capture\",\r\n                description: \"Pieces (but not pawns) die when they capture\",\r\n                tag,\r\n                color: variantRuleColors.extending,\r\n                displayIcon: \"\"\r\n            }\r\n        };\r\n    }\r\n    matchesPGNDeclaration(match) {\r\n        return /^FatalCapture$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"FatalCapture\";\r\n    }\r\n    isDisabled() {\r\n        return false;\r\n    }\r\n    affectOptions(move) {\r\n        let endCaptureCoordinates;\r\n        if (verifyStandardMove(move)) {\r\n            const { startCoordinates: [startI, startJ], endCoordinates: [endI, endJ] } = move;\r\n            const isCapture = this.decorator.board.board[endI][endJ].isPiece();\r\n            const royal = this.decorator.fenOptions.tag(\"royal\")[this.decorator.sideToMove];\r\n            if (royal && startI === royal[0] && startJ === royal[1] && isCapture) {\r\n                return {\r\n                    checkmates: this.decorator.board.gameType.getBaseColors(this.decorator.sideToMove),\r\n                    checks: createTuple(false, totalPlayers), stalemates: createTuple(false, totalPlayers)\r\n                };\r\n            }\r\n            endCaptureCoordinates = isCapture ? move.endCoordinates : undefined;\r\n        }\r\n        const returnType = this.callHandler(\"affectOptions\", arguments);\r\n        if (endCaptureCoordinates) {\r\n            const pieceString = this.decorator.board.board[endCaptureCoordinates[0]][endCaptureCoordinates[1]];\r\n            if (!pieceControlConfigSettings[pieceString.piece].moveGenerationSettings.isPawn) {\r\n                this.decorator.board.board[endCaptureCoordinates[0]][endCaptureCoordinates[1]] = createPieceFromData(deadColorIndex, this.decorator.board.board[endCaptureCoordinates[0]][endCaptureCoordinates[1]].piece);\r\n            }\r\n        }\r\n        return returnType;\r\n    }\r\n}\r\n","import { FENData } from \"../../../FENData/FENData\";\r\nimport { totalPlayers } from \"../../../GameInformation/GameData\";\r\nimport { VariantRule } from \"../../VariantRule\";\r\nconst tag = \"fiftyMoveRule\";\r\nexport class FiftyMoveRule extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(FiftyMoveRule);\r\n    }\r\n    totalFullMoves;\r\n    constructor(fullMoves) {\r\n        super();\r\n        if (typeof fullMoves === 'number' && fullMoves > 0) {\r\n            this.totalFullMoves = fullMoves;\r\n        }\r\n        else {\r\n            this.totalFullMoves = 50;\r\n        }\r\n    }\r\n    getDecoratorType() { return FENData; }\r\n    getPublicProperties() {\r\n        const isDisabled = this.totalFullMoves === Infinity;\r\n        return {\r\n            parameterValue: this.totalFullMoves,\r\n            information: {\r\n                name: isDisabled ? \"50 move rule disabled\" : `${this.totalFullMoves} move rule`,\r\n                textualForm: \"\",\r\n                description: isDisabled ? \"50 move rule disabled\" : `After ${this.totalFullMoves} full moves without captures or pawn pushes game is over`,\r\n                tag\r\n            }\r\n        };\r\n    }\r\n    matchesPGNDeclaration(match) {\r\n        const matchArray = match.match(/^FiftyMoveRule=((?:\\d+)|(?:Infinity))$/i);\r\n        if (matchArray) {\r\n            this.totalFullMoves = Number(matchArray[1]);\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    serializeToParsingForm() {\r\n        return `FiftyMoveRule=${this.totalFullMoves}`;\r\n    }\r\n    isDisabled() {\r\n        return false;\r\n    }\r\n    processStandardMove(moveData) {\r\n        if (this.decorator.getCapturedPieces(moveData).length > 0) {\r\n            this.decorator.plyCount = 0;\r\n        }\r\n        return this.callHandler(\"processStandardMove\", arguments);\r\n    }\r\n    affectOptions(move) {\r\n        const results = this.callHandler(\"affectOptions\", arguments);\r\n        if (move.isIrreversible) {\r\n            this.decorator.plyCount = 0;\r\n        }\r\n        else {\r\n            this.decorator.plyCount++;\r\n        }\r\n        const alivePlayers = totalPlayers - this.decorator.fenOptions.tag(\"dead\").filter(Boolean).length;\r\n        if (alivePlayers > 0 && Math.floor(this.decorator.plyCount / alivePlayers) > this.totalFullMoves) {\r\n            this.decorator.assignGeneralTermination(\"50-move Rule\");\r\n            this.injectIntoBaseClass(function () {\r\n                this.spreadPointsBetweenPlayersEvenly();\r\n            })();\r\n        }\r\n        return results;\r\n    }\r\n}\r\n","import { FENData } from \"../../../FENData/FENData\";\r\nimport { totalPlayers } from \"../../../GameInformation/GameData\";\r\nimport { VariantRule } from \"../../VariantRule\";\r\nimport { variantRuleColors } from \"../../VariantRuleInterface\";\r\nimport { ForcedCapture } from \"../BoardDecorators/ForcedCapture\";\r\nimport { StalemateOptions, stalemateOptionsValues } from \"./StalemateOptions\";\r\nconst tag = \"giveaway\";\r\nexport class Giveaway extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(Giveaway);\r\n    }\r\n    static pointsForPiece = 3;\r\n    static stalematePoints = {\r\n        [1]: 200, [2]: 400, [3]: 600\r\n    };\r\n    dependencies = new Map([[ForcedCapture, []], [StalemateOptions, [stalemateOptionsValues.stalemateWins]]]);\r\n    initiallyAliveColors = totalPlayers;\r\n    getDecoratorType() { return FENData; }\r\n    getPublicProperties() {\r\n        return {\r\n            parameterValue: true,\r\n            information: {\r\n                name: \"Giveaway\",\r\n                description: \"First to lose all pieces or stalemate wins\",\r\n                tag,\r\n                color: variantRuleColors.widespread,\r\n                displayIcon: \"\"\r\n            }\r\n        };\r\n    }\r\n    matchesPGNDeclaration(match) {\r\n        return /^Giveaway$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"Giveaway\";\r\n    }\r\n    isDisabled({ variantDataRules }) {\r\n        return variantDataRules.taboo;\r\n    }\r\n    initDecoratorSettings() {\r\n        this.decorator.fenOptions.setTag(\"royal\", [null, null, null, null]);\r\n        this.initiallyAliveColors = this.decorator.fenOptions.tag(\"dead\")\r\n            .map((d, i) => d || this.decorator.fenOptions.tag(\"resigned\")[i])\r\n            .filter(Boolean).length;\r\n        for (const decorator of this.wrappingDecorators)\r\n            decorator.initDecoratorSettings?.();\r\n    }\r\n    processStandardMove(moveData) {\r\n        const capturedPieces = this.decorator.getCapturedPieces(moveData);\r\n        const board = this.decorator.board.board;\r\n        for (const capturedPiece of capturedPieces) {\r\n            const pieceString = board[capturedPiece[0]][capturedPiece[1]];\r\n            if (pieceString.isPiece()) {\r\n                this.assignPoints(pieceString.color, Giveaway.pointsForPiece, true);\r\n            }\r\n        }\r\n        this.callHandler(\"processStandardMove\", arguments);\r\n        return { endPiece: [] };\r\n    }\r\n    affectOptions() {\r\n        const returnType = this.callHandler(\"affectOptions\", arguments);\r\n        this.decorator.fenOptions.setTag(\"royal\", [null, null, null, null]);\r\n        return returnType;\r\n    }\r\n    obtainPointsForMate() {\r\n        const aliveColors = this.decorator.fenOptions.tag(\"dead\").filter(Boolean).length;\r\n        switch (aliveColors) {\r\n            case 1:\r\n                if (this.initiallyAliveColors === totalPlayers) {\r\n                    return Giveaway.stalematePoints[1];\r\n                }\r\n            // * Fallthrough\r\n            case 2:\r\n                if (this.initiallyAliveColors >= totalPlayers - 1) {\r\n                    return Giveaway.stalematePoints[2];\r\n                }\r\n            // * Fallthrough\r\n            case 3:\r\n                return Giveaway.stalematePoints[3];\r\n            default:\r\n                console.error(`Unexpected players length ${aliveColors}`);\r\n                return 0;\r\n        }\r\n    }\r\n    assignPoints(sideToMove, points, isGiveawayAssigned = false) {\r\n        if (isGiveawayAssigned) {\r\n            for (const decorator of this.wrappingDecorators) {\r\n                if (decorator.assignPoints) {\r\n                    decorator.assignPoints(sideToMove, points);\r\n                    return;\r\n                }\r\n            }\r\n            FENData.prototype.assignPoints.call(this.decorator, sideToMove, points);\r\n        }\r\n    }\r\n}\r\n","import { compareArrays } from \"@client/ts/utils/ArrayUtils\";\r\nimport { compareCoordinates } from \"../../../Board/BoardInterface\";\r\nimport { FENData } from \"../../../FENData/FENData\";\r\nimport { colors, convertCoordinateToPGN4, getPlayerNameFromColor } from \"../../../GameInformation/GameData\";\r\nimport { InternalMoveSignature } from \"../../../MoveTree/MoveTreeInterface\";\r\nimport { VariantRule } from \"../../VariantRule\";\r\nimport { variantRuleColors } from \"../../VariantRuleInterface\";\r\nimport { parseSingleCoordinate } from \"@client/ts/logic/utils/Tags/Utils\";\r\nconst tag = \"kingOfTheHill\";\r\nexport class KingOfTheHill extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(KingOfTheHill);\r\n    }\r\n    static defaultCoordinates = [[7, 7], [7, 6], [6, 7], [6, 6]];\r\n    static defaultRoyal = \"K\";\r\n    hillSquares;\r\n    constructor(hillSquares) {\r\n        super();\r\n        if (Array.isArray(hillSquares) && hillSquares.every((c) => Array.isArray(c) && c.length === 2 && c.every(n => typeof n === 'number'))) {\r\n            this.hillSquares = hillSquares;\r\n        }\r\n        else {\r\n            this.hillSquares = KingOfTheHill.defaultCoordinates;\r\n        }\r\n    }\r\n    getDecoratorType() { return FENData; }\r\n    getPublicProperties() {\r\n        return {\r\n            parameterValue: this.hillSquares,\r\n            information: {\r\n                name: \"King of the Hill\",\r\n                description: \"A king reaching the hill will checkmate all opponents\",\r\n                tag,\r\n                color: variantRuleColors.autogenous,\r\n                displayIcon: \"\"\r\n            }\r\n        };\r\n    }\r\n    matchesPGNDeclaration(match) {\r\n        const matchArray = match.toLowerCase().match(/^KotH(?:=(.+))?$/i);\r\n        if (matchArray) {\r\n            if (matchArray[1]) {\r\n                const coordinatesArray = [];\r\n                const presumedOption = matchArray[1].split(\",\");\r\n                for (const coordinate of presumedOption) {\r\n                    const parsedCoordinate = parseSingleCoordinate(coordinate);\r\n                    if (parsedCoordinate) {\r\n                        coordinatesArray.push(parsedCoordinate);\r\n                    }\r\n                }\r\n                if (coordinatesArray.length > 0) {\r\n                    this.hillSquares = coordinatesArray;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    serializeToParsingForm() {\r\n        if (compareArrays(this.hillSquares, KingOfTheHill.defaultCoordinates)) {\r\n            return \"KotH\";\r\n        }\r\n        else {\r\n            return `KotH=${this.hillSquares.map(c => convertCoordinateToPGN4(c)).join(\",\")}`;\r\n        }\r\n    }\r\n    isDisabled() {\r\n        return false;\r\n    }\r\n    affectOptions() {\r\n        const { board, sideToMove, fenOptions } = this.decorator;\r\n        const returnValues = this.callHandler(\"affectOptions\", arguments);\r\n        const royal = fenOptions.tag(\"royal\")[sideToMove], dead = fenOptions.tag(\"dead\"), wb = fenOptions.tag(\"wb\");\r\n        if (board.variantData.giveaway && this.hillSquares.some(c => {\r\n            const pieceString = board.board[c[0]][c[1]];\r\n            return pieceString.isPiece() && pieceString.piece === KingOfTheHill.defaultRoyal;\r\n        })) {\r\n            this.decorator.processInternalMove({ type: InternalMoveSignature.Stalemate });\r\n            returnValues.stalemates[sideToMove] = true;\r\n        }\r\n        else if (royal && this.hillSquares.some(c => compareCoordinates(c, royal))) {\r\n            const pointsForMate = this.decorator.obtainPointsForMate();\r\n            for (const color of colors) {\r\n                if (color === sideToMove)\r\n                    continue;\r\n                if (!dead[color]) {\r\n                    dead[color] = true;\r\n                    this.decorator.assignPoints(sideToMove, pointsForMate);\r\n                }\r\n            }\r\n            if (this.decorator.board.variantData.taboo) {\r\n                this.decorator.gameOver = `${getPlayerNameFromColor(sideToMove, wb).toUpperCase()} WON THE RACE!`;\r\n            }\r\n            else {\r\n                this.decorator.assignGeneralTermination(\"King of the Hill\");\r\n            }\r\n        }\r\n        return returnValues;\r\n    }\r\n}\r\n","import { createTuple, verifyTupleType } from \"@client/ts/baseTypes\";\r\nimport { compareCoordinates } from \"../../../Board/BoardInterface\";\r\nimport { FENData } from \"../../../FENData/FENData\";\r\nimport { createDefaultFENEffectSettings } from \"../../../FENData/FENDataInterface\";\r\nimport { colors, totalPlayers } from \"../../../GameInformation/GameData\";\r\nimport { verifyStandardMove } from \"../../../MoveTree/MoveTreeInterface\";\r\nimport { VariantRule } from \"../../VariantRule\";\r\nconst tag = \"nCheck\";\r\nexport class NCheck extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(NCheck);\r\n    }\r\n    defaultChecks;\r\n    constructor(defaultChecks) {\r\n        super();\r\n        if (Array.isArray(defaultChecks) && verifyTupleType(defaultChecks, totalPlayers)\r\n            && defaultChecks.every((check) => typeof check === 'number')) {\r\n            this.defaultChecks = defaultChecks;\r\n        }\r\n        else {\r\n            this.defaultChecks = createTuple(3, totalPlayers);\r\n        }\r\n    }\r\n    getDecoratorType() { return FENData; }\r\n    getPublicProperties() {\r\n        const checks = this.defaultChecks.filter(Boolean).reduce((p, n, i, arr) => p + (arr[i - 1] === arr[i] ? \"\" : `-${n}`), \"\").slice(1);\r\n        return {\r\n            parameterValue: this.defaultChecks,\r\n            information: {\r\n                name: `${checks}-Check`,\r\n                textualForm: `${checks}+`,\r\n                description: `Checking a king ${checks} times is checkmate`,\r\n                tag\r\n            }\r\n        };\r\n    }\r\n    matchesPGNDeclaration(match) {\r\n        const matchArray = match.toLowerCase().match(/^(\\d\\d?\\d?(?:-\\d\\d?\\d?){0,3})-check$/i);\r\n        if (matchArray) {\r\n            const checks = matchArray[1].split(\"-\");\r\n            for (let i = 0; i <= checks.length; i++) {\r\n                if (checks[i]) {\r\n                    this.defaultChecks[i] = Number(checks[i]);\r\n                }\r\n                else {\r\n                    while (i !== totalPlayers) {\r\n                        this.defaultChecks[i] = this.defaultChecks[i - 1];\r\n                        i++;\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    serializeToParsingForm() {\r\n        return `${this.defaultChecks.join(\"-\")}-check`;\r\n    }\r\n    isDisabled({ variantDataRules }) {\r\n        return variantDataRules.giveaway;\r\n    }\r\n    initDecoratorSettings() {\r\n        const lives = this.decorator.fenOptions.tag(\"lives\");\r\n        for (const color of colors) {\r\n            if (lives[color] === null) {\r\n                lives[color] = this.defaultChecks[color];\r\n            }\r\n        }\r\n        for (const decorator of this.wrappingDecorators)\r\n            decorator.initDecoratorSettings?.();\r\n    }\r\n    affectOptions(move, settings = createDefaultFENEffectSettings()) {\r\n        const { board, sideToMove } = this.decorator;\r\n        const currentChecks = board.getCurrentChecks().map(arr => new Set(arr));\r\n        const isNCheckValidated = !settings.ignoreCheckmateChecks && !settings.ignoreNextTurn;\r\n        const royal = this.decorator.fenOptions.tag(\"royal\"), lives = this.decorator.fenOptions.tag(\"lives\");\r\n        const results = this.callHandler(\"affectOptions\", arguments);\r\n        const isStandardMove = verifyStandardMove(move);\r\n        if (isNCheckValidated) {\r\n            const updatedChecks = board.getCurrentChecks(sideToMove);\r\n            const playerChecks = createTuple(0, totalPlayers);\r\n            for (const color of colors) {\r\n                for (const coordinate of updatedChecks[color]) {\r\n                    const royalPiece = royal[color];\r\n                    if (!currentChecks[color].has(coordinate)\r\n                        || (royalPiece && isStandardMove\r\n                            && compareCoordinates(move.endCoordinates, royalPiece))) {\r\n                        playerChecks[color]++;\r\n                    }\r\n                }\r\n            }\r\n            if (lives.every((live) => live !== null)) {\r\n                for (const color of colors) {\r\n                    lives[color] -= playerChecks[color];\r\n                    if (lives[color] <= 0) {\r\n                        this.decorator.assignPoints(sideToMove, this.decorator.obtainPointsForMate());\r\n                        this.decorator.turnPiecesDead(color);\r\n                        lives[color] = 0;\r\n                    }\r\n                }\r\n            }\r\n            if (this.decorator.getRealPlayers() > 1) {\r\n                this.decorator.sideToMove = this.decorator.nextTurn(sideToMove);\r\n                board.pregenerateAttacks();\r\n            }\r\n        }\r\n        return results;\r\n    }\r\n}\r\n","import { FENData } from \"../../../FENData/FENData\";\r\nimport { getOppositePlacedColor, totalPlayers, VariantType } from \"../../../GameInformation/GameData\";\r\nimport { pieceControlConfigSettings } from \"../../../PieceControl/PieceControlInterface\";\r\nimport { VariantRule } from \"../../VariantRule\";\r\nconst tag = \"oppositeMultiplier\";\r\nexport class OppositeMultiplier extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(OppositeMultiplier);\r\n    }\r\n    oppositeMultiplierValue = 2;\r\n    getDecoratorType() { return FENData; }\r\n    getPublicProperties() {\r\n        return {\r\n            parameterValue: this.oppositeMultiplierValue,\r\n            information: {\r\n                name: \"Opposite's piece value\",\r\n                textualForm: `Ox${this.oppositeMultiplierValue}`,\r\n                description: `Opposite's pieces are worth ${this.oppositeMultiplierValue} times their normal points value until one player is eliminated`,\r\n                tag\r\n            }\r\n        };\r\n    }\r\n    matchesPGNDeclaration(match) {\r\n        const matchArray = match.toLowerCase().match(/^OppX=(2|3|4|5|6)$/i);\r\n        if (matchArray) {\r\n            this.oppositeMultiplierValue = Number(matchArray[1]);\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    serializeToParsingForm() {\r\n        return `OppX=${this.oppositeMultiplierValue}`;\r\n    }\r\n    isDisabled({ variantDataRules, gameType, fenTags }) {\r\n        return gameType === VariantType.Teams\r\n            || variantDataRules.giveaway\r\n            || fenTags.dead.value.reduce((p, n, i) => p + (Number(n || fenTags.resigned.value[i])), 0) <= totalPlayers - 1;\r\n    }\r\n    getPointsForPiece(pieceString) {\r\n        const dead = this.decorator.fenOptions.tag(\"dead\"), resigned = this.decorator.fenOptions.tag(\"resigned\");\r\n        const aliveColors = dead.map((d, i) => d || resigned[i]).filter(Boolean).length;\r\n        if (aliveColors === totalPlayers && pieceString.isPiece()\r\n            && pieceString.color === getOppositePlacedColor(this.decorator.sideToMove)) {\r\n            return pieceControlConfigSettings[pieceString.piece].points.singlesPoints * this.oppositeMultiplierValue;\r\n        }\r\n        else\r\n            return this.callHandler(\"getPointsForPiece\", arguments);\r\n    }\r\n}\r\n","import { SpecialMove } from \"../../../MoveTree/MoveTreeInterface\";\r\nimport { FENData } from \"../../../FENData/FENData\";\r\nimport { VariantRule } from \"../../VariantRule\";\r\nimport { variantRuleColors } from \"../../VariantRuleInterface\";\r\nimport { getOppositePlacedColor } from \"../../../GameInformation/GameData\";\r\nconst tag = \"oppositeSideCastling\";\r\nexport class OppositeSideCastling extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(OppositeSideCastling);\r\n    }\r\n    getDecoratorType() { return FENData; }\r\n    getPublicProperties() {\r\n        return {\r\n            parameterValue: true,\r\n            information: {\r\n                name: \"Opposite-side Castling\",\r\n                description: \"Once your opponent has castled, you can only castle to the opposite side\",\r\n                tag,\r\n                color: variantRuleColors.minor,\r\n                displayIcon: \"\"\r\n            }\r\n        };\r\n    }\r\n    matchesPGNDeclaration(match) {\r\n        return /^OppositeSideCastling$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"OppositeSideCastling\";\r\n    }\r\n    isDisabled() {\r\n        return false;\r\n    }\r\n    processStandardMove(moveData) {\r\n        const result = this.callHandler(\"processStandardMove\", arguments);\r\n        if (\"specialType\" in moveData) {\r\n            let castlingDataReference;\r\n            if (moveData.specialType === SpecialMove.CastlingKingside) {\r\n                castlingDataReference = this.decorator.fenOptions.tag(\"castleKingside\");\r\n            }\r\n            else if (moveData.specialType === SpecialMove.CastlingQueenside) {\r\n                castlingDataReference = this.decorator.fenOptions.tag(\"castleQueenside\");\r\n            }\r\n            if (castlingDataReference) {\r\n                castlingDataReference[getOppositePlacedColor(this.decorator.sideToMove)] = false;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n","import { FENData } from \"../../../FENData/FENData\";\r\nimport { createPieceFromData } from \"../../../GameInformation/GameUnits/PieceString\";\r\nimport { VariantRule } from \"../../VariantRule\";\r\nimport { variantRuleColors } from \"../../VariantRuleInterface\";\r\nimport { verifyInternalMove, verifyStandardMove } from \"../../../MoveTree/MoveTreeInterface\";\r\nconst tag = \"piecesGoToBanks\";\r\nexport class PiecesGoToBanks extends VariantRule {\r\n    getDecoratorType() { return FENData; }\r\n    getPublicProperties() {\r\n        return {\r\n            parameterValue: true,\r\n            information: {\r\n                name: \"Bank Captures\",\r\n                description: \"Captured pieces go to banks\",\r\n                tag,\r\n                color: variantRuleColors.extending,\r\n                displayIcon: \"X\"\r\n            }\r\n        };\r\n    }\r\n    matchesPGNDeclaration(match) {\r\n        return /^Crazy(?:house|wan)$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"\";\r\n    }\r\n    isDisabled() {\r\n        return false;\r\n    }\r\n    processStandardMove(moveData) {\r\n        const promotedFrom = this.decorator.fenOptions.tag(\"promotedFrom\");\r\n        if (moveData.promotion) {\r\n            const pieceLetter = this.decorator.board.board[moveData.startCoordinates[0]][moveData.startCoordinates[1]].piece;\r\n            promotedFrom.set(moveData.endCoordinates, pieceLetter);\r\n        }\r\n        else {\r\n            for (const [key, value] of promotedFrom) {\r\n                if (key[0] === moveData.startCoordinates[0] && key[1] === moveData.endCoordinates[1]) {\r\n                    promotedFrom.delete(key);\r\n                    promotedFrom.set(moveData.endCoordinates, value);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return this.callHandler(\"processStandardMove\", arguments);\r\n    }\r\n    affectOptions(move) {\r\n        const fenOptions = this.decorator.fenOptions;\r\n        const areBanksEnabled = fenOptions.tag(\"areBanksEnabled\"), bank = fenOptions.tag(\"bank\"), promotedFrom = fenOptions.tag(\"promotedFrom\");\r\n        if (areBanksEnabled[this.decorator.sideToMove]) {\r\n            if (!verifyInternalMove(move)) {\r\n                if (verifyStandardMove(move)) {\r\n                    const captures = this.decorator.getCapturedPieces(move);\r\n                    const sideToMove = this.decorator.sideToMove;\r\n                    const addPieceToBank = (piece) => {\r\n                        for (const [key, value] of bank[sideToMove]) {\r\n                            if (key.piece === piece && key.color === sideToMove) {\r\n                                bank[sideToMove].set(key, value + 1);\r\n                                return;\r\n                            }\r\n                        }\r\n                        bank[sideToMove].set(createPieceFromData(sideToMove, piece), 1);\r\n                    };\r\n                    captures.forEach(c => {\r\n                        for (const [key, value] of promotedFrom) {\r\n                            if (key[0] === c[0] && key[1] === c[1]) {\r\n                                promotedFrom.delete(key);\r\n                                addPieceToBank(value);\r\n                                return;\r\n                            }\r\n                        }\r\n                        addPieceToBank(this.decorator.board.board[c[0]][c[1]].piece);\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        return this.callHandler(\"affectOptions\", arguments);\r\n    }\r\n}\r\n","import { FENData } from \"../../../FENData/FENData\";\r\nimport { totalPlayers, VariantType } from \"../../../GameInformation/GameData\";\r\nimport { VariantRule } from \"../../VariantRule\";\r\nimport { variantRuleColors } from \"../../VariantRuleInterface\";\r\nconst tag = \"playForMate\";\r\nexport class PlayForMate extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(PlayForMate);\r\n    }\r\n    initiallyAliveColors = totalPlayers;\r\n    static checkmatePoints = {\r\n        [1]: 24, [2]: 32, [3]: 48\r\n    };\r\n    getDecoratorType() { return FENData; }\r\n    getPublicProperties() {\r\n        return {\r\n            parameterValue: true,\r\n            information: {\r\n                name: \"Play for mate\",\r\n                description: \"No points for pieces, only checkmates matter\",\r\n                tag,\r\n                color: variantRuleColors.pointsAlternation,\r\n                displayIcon: \"D\"\r\n            }\r\n        };\r\n    }\r\n    matchesPGNDeclaration(match) {\r\n        return /^Play4Mate$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"Play4Mate\";\r\n    }\r\n    isDisabled({ gameType }) {\r\n        return gameType === VariantType.Teams;\r\n    }\r\n    initDecoratorSettings() {\r\n        this.initiallyAliveColors = this.decorator.fenOptions.tag(\"dead\")\r\n            .map((d, i) => d || this.decorator.fenOptions.tag(\"resigned\")[i])\r\n            .filter(Boolean).length;\r\n        for (const decorator of this.wrappingDecorators)\r\n            decorator.initDecoratorSettings?.();\r\n    }\r\n    obtainPointsForMate() {\r\n        const aliveColors = this.decorator.fenOptions.tag(\"dead\").filter(Boolean).length;\r\n        switch (aliveColors) {\r\n            case 1:\r\n                if (this.initiallyAliveColors === totalPlayers) {\r\n                    return PlayForMate.checkmatePoints[1];\r\n                }\r\n            // * Fallthrough\r\n            case 2:\r\n                if (this.initiallyAliveColors >= totalPlayers - 1) {\r\n                    return PlayForMate.checkmatePoints[2];\r\n                }\r\n            // * Fallthrough\r\n            case 3:\r\n                return PlayForMate.checkmatePoints[3];\r\n            default:\r\n                console.error(`Unexpected players length ${aliveColors}`);\r\n                return 0;\r\n        }\r\n    }\r\n    getPointsForPiece() {\r\n        return 0;\r\n    }\r\n}\r\n","import { VariantType } from \"@moveGeneration/GameInformation/GameData\";\r\nimport { FENData } from \"../../../FENData/FENData\";\r\nimport { VariantRule } from \"../../VariantRule\";\r\nconst tag = \"pointsForMate\";\r\nexport class PointsForMate extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(PointsForMate);\r\n    }\r\n    pointsForMate;\r\n    constructor(pointsForMate) {\r\n        super();\r\n        if (typeof pointsForMate === \"number\") {\r\n            this.pointsForMate = pointsForMate;\r\n        }\r\n        else {\r\n            this.pointsForMate = 20;\r\n        }\r\n    }\r\n    getDecoratorType() { return FENData; }\r\n    getPublicProperties() {\r\n        return {\r\n            parameterValue: this.pointsForMate,\r\n            information: {\r\n                name: `${this.pointsForMate}-point checkmate`,\r\n                textualForm: `+${this.pointsForMate}`,\r\n                description: `Checkmates & king captures are worth ${this.pointsForMate} points`,\r\n                tag\r\n            }\r\n        };\r\n    }\r\n    matchesPGNDeclaration(match) {\r\n        const matchArray = match.match(/^PointsForMate=(3|5|10|40)$/i);\r\n        if (matchArray) {\r\n            this.pointsForMate = Number(matchArray[1]);\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    serializeToParsingForm() {\r\n        return `PointsForMate=${this.pointsForMate}`;\r\n    }\r\n    isDisabled({ variantDataRules, gameType }) {\r\n        return variantDataRules.giveaway || variantDataRules.playForMate || gameType === VariantType.Teams;\r\n    }\r\n    obtainPointsForMate() {\r\n        return this.pointsForMate;\r\n    }\r\n}\r\n","import { throwOnNever } from \"@client/ts/baseTypes\";\r\nimport { FENData } from \"../../../FENData/FENData\";\r\nimport { InternalMoveSignature } from \"../../../MoveTree/MoveTreeInterface\";\r\nimport { VariantRule } from \"../../VariantRule\";\r\nimport { variantRuleColors } from \"../../VariantRuleInterface\";\r\nconst tag = \"stalemateOptions\";\r\nexport const stalemateOptionsValues = {\r\n    stalemateLoses: \"loss\",\r\n    stalemateWins: \"win\",\r\n    stalemateDraws: \"draw\"\r\n};\r\nexport const verifyCustomStalemateValue = (v) => Object.values(stalemateOptionsValues).includes(v);\r\nexport class StalemateOptions extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(StalemateOptions);\r\n    }\r\n    type;\r\n    isFFA = false;\r\n    constructor(type) {\r\n        super();\r\n        if (typeof type === 'string' && verifyCustomStalemateValue(type)) {\r\n            this.type = type;\r\n        }\r\n        else {\r\n            this.type = false;\r\n        }\r\n    }\r\n    getDecoratorType() { return FENData; }\r\n    getPublicProperties() {\r\n        const description = this.type === \"draw\"\r\n            ? `Stalemate is a draw`\r\n            : this.isFFA\r\n                ? `The remaining players share the points`\r\n                : `The stalemated player ${this.type === \"loss\" ? \"loses\" : \"wins\"}`;\r\n        return {\r\n            parameterValue: this.type,\r\n            information: {\r\n                name: description,\r\n                description,\r\n                tag,\r\n                color: variantRuleColors.minor,\r\n                displayIcon: \"\"\r\n            }\r\n        };\r\n    }\r\n    matchesPGNDeclaration(match) {\r\n        const matchArray = match.toLowerCase().match(/^Stalemate=(.+)$/i);\r\n        if (matchArray) {\r\n            const presumedOption = matchArray[1];\r\n            if (verifyCustomStalemateValue(presumedOption)) {\r\n                this.type = presumedOption;\r\n            }\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    serializeToParsingForm() {\r\n        return `Stalemate=${this.type || \"draw\"}`;\r\n    }\r\n    isDisabled() {\r\n        return false;\r\n    }\r\n    initDecoratorSettings() {\r\n        if (this.type === false) {\r\n            if (this.decorator.board.gameType.isFFA()\r\n                && this.decorator.fenOptions.tag(\"dead\").filter(Boolean).length > 2) {\r\n                this.type = \"win\";\r\n                this.isFFA = true;\r\n            }\r\n            else {\r\n                this.type = \"draw\";\r\n                this.isFFA = false;\r\n            }\r\n        }\r\n        for (const decorator of this.wrappingDecorators)\r\n            decorator.initDecoratorSettings?.();\r\n    }\r\n    processInternalMove(internalMove) {\r\n        const currentTurn = this.decorator.sideToMove;\r\n        const returnValues = this.callHandler(\"processInternalMove\", arguments);\r\n        if (internalMove.type === InternalMoveSignature.Stalemate) {\r\n            const pointsForMate = this.decorator.obtainPointsForMate();\r\n            switch (this.type) {\r\n                case \"loss\":\r\n                    if (!this.isFFA) {\r\n                        this.decorator.points[currentTurn] += pointsForMate;\r\n                        break;\r\n                    }\r\n                // * Fallthrough\r\n                case \"draw\":\r\n                    this.injectIntoBaseClass(function () {\r\n                        this.spreadPointsBetweenPlayersEvenly();\r\n                    })();\r\n                    break;\r\n                case \"win\":\r\n                    this.decorator.points[this.decorator.sideToMove] += pointsForMate;\r\n                    break;\r\n                case false:\r\n                    break;\r\n                default:\r\n                    throwOnNever(this.type);\r\n            }\r\n            if (this.decorator.getRealPlayers() === 1) {\r\n                this.decorator.assignGeneralTermination(\"Stalemate\", currentTurn);\r\n            }\r\n        }\r\n        return returnValues;\r\n    }\r\n}\r\n","import { compareCoordinates } from \"../../../Board/BoardInterface\";\r\nimport { FENData } from \"../../../FENData/FENData\";\r\nimport { colors, VariantType } from \"../../../GameInformation/GameData\";\r\nimport { createPieceFromData } from \"../../../GameInformation/GameUnits/PieceString\";\r\nimport { pieceControlConfigSettings } from \"../../../PieceControl/PieceControlInterface\";\r\nimport { VariantRule } from \"../../VariantRule\";\r\nimport { variantRuleColors } from \"../../VariantRuleInterface\";\r\nimport { DeadKingWalking } from \"./DeadKingWalking\";\r\nconst tag = \"takeover\";\r\nexport class Takeover extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(Takeover);\r\n    }\r\n    dependencies = new Map([[DeadKingWalking, []]]);\r\n    getDecoratorType() { return FENData; }\r\n    getPublicProperties() {\r\n        return {\r\n            parameterValue: true,\r\n            information: {\r\n                name: \"Takeover\",\r\n                description: \"Checkmate players to take control of their pieces\",\r\n                tag,\r\n                color: variantRuleColors.phased,\r\n                displayIcon: \"\"\r\n            }\r\n        };\r\n    }\r\n    matchesPGNDeclaration(match) {\r\n        return /^Takeover$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"Takeover\";\r\n    }\r\n    isDisabled({ gameType }) {\r\n        return gameType === VariantType.Teams;\r\n    }\r\n    affectOptions() {\r\n        const sideToMove = this.decorator.sideToMove, detectedPieces = this.decorator.board.getPlayerPieces();\r\n        const results = this.callHandler(\"affectOptions\", arguments);\r\n        for (const color of colors) {\r\n            if (!results.checkmates[color])\r\n                continue;\r\n            for (const piece of detectedPieces[sideToMove]) {\r\n                const pieceString = this.decorator.board.board[piece[0]][piece[1]];\r\n                if (!pieceString.isDead() || pieceControlConfigSettings[pieceString.piece].moveGenerationSettings.isPawn)\r\n                    continue;\r\n                this.decorator.board.board[piece[0]][piece[1]] = createPieceFromData(sideToMove, pieceString.piece);\r\n            }\r\n        }\r\n        return results;\r\n    }\r\n    countTotalPointsOnBoard() {\r\n        const zombieImmune = this.decorator.fenOptions.tag(\"zombieImmune\"), royals = this.decorator.fenOptions.tag(\"royal\");\r\n        const resultingPoints = [0, 0, 0, 0];\r\n        this.decorator.board.getPlayerPieces().forEach((army, color) => {\r\n            if (zombieImmune[color])\r\n                return;\r\n            const royal = royals[color];\r\n            for (const coordinate of army) {\r\n                if (royal && compareCoordinates(coordinate, royal)) {\r\n                    resultingPoints[color] += this.decorator.obtainPointsForMate();\r\n                }\r\n                else {\r\n                    const piece = this.decorator.board.board[coordinate[0]][coordinate[1]].piece;\r\n                    resultingPoints[color] += pieceControlConfigSettings[piece].points.singlesPoints;\r\n                }\r\n            }\r\n        });\r\n        return resultingPoints;\r\n    }\r\n}\r\n","import { FENData } from \"../../../FENData/FENData\";\r\nimport { VariantRule } from \"../../VariantRule\";\r\nconst tag = \"threefoldRepetition\";\r\nexport class ThreefoldRepetition extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(ThreefoldRepetition);\r\n    }\r\n    totalRepetitionsRequired;\r\n    constructor(totalRepetitions) {\r\n        super();\r\n        if (typeof totalRepetitions === 'number' && totalRepetitions > 0) {\r\n            this.totalRepetitionsRequired = totalRepetitions;\r\n        }\r\n        else {\r\n            this.totalRepetitionsRequired = 3;\r\n        }\r\n    }\r\n    getDecoratorType() { return FENData; }\r\n    getPublicProperties() {\r\n        const isDisabled = this.totalRepetitionsRequired === Infinity;\r\n        return {\r\n            parameterValue: this.totalRepetitionsRequired,\r\n            information: {\r\n                name: isDisabled ? \"3-fold repetition disabled\" : `${this.totalRepetitionsRequired}-fold repetition`,\r\n                textualForm: \"\",\r\n                description: isDisabled ? \"3-fold repetition disabled\" : `After position repeats ${this.totalRepetitionsRequired} times game is over`,\r\n                tag\r\n            }\r\n        };\r\n    }\r\n    matchesPGNDeclaration(match) {\r\n        const matchArray = match.match(/^ThreefoldRepetition=((?:\\d+)|(?:Infinity))$/i);\r\n        if (matchArray) {\r\n            this.totalRepetitionsRequired = Number(matchArray[1]);\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    serializeToParsingForm() {\r\n        return `ThreefoldRepetition=${this.totalRepetitionsRequired}`;\r\n    }\r\n    isDisabled() {\r\n        return false;\r\n    }\r\n    affectOptions() {\r\n        const results = this.callHandler(\"affectOptions\", arguments);\r\n        const repetitions = this.decorator.board.moves.getHash(this.decorator.constructPreliminaryHashString());\r\n        if (repetitions + 1 >= this.totalRepetitionsRequired) {\r\n            this.decorator.assignGeneralTermination(\"Threefold Repetition\");\r\n            this.injectIntoBaseClass(function () {\r\n                this.spreadPointsBetweenPlayersEvenly();\r\n            })();\r\n        }\r\n        return results;\r\n    }\r\n}\r\n","import { createTuple } from \"../../../../../baseTypes\";\r\nimport { totalPlayers } from \"../../../GameInformation/GameData\";\r\nimport { PieceControl } from \"../../../PieceControl/PieceControl\";\r\nimport { VariantRule } from \"../../VariantRule\";\r\nimport { variantRuleColors } from \"../../VariantRuleInterface\";\r\nconst tag = \"anyCapture\";\r\nexport class AnyCapture extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(AnyCapture);\r\n    }\r\n    getDecoratorType() { return PieceControl; }\r\n    getPublicProperties() {\r\n        return {\r\n            parameterValue: true,\r\n            information: {\r\n                name: \"Any Capture\",\r\n                description: \"You can capture your own pieces\",\r\n                tag,\r\n                color: variantRuleColors.autogenous,\r\n                displayIcon: \"\"\r\n            }\r\n        };\r\n    }\r\n    matchesPGNDeclaration(match) {\r\n        return /^AnyCapture$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"AnyCapture\";\r\n    }\r\n    isDisabled() {\r\n        return false;\r\n    }\r\n    configure(configuration) {\r\n        const modifiedConfiguration = {\r\n            ...configuration,\r\n            immunePieces: createTuple(false, totalPlayers),\r\n        };\r\n        for (const decorator of this.wrappingDecorators) {\r\n            if (decorator.configure)\r\n                return decorator.configure(modifiedConfiguration);\r\n        }\r\n        return PieceControl.prototype.configure.call(this.decorator, modifiedConfiguration);\r\n    }\r\n}\r\n","import { verifyPieceLetter, pieceControlConfigSettings, defaultPieces } from \"@moveGeneration/PieceControl/PieceControlInterface\";\r\nimport { compileEnumeration, prefixWithIndefiniteArticle } from \"@client/ts/utils/StringFormatUtils\";\r\nimport { PieceControl } from \"../../../PieceControl/PieceControl\";\r\nimport { VariantRule } from \"../../VariantRule\";\r\nconst tag = \"promotionPieces\";\r\nexport class PromoteTo extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(PromoteTo);\r\n    }\r\n    promotionPieces;\r\n    constructor(promotionPieces) {\r\n        super();\r\n        this.promotionPieces = Array.isArray(promotionPieces)\r\n            && promotionPieces.every((p) => typeof p === 'string' && verifyPieceLetter(p))\r\n            ? promotionPieces : [defaultPieces.queen, defaultPieces.rook, defaultPieces.bishop, defaultPieces.knight];\r\n    }\r\n    getDecoratorType() { return PieceControl; }\r\n    getPublicProperties() {\r\n        const pieceNames = this.promotionPieces.reduce((p, c) => {\r\n            const pieceName = pieceControlConfigSettings[c].naming.name;\r\n            return [...p, pieceName];\r\n        }, []);\r\n        return {\r\n            parameterValue: this.promotionPieces,\r\n            information: {\r\n                name: \"Promotion Pieces\",\r\n                textualForm: \"\",\r\n                description: `Pawns promote to ${prefixWithIndefiniteArticle(compileEnumeration(pieceNames))}`,\r\n                tag\r\n            }\r\n        };\r\n    }\r\n    matchesPGNDeclaration(match) {\r\n        const matchArray = match.match(/^PromoteTo=([A-Zx]+)$/i);\r\n        if (matchArray) {\r\n            const inputPromotion = matchArray[1].split(\"\").filter((p) => verifyPieceLetter(p));\r\n            if (inputPromotion.length)\r\n                this.promotionPieces = inputPromotion;\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    serializeToParsingForm() {\r\n        return `PromoteTo=${this.promotionPieces.join(\"\")}`;\r\n    }\r\n    isDisabled() {\r\n        return false;\r\n    }\r\n    initDecoratorSettings() {\r\n        if (this.decorator.hooks.usePawnLogic) {\r\n            this.decorator.hooks.usePawnLogic.promotionPieces = this.promotionPieces;\r\n        }\r\n        for (const decorator of this.wrappingDecorators)\r\n            decorator.initDecoratorSettings?.();\r\n    }\r\n}\r\n","import { formatOrdinalNumber } from \"@client/ts/utils/StringFormatUtils\";\r\nimport { boardDimension } from \"../../../GameInformation/GameData\";\r\nimport { PieceControl } from \"../../../PieceControl/PieceControl\";\r\nimport { VariantRule } from \"../../VariantRule\";\r\nconst tag = \"promotionRank\";\r\nexport const disabledRank = 99;\r\nexport class PromotionRank extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(PromotionRank);\r\n    }\r\n    promotionRank;\r\n    constructor(promotionRank) {\r\n        super();\r\n        this.promotionRank = typeof promotionRank === 'number' ? promotionRank : 8;\r\n    }\r\n    getDecoratorType() { return PieceControl; }\r\n    getPublicProperties() {\r\n        return {\r\n            parameterValue: this.promotionRank,\r\n            information: {\r\n                name: \"Promotion Rank\",\r\n                textualForm: \"\",\r\n                description: `on the ${this.promotionRank}${formatOrdinalNumber(this.promotionRank)} rank`,\r\n                tag\r\n            }\r\n        };\r\n    }\r\n    matchesPGNDeclaration(match) {\r\n        const matchArray = match.match(/^Prom=(\\d\\d?)$/i);\r\n        if (matchArray) {\r\n            this.promotionRank = Number(matchArray[1]);\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    serializeToParsingForm() {\r\n        return `Prom=${this.promotionRank}`;\r\n    }\r\n    isDisabled() {\r\n        return false;\r\n    }\r\n    initDecoratorSettings() {\r\n        if (this.decorator.hooks.usePawnLogic) {\r\n            this.decorator.hooks.usePawnLogic.promotionRanks = [boardDimension - this.promotionRank,\r\n                this.promotionRank - 1, this.promotionRank - 1, boardDimension - this.promotionRank];\r\n        }\r\n        for (const decorator of this.wrappingDecorators)\r\n            decorator.initDecoratorSettings?.();\r\n    }\r\n}\r\n","import { PieceControl } from \"../../../PieceControl/PieceControl\";\r\nimport { AttackType } from \"../../../PieceControl/PieceControlInterface\";\r\nimport { VariantRule } from \"../../VariantRule\";\r\nimport { variantRuleColors } from \"../../VariantRuleInterface\";\r\nconst tag = \"royalsCannotCapture\";\r\nexport class RoyalsCannotCapture extends VariantRule {\r\n    getDecoratorType() { return PieceControl; }\r\n    getPublicProperties() {\r\n        return {\r\n            parameterValue: true,\r\n            information: {\r\n                name: \"Royals Cannot Capture\",\r\n                description: \"Royal pieces cannot capture pieces.\",\r\n                tag,\r\n                color: variantRuleColors.autogenous,\r\n                displayIcon: \"\"\r\n            }\r\n        };\r\n    }\r\n    matchesPGNDeclaration() {\r\n        return false;\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"\";\r\n    }\r\n    isDisabled() {\r\n        return false;\r\n    }\r\n    getMovePossibility(configuration) {\r\n        const royal = this.decorator.fenData.fenOptions.tag(\"royal\")[this.decorator.color];\r\n        if (royal && royal[0] === this.decorator.i && royal[1] === this.decorator.j) {\r\n            configuration.special = AttackType.MoveOnly;\r\n        }\r\n        for (const decorator of this.wrappingDecorators) {\r\n            if (decorator.getMovePossibility)\r\n                return decorator.getMovePossibility(configuration);\r\n        }\r\n        return PieceControl.prototype.getMovePossibility.call(this.decorator, configuration);\r\n    }\r\n}\r\n","import { AttackType } from \"@moveGeneration/PieceControl/PieceControlInterface\";\r\nimport { PieceControl } from \"../../../PieceControl/PieceControl\";\r\nimport { VariantRule } from \"../../VariantRule\";\r\nimport { variantRuleColors } from \"../../VariantRuleInterface\";\r\nconst tag = \"sideways\";\r\nexport class Sideways extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(Sideways);\r\n    }\r\n    getDecoratorType() { return PieceControl; }\r\n    getPublicProperties() {\r\n        return {\r\n            parameterValue: true,\r\n            information: {\r\n                name: \"Sideways\",\r\n                description: \"Pawns can also move one square sideways\",\r\n                tag,\r\n                color: variantRuleColors.autogenous,\r\n                displayIcon: \"\"\r\n            }\r\n        };\r\n    }\r\n    matchesPGNDeclaration(match) {\r\n        return /^Sideways$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"Sideways\";\r\n    }\r\n    isDisabled() {\r\n        return false;\r\n    }\r\n    getPossibleCells() {\r\n        if (this.decorator.hooks.usePawnLogic) {\r\n            this.injectIntoBaseClass(function () {\r\n                this.generateJumpAttack({ displacement: [0, -1], special: AttackType.MoveOnly });\r\n                this.generateJumpAttack({ displacement: [0, 1], special: AttackType.MoveOnly });\r\n            })();\r\n        }\r\n        for (const decorator of this.wrappingDecorators) {\r\n            if (decorator.getPossibleCells)\r\n                return decorator.getPossibleCells();\r\n        }\r\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\r\n        const prototype = Object.getPrototypeOf(this.decorator);\r\n        prototype.getPossibleCells.call(this.decorator);\r\n    }\r\n}\r\n","import { PieceControl } from \"../../../PieceControl/PieceControl\";\r\nimport { AttackType } from \"../../../PieceControl/PieceControlInterface\";\r\nimport { VariantRule } from \"../../VariantRule\";\r\nconst tag = \"stonewall\";\r\nexport class Stonewall extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(Stonewall);\r\n    }\r\n    getDecoratorType() {\r\n        return PieceControl;\r\n    }\r\n    getPublicProperties() {\r\n        return {\r\n            parameterValue: true,\r\n            information: {\r\n                name: \"Stonewall\",\r\n                textualForm: \"\",\r\n                description: \"Dead pieces cannot be captured\",\r\n                tag\r\n            }\r\n        };\r\n    }\r\n    matchesPGNDeclaration(match) {\r\n        return /^Deadwall$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"Deadwall\";\r\n    }\r\n    isDisabled() {\r\n        return false;\r\n    }\r\n    getMovePossibility(configuration) {\r\n        const { displacement: [i, j], special } = configuration;\r\n        let modifiedConfiguration = configuration;\r\n        if ((special === AttackType.AttackOnly || special === AttackType.Normal || special === AttackType.RayGen) &&\r\n            this.decorator.board[i] &&\r\n            this.decorator.board[i][j] &&\r\n            this.decorator.board[i][j].isDead()) {\r\n            modifiedConfiguration = {\r\n                ...configuration,\r\n                special: AttackType.MoveOnly\r\n            };\r\n        }\r\n        for (const decorator of this.wrappingDecorators) {\r\n            if (decorator.getMovePossibility)\r\n                return decorator.getMovePossibility(configuration);\r\n        }\r\n        return PieceControl.prototype.getMovePossibility.call(this.decorator, modifiedConfiguration);\r\n    }\r\n}\r\n","import { PieceControl } from \"../../../PieceControl/PieceControl\";\r\nimport { VariantRule } from \"../../VariantRule\";\r\nimport { variantRuleColors } from \"../../VariantRuleInterface\";\r\nconst tag = \"torpedo\";\r\nexport class Torpedo extends VariantRule {\r\n    static {\r\n        VariantRule.initVariantRule(Torpedo);\r\n    }\r\n    getDecoratorType() { return PieceControl; }\r\n    getPublicProperties() {\r\n        return {\r\n            parameterValue: true,\r\n            information: {\r\n                name: \"Torpedo\",\r\n                description: \"Pawns can always jump two squares\",\r\n                tag,\r\n                color: variantRuleColors.autogenous,\r\n                displayIcon: \"\"\r\n            }\r\n        };\r\n    }\r\n    matchesPGNDeclaration(match) {\r\n        return /^Torpedo$/i.test(match);\r\n    }\r\n    serializeToParsingForm() {\r\n        return \"Torpedo\";\r\n    }\r\n    isDisabled() {\r\n        return false;\r\n    }\r\n    configure(configuration) {\r\n        const modifiedConfiguration = {\r\n            ...configuration,\r\n            baseRank: true\r\n        };\r\n        for (const decorator of this.wrappingDecorators) {\r\n            if (decorator.configure)\r\n                return decorator.configure(modifiedConfiguration);\r\n        }\r\n        PieceControl.prototype.configure.call(this.decorator, modifiedConfiguration);\r\n    }\r\n}\r\n","import { createHexColor } from \"@client/ts/interfaces/Colors\";\r\nexport const variantRuleColors = {\r\n    minor: createHexColor(\"#e01492\"),\r\n    visual: createHexColor(\"#ad5709\"),\r\n    autogenous: createHexColor(\"#f2791e\"),\r\n    metadata: createHexColor(\"#89a5d3\"),\r\n    startingPosition: createHexColor(\"#7030a0\"),\r\n    extending: createHexColor(\"#fbaa07\"),\r\n    widespread: createHexColor(\"#d40c0c\"),\r\n    pointsAlternation: createHexColor(\"#00b0f0\"),\r\n    phased: createHexColor(\"#00b050\")\r\n};\r\n","import { Board } from \"../Board/Board\";\r\nimport { FENData } from \"../FENData/FENData\";\r\nimport { PieceControl } from \"../PieceControl/PieceControl\";\r\nimport { ForcedCapture } from \"./VariantRuleDefinitions/BoardDecorators/ForcedCapture\";\r\nimport { SeirawanSetup } from \"./VariantRuleDefinitions/BoardDecorators/SeirawanSetup\";\r\nimport { SetupChess } from \"./VariantRuleDefinitions/BoardDecorators/SetupChess\";\r\nimport { Taboo } from \"./VariantRuleDefinitions/BoardDecorators/Taboo\";\r\nimport { FiftyMoveRule } from \"./VariantRuleDefinitions/FENDataDecorators/FiftyMoveRule\";\r\nimport { Giveaway } from \"./VariantRuleDefinitions/FENDataDecorators/Giveaway\";\r\nimport { StalemateOptions } from \"./VariantRuleDefinitions/FENDataDecorators/StalemateOptions\";\r\nimport { ThreefoldRepetition } from \"./VariantRuleDefinitions/FENDataDecorators/ThreefoldRepetition\";\r\nimport { PromoteTo } from \"./VariantRuleDefinitions/PieceControlDecorators/PromoteTo\";\r\nimport { PromotionRank } from \"./VariantRuleDefinitions/PieceControlDecorators/PromotionRank\";\r\nimport { VariantRule } from \"./VariantRule\";\r\nexport const createBaseParsingTypes = () => ({\r\n    boardDecorators: [], pieceControlDecorators: [], fenDataDecorators: []\r\n});\r\nconst variantRulePriorities = [\r\n    SetupChess, ForcedCapture, Taboo, SeirawanSetup,\r\n    PromoteTo, PromotionRank,\r\n    Giveaway\r\n].reverse();\r\nfunction differentiateDecoratorMethods(variant, methods) {\r\n    const verifyDecorator = (rv, type) => rv.getDecoratorType() === type;\r\n    if (verifyDecorator(variant, Board)) {\r\n        methods.boardDecorators(variant);\r\n    }\r\n    else if (verifyDecorator(variant, PieceControl)) {\r\n        methods.pieceControlDecorators(variant);\r\n    }\r\n    else if (verifyDecorator(variant, FENData)) {\r\n        methods.fenDataDecorators(variant);\r\n    }\r\n}\r\nexport function parseVariantRules(rules) {\r\n    const variantClasses = new Set();\r\n    const variantRuleList = new Set();\r\n    const forcedRules = [PromotionRank, PromoteTo, StalemateOptions, FiftyMoveRule, ThreefoldRepetition];\r\n    for (const variantRule of VariantRule.variantRuleList) {\r\n        const rv = new variantRule();\r\n        variantRuleList.add(rv);\r\n        variantClasses.add(variantRule);\r\n    }\r\n    const finalList = {\r\n        boardDecorators: [], pieceControlDecorators: [], fenDataDecorators: []\r\n    };\r\n    const rulesStrings = rules.split(/\\s+/);\r\n    const insertVariantRule = (variant) => {\r\n        differentiateDecoratorMethods(variant, {\r\n            boardDecorators: (variant) => {\r\n                finalList.boardDecorators.push(variant);\r\n            },\r\n            pieceControlDecorators: (variant) => {\r\n                finalList.pieceControlDecorators.push(variant);\r\n            },\r\n            fenDataDecorators: (variant) => {\r\n                finalList.fenDataDecorators.push(variant);\r\n            }\r\n        });\r\n        for (const [dependency, dependencyArgs] of variant.dependencies) {\r\n            if (!Object.values(finalList).some((decorators) => decorators.some(rv => rv instanceof dependency))) {\r\n                insertVariantRule(new dependency(...dependencyArgs));\r\n            }\r\n        }\r\n    };\r\n    for (const variant of variantRuleList) {\r\n        for (const ruleString of rulesStrings) {\r\n            if (variant.matchesPGNDeclaration(ruleString)) {\r\n                insertVariantRule(variant);\r\n                variantRuleList.delete(variant);\r\n            }\r\n        }\r\n    }\r\n    for (const forcedRule of forcedRules) {\r\n        const variant = new forcedRule();\r\n        differentiateDecoratorMethods(variant, {\r\n            boardDecorators: (variant) => {\r\n                if (!finalList.boardDecorators.some(rule => rule instanceof forcedRule)) {\r\n                    finalList.boardDecorators.push(variant);\r\n                }\r\n            },\r\n            pieceControlDecorators: (variant) => {\r\n                if (!finalList.pieceControlDecorators.some(rule => rule instanceof forcedRule)) {\r\n                    finalList.pieceControlDecorators.push(variant);\r\n                }\r\n            },\r\n            fenDataDecorators: (variant) => {\r\n                if (!finalList.fenDataDecorators.some(rule => rule instanceof forcedRule)) {\r\n                    finalList.fenDataDecorators.push(variant);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    for (const rule of variantRulePriorities) {\r\n        const resultingRule = new rule();\r\n        differentiateDecoratorMethods(resultingRule, {\r\n            boardDecorators: () => {\r\n                const index = finalList.boardDecorators.findIndex(c => c instanceof rule);\r\n                if (index !== -1) {\r\n                    finalList.boardDecorators.unshift(finalList.boardDecorators.splice(index, 1)[0]);\r\n                }\r\n            },\r\n            pieceControlDecorators: () => {\r\n                const index = finalList.pieceControlDecorators.findIndex(c => c instanceof rule);\r\n                if (index !== -1) {\r\n                    finalList.pieceControlDecorators.unshift(finalList.pieceControlDecorators.splice(index, 1)[0]);\r\n                }\r\n            },\r\n            fenDataDecorators: () => {\r\n                const index = finalList.fenDataDecorators.findIndex(c => c instanceof rule);\r\n                if (index !== -1) {\r\n                    finalList.fenDataDecorators.unshift(finalList.fenDataDecorators.splice(index, 1)[0]);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    return finalList;\r\n}\r\nexport function compileVariantRuleData(rules) {\r\n    const finalObject = {};\r\n    const variantRuleList = VariantRule.variantRuleList.map(rv => new rv());\r\n    for (const rule of variantRuleList) {\r\n        finalObject[rule.getPublicProperties().information.tag] = false;\r\n    }\r\n    const setFinalObjectProperty = (properties) => {\r\n        finalObject[properties.information.tag] = properties.parameterValue;\r\n    };\r\n    const ruleArray = [...rules.boardDecorators, ...rules.fenDataDecorators, ...rules.pieceControlDecorators];\r\n    for (const rule of ruleArray) {\r\n        setFinalObjectProperty(rule.getPublicProperties());\r\n    }\r\n    return finalObject;\r\n}\r\nexport function copyVariantRules(rvs) {\r\n    return rvs.map(rv => {\r\n        const parameterValue = rv.getPublicProperties().parameterValue;\r\n        const parameterArray = parameterValue !== false ? [parameterValue] : [];\r\n        const constructor = rv.constructor;\r\n        return new constructor(parameterArray);\r\n    });\r\n}\r\nexport function validateVariantRules(board) {\r\n    const configuration = {\r\n        variantDataRules: board.variantData,\r\n        gameType: board.gameType.type,\r\n        fenTags: board.data.fenOptions.tags\r\n    };\r\n    return {\r\n        boardDecorators: board.variantRules.boardDecorators.filter(rv => !rv.isDisabled(configuration)),\r\n        pieceControlDecorators: board.variantRules.pieceControlDecorators.filter(rv => !rv.isDisabled(configuration)),\r\n        fenDataDecorators: board.variantRules.fenDataDecorators.filter(rv => !rv.isDisabled(configuration))\r\n    };\r\n}\r\n","import { nonPlayablePieces } from \"@moveGeneration/GameInformation/GameUnits/GameUnits\";\r\nimport { compileVariantRuleData } from \"@moveGeneration/VariantRules/VariantRuleSetup\";\r\nimport { parsePGN4Moves } from \"./Moves/ParsePGNMoves\";\r\nimport { serializePGNMoves } from \"./Moves/SerializePGNMoves\";\r\nimport { createDefaultVariantTags } from \"./TagInterface\";\r\nexport function parsePGN4(pgn4) {\r\n    let pgn4Tags, pgn4Moves = \"\";\r\n    const match = pgn4.match(/(?=1\\.\\s*?[xA-Z-a-n0-9-])/);\r\n    if (match?.index) {\r\n        pgn4Moves = pgn4.substring(match.index);\r\n        pgn4Tags = pgn4.substring(0, match.index).split(\"]\").map(t => t.trim());\r\n    }\r\n    else {\r\n        pgn4Tags = pgn4.split(\"]\").map(t => t.trim());\r\n    }\r\n    const moves = pgn4Moves.length ? parsePGN4Moves(pgn4Moves) : [];\r\n    const variantTags = createDefaultVariantTags();\r\n    for (const input of pgn4Tags) {\r\n        let variantTag;\r\n        for (variantTag in variantTags) {\r\n            const tag = variantTags[variantTag];\r\n            if (Object.prototype.hasOwnProperty.call(variantTags, variantTag) && tag.verifyTagInParsing(input)) {\r\n                tag.currentValue = tag.parseTag(input);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    const gameData = {\r\n        site: variantTags.site.currentValue,\r\n        gameNumber: variantTags.gameNumber.currentValue,\r\n        date: variantTags.date.currentValue,\r\n        timeControl: variantTags.timeControl.currentValue,\r\n        players: variantTags.playerData.currentValue,\r\n        termination: variantTags.termination.currentValue,\r\n        result: undefined,\r\n    };\r\n    const variantRuleData = compileVariantRuleData(variantTags.variantRules.currentValue);\r\n    const promotionPieces = Array.isArray(variantRuleData.promotionPieces) ? variantRuleData.promotionPieces : [];\r\n    const nonPlayablePieceValues = Object.values(nonPlayablePieces);\r\n    return {\r\n        gameData,\r\n        gameType: variantTags.variantType.currentValue,\r\n        variantRules: variantTags.variantRules.currentValue,\r\n        variantRuleData,\r\n        board: variantTags.startingPosition.currentValue.board,\r\n        fenData: variantTags.startingPosition.currentValue.fenData,\r\n        pieceSet: new Set([...variantTags.startingPosition.currentValue.pieceSet,\r\n            ...promotionPieces].filter(e => !nonPlayablePieceValues.includes(e))),\r\n        moves\r\n    };\r\n}\r\nconst defaultTags = createDefaultVariantTags();\r\nexport function serializeBoard(board) {\r\n    return {\r\n        board: Object.values(defaultTags).map(t => t.serialize(board))\r\n            .filter((v) => v !== undefined).join(\"\\n\"),\r\n        moves: serializePGNMoves(board.moves)\r\n    };\r\n}\r\n","import { assertNonUndefined } from \"@client/ts/baseTypes\";\r\nimport { verifyColorEnumValue, colorEnum } from \"@moveGeneration/GameInformation/GameUnits/GameUnits\";\r\nimport { duckPieceString, createPieceFromData, deadColorIndex } from \"@moveGeneration/GameInformation/GameUnits/PieceString\";\r\nimport { InternalMoveSignature, SpecialMove, verifyInternalMove, createDummyMoveMetadata, verifyMoveWrapperProperties, verifyRequiredMove } from \"@moveGeneration/MoveTree/MoveTreeInterface\";\r\nimport { verifyPieceLetter } from \"@moveGeneration/PieceControl/PieceControlInterface\";\r\nimport { parseEnPassantCoordinates, parseSingleCoordinate } from \"../Utils\";\r\nexport const PGN4_SYNTAX = {\r\n    SPLIT: '.',\r\n    PIECE_REGEX: /[xA-Z-a-nrbyg0-9-=+#@]/,\r\n    PIECE_REGEX_SIMPLIFIED: /[A-Z-a-n0-9-]/,\r\n    MOVE_CAPTURING_REGEX: /^[A-Z-]?([a-n]\\d{1,2})(?:-|x[A-Z-]?)[A-Z-]?([a-n]\\d{1,2})/,\r\n    DUCK_MOVE_CAPTURING_REGEX: /([a-n]\\d{1,2})?-([a-n]\\d{1,2})/,\r\n    DROPPING_MOVE_CAPTURING_REGEX: /?@([a-z])([A-Z-])-([a-n]\\d{1,2})/,\r\n    BRACKETS: {\r\n        COMMENT_START: '{',\r\n        COMMENT_END: '}',\r\n        VARIATION_START: '(',\r\n        VARIATION_END: ')'\r\n    },\r\n    COORDINATE_REGEX: /[a-n](?:(?:1[0-4])|(?:[1-9]))/,\r\n    COMMENT_SYNTAXES: {\r\n        CLOCK: /\\[%timestamp (-?\\d+?)]/,\r\n        ARROWS: /\\[%cal ((?:R|B|Y|G).+?)]/,\r\n        SQUARES: /\\[%csl ((?:R|B|Y|G).+?)]/,\r\n        ANNOTATION: /\\[%ann (.+?)]/\r\n    }\r\n};\r\nfunction obtainDuckMove(move) {\r\n    const match = move.match(PGN4_SYNTAX.DUCK_MOVE_CAPTURING_REGEX);\r\n    if (match) {\r\n        if (match[1]) {\r\n            const startCoordinates = parseSingleCoordinate(match[1]);\r\n            const endCoordinates = parseSingleCoordinate(match[2]);\r\n            if (!startCoordinates || !endCoordinates)\r\n                return;\r\n            return { startCoordinates, endCoordinates };\r\n        }\r\n        else {\r\n            const endCoordinates = parseSingleCoordinate(match[2]);\r\n            if (!endCoordinates)\r\n                return;\r\n            return { piece: duckPieceString, endCoordinates };\r\n        }\r\n    }\r\n    else\r\n        return;\r\n}\r\nfunction obtainInternalType(type) {\r\n    let internalMove;\r\n    for (internalMove in InternalMoveSignature) {\r\n        if (Object.prototype.hasOwnProperty.call(InternalMoveSignature, internalMove)) {\r\n            if (InternalMoveSignature[internalMove] === type)\r\n                return { type: InternalMoveSignature[internalMove] };\r\n        }\r\n    }\r\n}\r\nfunction obtainDroppingMove(move) {\r\n    const match = move.match(PGN4_SYNTAX.DROPPING_MOVE_CAPTURING_REGEX);\r\n    if (match) {\r\n        const [, color, piece, coordinate] = match;\r\n        if (!verifyColorEnumValue(color) || !verifyPieceLetter(piece))\r\n            return;\r\n        const endCoordinates = parseSingleCoordinate(coordinate);\r\n        if (!endCoordinates)\r\n            return;\r\n        return {\r\n            piece: createPieceFromData(colorEnum[color], piece),\r\n            endCoordinates\r\n        };\r\n    }\r\n    else\r\n        return;\r\n}\r\nfunction obtainStandardMove(move) {\r\n    const moveData = { startCoordinates: [-1, -1], endCoordinates: [-1, -1] };\r\n    const promotionMatch = move.match(/.*?=([A-Zx])/);\r\n    if (promotionMatch?.[1]) {\r\n        moveData.promotion = [createPieceFromData(deadColorIndex, promotionMatch[1].charAt(0))];\r\n    }\r\n    const moveCoordinates = move.match(PGN4_SYNTAX.MOVE_CAPTURING_REGEX);\r\n    if (moveCoordinates) {\r\n        const startCoordinate = parseSingleCoordinate(moveCoordinates[1]);\r\n        const endCoordinate = parseSingleCoordinate(moveCoordinates[2]);\r\n        assertNonUndefined(startCoordinate);\r\n        assertNonUndefined(endCoordinate);\r\n        moveData.startCoordinates = startCoordinate;\r\n        moveData.endCoordinates = endCoordinate;\r\n        return moveData;\r\n    }\r\n    else {\r\n        if (/O-O-O.*/.test(move)) {\r\n            return { ...moveData, specialType: SpecialMove.CastlingQueenside };\r\n        }\r\n        else if (/O-O.*/.test(move)) {\r\n            return { ...moveData, specialType: SpecialMove.CastlingKingside };\r\n        }\r\n    }\r\n}\r\nfunction cloneMoveData(move) {\r\n    if (!verifyInternalMove(move)) {\r\n        if (\"startCoordinates\" in move) {\r\n            const newMove = {\r\n                startCoordinates: [...move.startCoordinates],\r\n                endCoordinates: [...move.endCoordinates]\r\n            };\r\n            if (\"specialType\" in move) {\r\n                newMove.specialType = move.specialType;\r\n            }\r\n            if (\"promotion\" in move) {\r\n                newMove.promotion = move.promotion;\r\n            }\r\n            return newMove;\r\n        }\r\n        else {\r\n            return {\r\n                endCoordinates: move.endCoordinates,\r\n                piece: move.piece\r\n            };\r\n        }\r\n    }\r\n    else {\r\n        return { type: move.type };\r\n    }\r\n}\r\nexport const parsePGN4Moves = (moves) => {\r\n    const parseMoves = (selectedMove, path) => {\r\n        const moveList = [];\r\n        const currentPath = path;\r\n        function getMoveIndexes(mI) {\r\n            while (selectedMove[mI] && PGN4_SYNTAX.PIECE_REGEX.test(selectedMove[mI]))\r\n                mI++;\r\n            return mI;\r\n        }\r\n        function parseComment(mI) {\r\n            while (selectedMove[mI] && selectedMove[mI] !== PGN4_SYNTAX.BRACKETS.COMMENT_END)\r\n                mI++;\r\n            return mI;\r\n        }\r\n        function getEnumeratorIndex(mI) {\r\n            while (selectedMove[mI] && /\\d|\\./.test(selectedMove[mI]))\r\n                mI++;\r\n            return --mI;\r\n        }\r\n        function findBracketIndex(i) {\r\n            let depth = 0;\r\n            for (; i < selectedMove.length; i++) {\r\n                switch (selectedMove[i]) {\r\n                    case PGN4_SYNTAX.BRACKETS.COMMENT_START:\r\n                        i = parseComment(i);\r\n                        break;\r\n                    case PGN4_SYNTAX.BRACKETS.VARIATION_START:\r\n                        depth++;\r\n                        break;\r\n                    case PGN4_SYNTAX.BRACKETS.VARIATION_END:\r\n                        if (--depth === 0) {\r\n                            return i;\r\n                        }\r\n                        break;\r\n                }\r\n            }\r\n            throw new TypeError(\"No matching parentheses for input \" + selectedMove);\r\n        }\r\n        function processMoveDataInsertion() {\r\n            if (currentMoveData) {\r\n                currentPath.push(++increment);\r\n                currentMove.path = currentPath.slice();\r\n                currentPath.pop();\r\n                currentMove.moveData = currentMoveData.map(m => cloneMoveData(m));\r\n                currentMove.metadata = createDummyMoveMetadata();\r\n                const clockSyntax = currentMove.comment?.match(PGN4_SYNTAX.COMMENT_SYNTAXES.CLOCK);\r\n                if (clockSyntax && !isNaN(Number(clockSyntax[1]))) {\r\n                    currentMove.comment = currentMove.comment?.replace(PGN4_SYNTAX.COMMENT_SYNTAXES.CLOCK, \"\");\r\n                    currentMove.metadata.playerClock = Number(clockSyntax[1]);\r\n                }\r\n                const arrowSyntax = currentMove.comment?.match(PGN4_SYNTAX.COMMENT_SYNTAXES.ARROWS);\r\n                if (arrowSyntax) {\r\n                    const arrows = arrowSyntax[1].split(\",\");\r\n                    for (const arrow of arrows) {\r\n                        const [color, coordinate] = [arrow[0], arrow.slice(1)];\r\n                        const numericColor = color.toLowerCase(), arrowCoordinates = parseEnPassantCoordinates(coordinate);\r\n                        if (!verifyColorEnumValue(numericColor) || !arrowCoordinates)\r\n                            continue;\r\n                        currentMove.metadata.highlightedArrows.push([colorEnum[numericColor], ...arrowCoordinates]);\r\n                    }\r\n                    currentMove.comment = currentMove.comment?.replace(PGN4_SYNTAX.COMMENT_SYNTAXES.ARROWS, \"\");\r\n                }\r\n                const squareSyntax = currentMove.comment?.match(PGN4_SYNTAX.COMMENT_SYNTAXES.SQUARES);\r\n                if (squareSyntax) {\r\n                    const squares = squareSyntax[1].split(\",\");\r\n                    for (const square of squares) {\r\n                        const [color, inputCoordinate] = [square[0], square.slice(1)];\r\n                        const numericColor = color.toLowerCase(), coordinate = parseSingleCoordinate(inputCoordinate);\r\n                        if (!verifyColorEnumValue(numericColor) || !coordinate)\r\n                            continue;\r\n                        currentMove.metadata.highlightedSquares.push([colorEnum[numericColor], coordinate]);\r\n                    }\r\n                    currentMove.comment = currentMove.comment?.replace(PGN4_SYNTAX.COMMENT_SYNTAXES.SQUARES, \"\");\r\n                }\r\n                const annotationMatch = currentMove.comment?.match(PGN4_SYNTAX.COMMENT_SYNTAXES.ANNOTATION);\r\n                if (annotationMatch) {\r\n                    currentMove.metadata.annotation = annotationMatch[1];\r\n                    currentMove.comment = currentMove.comment?.replace(PGN4_SYNTAX.COMMENT_SYNTAXES.ANNOTATION, \"\");\r\n                }\r\n                if (verifyMoveWrapperProperties(currentMove)) {\r\n                    moveList.push(Object.assign({}, currentMove));\r\n                }\r\n                else {\r\n                    console.error(`Not all properties of move wrapper are filled out: ${JSON.stringify(currentMove)}`);\r\n                }\r\n                currentMove = {\r\n                    alternativeLines: [],\r\n                    comment: \"\"\r\n                };\r\n                currentMoveData = undefined;\r\n            }\r\n        }\r\n        function obtainMoveFromInfo(info) {\r\n            const currentMove = [];\r\n            const internalType = obtainInternalType(info[0]);\r\n            if (info.length === 1 && internalType !== undefined) {\r\n                return [internalType];\r\n            }\r\n            const standardMove = obtainStandardMove(info);\r\n            if (standardMove)\r\n                currentMove.push(standardMove);\r\n            const droppingMove = obtainDroppingMove(info);\r\n            if (droppingMove)\r\n                currentMove.push(droppingMove);\r\n            const duckMove = obtainDuckMove(info);\r\n            if (duckMove)\r\n                currentMove.push(duckMove);\r\n            if (verifyRequiredMove(currentMove)) {\r\n                return currentMove;\r\n            }\r\n            else\r\n                throw new Error(`Move length is 0 for string ${info}`);\r\n        }\r\n        let currentMoveData;\r\n        let currentMove = {\r\n            alternativeLines: [],\r\n            comment: \"\"\r\n        };\r\n        let increment = -1, variationIncrement = -1;\r\n        try {\r\n            for (let i = 0; i < selectedMove.length; i++) {\r\n                const isNumNaN = isNaN(Number(selectedMove[i]));\r\n                if (isNumNaN && !/\\s/.test(selectedMove[i]) && selectedMove[i] !== PGN4_SYNTAX.SPLIT) {\r\n                    if (PGN4_SYNTAX.PIECE_REGEX_SIMPLIFIED.test(selectedMove[i])) {\r\n                        const index = getMoveIndexes(i);\r\n                        currentMoveData = obtainMoveFromInfo(selectedMove.substring(i, index));\r\n                        i = index;\r\n                    }\r\n                    else if (moves[i] === PGN4_SYNTAX.BRACKETS.COMMENT_START) {\r\n                        const index = parseComment(i);\r\n                        currentMove.comment = moves.substring(i + 1, index);\r\n                        i = index;\r\n                    }\r\n                    else if (moves[i] === PGN4_SYNTAX.BRACKETS.VARIATION_START) {\r\n                        const index = findBracketIndex(i);\r\n                        currentPath.push(increment + 1, ++variationIncrement);\r\n                        currentMove.alternativeLines?.push([...parseMoves(moves.substring(i + 1, index), currentPath.slice())]);\r\n                        i = index;\r\n                    }\r\n                }\r\n                else if ((selectedMove[i] === PGN4_SYNTAX.SPLIT && moves[i + 1] && moves[i + 1] === PGN4_SYNTAX.SPLIT)\r\n                    || (moves[i].trim() && !isNumNaN) && moves[i + 1] && (moves[i + 1] === PGN4_SYNTAX.SPLIT || !isNaN(Number(moves[i + 1])))) {\r\n                    if (!isNumNaN)\r\n                        i = getEnumeratorIndex(i);\r\n                    if (currentMoveData) {\r\n                        processMoveDataInsertion();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        catch (e) {\r\n            console.trace(e);\r\n        }\r\n        finally {\r\n            processMoveDataInsertion();\r\n            currentPath.push(increment + 1);\r\n            currentMove.path = currentPath.slice();\r\n            if (verifyMoveWrapperProperties(currentMove)) {\r\n                moveList.push(Object.assign({}, currentMove));\r\n            }\r\n        }\r\n        return moveList;\r\n    };\r\n    return parseMoves(moves, []);\r\n};\r\n","export function serializePGNMoves(moveTree) {\r\n    let resultingString = \"\";\r\n    const traverse = (moves) => {\r\n        for (const moveWrapper of moves) {\r\n            if (moveWrapper.metadata.currentFullMove) {\r\n                resultingString = resultingString.replace(/\\s\\.\\.\\s$/, \"\");\r\n                resultingString += ` ${moveWrapper.metadata.currentFullMove}. `;\r\n            }\r\n            resultingString += moveWrapper.cachedNames.fullMoveNotation;\r\n            if (moveWrapper.comment)\r\n                resultingString += ` {${moveWrapper.comment}}`;\r\n            resultingString += \" .. \";\r\n            for (const alternativeLine of moveWrapper.alternativeLines) {\r\n                resultingString += \"(.. \";\r\n                traverse(alternativeLine);\r\n                resultingString += \" )\";\r\n            }\r\n        }\r\n        resultingString = resultingString.replace(/\\s\\.\\.\\s$/, \"\");\r\n    };\r\n    traverse(moveTree.moves);\r\n    return resultingString;\r\n}\r\n","import { createFENDataTag } from \"./TagLogic/FENDataTag\";\r\nimport { createSiteTag, createDateTag, createVariantTypeTag, createTimeControlTag, createTerminationTag, createGameNumberTag, createPlayerDataTag, createResultsTag } from \"./TagLogic/GameMetadataTags\";\r\nimport { createVariantRulesTag } from \"./TagLogic/VariantRulesTag\";\r\nexport const createDefaultVariantTags = () => ({\r\n    variantType: createVariantTypeTag(),\r\n    startingPosition: createFENDataTag(),\r\n    variantRules: createVariantRulesTag(),\r\n    date: createDateTag(), site: createSiteTag(),\r\n    timeControl: createTimeControlTag(),\r\n    termination: createTerminationTag(),\r\n    gameNumber: createGameNumberTag(),\r\n    playerData: createPlayerDataTag(),\r\n    results: createResultsTag()\r\n});\r\n","import { createTuple, verifyTupleType } from \"@client/ts/baseTypes\";\r\nimport { initializeBoardSquares } from \"@client/ts/logic/BaseInterfaces\";\r\nimport { FENData } from \"@moveGeneration/FENData/FENData\";\r\nimport { boardDimension, colors, totalPlayers } from \"@moveGeneration/GameInformation/GameData\";\r\nimport { verifyColorEnumValue, colorEnum, nonPlayablePieces, stringColorEnum } from \"@moveGeneration/GameInformation/GameUnits/GameUnits\";\r\nimport { createPieceFromString, emptyPieceString } from \"@moveGeneration/GameInformation/GameUnits/PieceString\";\r\nimport { tagNamesEqual, unwrapTag, wrapTag } from \"../Utils\";\r\nexport function checkDimensionIntersection(dimension, [i, j]) {\r\n    const dimensionI = (boardDimension - dimension[0]) / 2, dimensionJ = (boardDimension - dimension[1]) / 2;\r\n    return i < dimensionI || i >= (dimensionI + dimension[0])\r\n        || j < dimensionJ || j >= (dimensionJ + dimension[1]);\r\n}\r\nfunction serializeFENOptions(fenOptions) {\r\n    const resultingStrings = [];\r\n    let key;\r\n    for (key in fenOptions.tags) {\r\n        if (!Object.prototype.hasOwnProperty.call(fenOptions.tags, key))\r\n            continue;\r\n        const serializedForm = fenOptions.tags[key].serialize();\r\n        if (serializedForm)\r\n            resultingStrings.push(serializedForm);\r\n    }\r\n    return `{${resultingStrings.join(\",\")}}`;\r\n}\r\nfunction modifyFourBooleanParameter(part, fenDataArrayRef) {\r\n    const booleans = part.split(\",\").map(e => Boolean(Number(e)));\r\n    if (verifyTupleType(booleans, totalPlayers)) {\r\n        fenDataArrayRef.forEach((_, i, arr) => arr[i] = booleans[i]);\r\n    }\r\n    else {\r\n        console.error(\"Incorrect amount of arguments for the boolean parameter length in FENData: \" + part);\r\n        console.trace(`Expected ${totalPlayers} arguments, but got ${booleans.length}`);\r\n    }\r\n}\r\nconst predefinedFENpositions = {\r\n    \"4PC\": \"R-0,0,0,0-1,1,1,1-1,1,1,1-0,0,0,0-0-x,x,x,yR,yN,yB,yK,yQ,yB,yN,yR,x,x,x/x,x,x,yP,yP,yP,yP,yP,yP,yP,yP,x,x,x/x,x,x,8,x,x,x/bR,bP,10,gP,gR/bN,bP,10,gP,gN/bB,bP,10,gP,gB/bQ,bP,10,gP,gK/bK,bP,10,gP,gQ/bB,bP,10,gP,gB/bN,bP,10,gP,gN/bR,bP,10,gP,gR/x,x,x,8,x,x,x/x,x,x,rP,rP,rP,rP,rP,rP,rP,rP,x,x,x/x,x,x,rR,rN,rB,rQ,rK,rB,rN,rR,x,x,x\",\r\n    \"4PCo\": \"R-0,0,0,0-1,1,1,1-1,1,1,1-0,0,0,0-0-x,x,x,yR,yN,yB,yK,yQ,yB,yN,yR,x,x,x/x,x,x,yP,yP,yP,yP,yP,yP,yP,yP,x,x,x/x,x,x,8,x,x,x/bR,bP,10,gP,gR/bN,bP,10,gP,gN/bB,bP,10,gP,gB/bK,bP,10,gP,gQ/bQ,bP,10,gP,gK/bB,bP,10,gP,gB/bN,bP,10,gP,gN/bR,bP,10,gP,gR/x,x,x,8,x,x,x/x,x,x,rP,rP,rP,rP,rP,rP,rP,rP,x,x,x/x,x,x,rR,rN,rB,rQ,rK,rB,rN,rR,x,x,x\",\r\n    \"4PCb\": \"R-0,0,0,0-1,1,1,1-1,1,1,1-0,0,0,0-0-x,x,x,yR,yN,yB,yQ,yK,yB,yN,yR,x,x,x/x,x,x,yP,yP,yP,yP,yP,yP,yP,yP,x,x,x/x,x,x,8,x,x,x/bR,bP,10,gP,gR/bN,bP,10,gP,gN/bB,bP,10,gP,gB/bQ,bP,10,gP,gQ/bK,bP,10,gP,gK/bB,bP,10,gP,gB/bN,bP,10,gP,gN/bR,bP,10,gP,gR/x,x,x,8,x,x,x/x,x,x,rP,rP,rP,rP,rP,rP,rP,rP,x,x,x/x,x,x,rR,rN,rB,rQ,rK,rB,rN,rR,x,x,x\",\r\n    \"4PCn\": \"R-0,0,0,0-1,1,1,1-1,1,1,1-0,0,0,0-0-x,x,x,yR,yN,yB,yQ,yK,yB,yN,yR,x,x,x/x,x,x,yP,yP,yP,yP,yP,yP,yP,yP,x,x,x/x,x,x,8,x,x,x/bR,bP,10,gP,gR/bN,bP,10,gP,gN/bB,bP,10,gP,gB/bQ,bP,10,gP,gK/bK,bP,10,gP,gQ/bB,bP,10,gP,gB/bN,bP,10,gP,gN/bR,bP,10,gP,gR/x,x,x,8,x,x,x/x,x,x,rP,rP,rP,rP,rP,rP,rP,rP,x,x,x/x,x,x,rR,rN,rB,rQ,rK,rB,rN,rR,x,x,x\",\r\n    \"2PC\": \"R-0,1,0,1-1,1,1,1-1,1,1,1-0,0,0,0-0-{'pawnBaseRank':5,'wb':true,'dim':'8x8'}-x,x,x,x,x,x,x,x,x,x,x,x,x,x/x,x,x,x,x,x,x,x,x,x,x,x,x,x/x,x,x,x,x,x,x,x,x,x,x,x,x,x/x,x,x,yR,yN,yB,yQ,yK,yB,yN,yR,x,x,x/x,x,x,yP,yP,yP,yP,yP,yP,yP,yP,x,x,x/x,x,x,8,x,x,x/x,x,x,8,x,x,x/x,x,x,8,x,x,x/x,x,x,8,x,x,x/x,x,x,rP,rP,rP,rP,rP,rP,rP,rP,x,x,x/x,x,x,rR,rN,rB,rQ,rK,rB,rN,rR,x,x,x/x,x,x,x,x,x,x,x,x,x,x,x,x,x/x,x,x,x,x,x,x,x,x,x,x,x,x,x/x,x,x,x,x,x,x,x,x,x,x,x,x,x\"\r\n};\r\nconst verifyPredefinedFENPosition = (fenShorthand) => fenShorthand in predefinedFENpositions;\r\nconst fenDataTag = \"StartFen4\";\r\nexport const createFENDataTag = () => ({\r\n    tag: \"startingPosition\",\r\n    currentValue: {\r\n        board: initializeBoardSquares(() => emptyPieceString),\r\n        fenData: new FENData(),\r\n        pieceSet: new Set()\r\n    },\r\n    verifyTagInParsing(inputTag) {\r\n        return tagNamesEqual(inputTag, fenDataTag);\r\n    },\r\n    parseTag(inputTag) {\r\n        const tagContents = unwrapTag(inputTag, fenDataTag);\r\n        const fenDataString = verifyPredefinedFENPosition(tagContents) ? predefinedFENpositions[tagContents] : tagContents;\r\n        const fenData = new FENData();\r\n        const board = initializeBoardSquares(() => emptyPieceString);\r\n        const pieceSet = new Set();\r\n        const transparentWall = createPieceFromString(\"x\");\r\n        const parts = fenDataString.split(\"-\");\r\n        if (parts.length < 7 || parts[parts.length - 1].split(\"/\").length !== boardDimension) {\r\n            console.warn(\"FEN has less than 7 parts: \" + fenDataString);\r\n        }\r\n        else {\r\n            const sideToMove = parts[0].charAt(0).toLowerCase();\r\n            if (verifyColorEnumValue(sideToMove)) {\r\n                fenData.sideToMove = colorEnum[sideToMove];\r\n            }\r\n            else {\r\n                console.warn(\"FEN option 1: side to move is not an alphabetic color: \" + sideToMove);\r\n            }\r\n            modifyFourBooleanParameter(parts[1], fenData.fenOptions.tag(\"dead\"));\r\n            modifyFourBooleanParameter(parts[2], fenData.fenOptions.tag(\"castleKingside\"));\r\n            modifyFourBooleanParameter(parts[3], fenData.fenOptions.tag(\"castleQueenside\"));\r\n            const points = parts[4].split(\",\").map(e => Number(e));\r\n            if (verifyTupleType(points, totalPlayers)) {\r\n                fenData.points = points;\r\n            }\r\n            else {\r\n                console.warn(`FEN option 5: points is of incorrect length: ${points.join(\",\")}`);\r\n            }\r\n            fenData.plyCount = Number(parts[5]);\r\n            const royals = createTuple(null, totalPlayers);\r\n            const verifyKeyInTags = (key) => key in fenData.fenOptions.tags;\r\n            if (parts[6].startsWith(\"{\")) {\r\n                const initialParsing = JSON.parse(parts[6].replaceAll(\"(\", '[').replaceAll(\")\", \"]\").replaceAll(\"'\", '\"'));\r\n                if (typeof initialParsing !== 'object' || initialParsing === null)\r\n                    throw new Error(\"Unexpected object definition syntax for \" + String(initialParsing));\r\n                for (const [key, value] of Object.entries(initialParsing)) {\r\n                    if (!verifyKeyInTags(key))\r\n                        continue;\r\n                    const tag = fenData.fenOptions.tags[key];\r\n                    tag.value = tag.parse(value);\r\n                }\r\n            }\r\n            const position = parts[parts.length - 1].split(\"/\"), dimension = fenData.fenOptions.tag(\"dim\");\r\n            position.forEach((line, i) => {\r\n                let j = 0;\r\n                for (let pieceStr of line.split(\",\")) {\r\n                    if (pieceStr.endsWith('\"'))\r\n                        pieceStr = pieceStr.slice(0, -1);\r\n                    if (isNaN(Number(pieceStr))) {\r\n                        try {\r\n                            if (!checkDimensionIntersection(dimension, [i, j])) {\r\n                                const pieceString = createPieceFromString(pieceStr);\r\n                                board[i][j] = pieceString;\r\n                                if (pieceString.isPiece()) {\r\n                                    if (pieceString.piece === \"K\" && !royals[pieceString.color]) {\r\n                                        royals[pieceString.color] = [i, j];\r\n                                    }\r\n                                    pieceSet.add(pieceString.piece);\r\n                                }\r\n                            }\r\n                        }\r\n                        finally {\r\n                            j++;\r\n                        }\r\n                    }\r\n                    else\r\n                        j += Number(pieceStr);\r\n                }\r\n            });\r\n            for (const color of colors) {\r\n                for (const [piece] of fenData.fenOptions.tag(\"bank\")[color]) {\r\n                    if (piece.piece in nonPlayablePieces)\r\n                        continue;\r\n                    pieceSet.add(piece.piece);\r\n                }\r\n            }\r\n            fenData.fenOptions.setTag(\"royal\", royals);\r\n            for (let i = 0; i < boardDimension; i++) {\r\n                for (let j = 0; j < boardDimension; j++) {\r\n                    if (checkDimensionIntersection(dimension, [i, j]))\r\n                        board[i][j] = transparentWall;\r\n                }\r\n            }\r\n        }\r\n        if (!fenData.fenOptions.tag(\"noCorners\")) {\r\n            const cornerAreaSize = 3, arrayDimension = boardDimension - 1;\r\n            baseLoop: for (let i = 0; i < cornerAreaSize; i++) {\r\n                for (let j = 0; j < cornerAreaSize; j++) {\r\n                    const squares = [\r\n                        [i, j], [arrayDimension - i, j],\r\n                        [i, arrayDimension - j], [arrayDimension - i, arrayDimension - j]\r\n                    ];\r\n                    for (const square of squares) {\r\n                        const pieceString = board[square[0]][square[1]];\r\n                        if (!pieceString.isWall() || pieceString.piece !== transparentWall.piece) {\r\n                            fenData.fenOptions.setTag(\"noCorners\", true);\r\n                            break baseLoop;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return { fenData, board, pieceSet };\r\n    },\r\n    serialize(baseBoard) {\r\n        const { board, data } = baseBoard;\r\n        let resultingString = \"\";\r\n        resultingString += `${stringColorEnum[data.sideToMove].toUpperCase()}-`;\r\n        resultingString += `${data.fenOptions.tag(\"dead\").map(d => Number(d)).join(\",\")}-`;\r\n        resultingString += `${data.fenOptions.tag(\"castleKingside\").map(d => Number(d)).join(\",\")}-`;\r\n        resultingString += `${data.fenOptions.tag(\"castleQueenside\").map(d => Number(d)).join(\",\")}-`;\r\n        resultingString += `${data.points.join(\",\")}-`;\r\n        resultingString += `${data.plyCount}-`;\r\n        resultingString += `${serializeFENOptions(data.fenOptions)}-`;\r\n        let currentEmptySquares = 0;\r\n        for (const row of board) {\r\n            for (const pieceString of row) {\r\n                if (pieceString.isEmpty()) {\r\n                    currentEmptySquares++;\r\n                    continue;\r\n                }\r\n                if (currentEmptySquares !== 0) {\r\n                    resultingString += `${currentEmptySquares},`;\r\n                    currentEmptySquares = 0;\r\n                }\r\n                resultingString += `${pieceString.value},`;\r\n            }\r\n            if (currentEmptySquares !== 0) {\r\n                resultingString += `${currentEmptySquares}/`;\r\n                currentEmptySquares = 0;\r\n            }\r\n            else {\r\n                resultingString = resultingString.slice(0, -1);\r\n                resultingString += \"/\";\r\n            }\r\n        }\r\n        resultingString = resultingString.slice(0, -1);\r\n        return wrapTag(fenDataTag, resultingString);\r\n    }\r\n});\r\n","import { createTupleFromCallback } from \"@client/ts/baseTypes\";\r\nimport { colors, getPlayerNameFromColor, playerNames, totalPlayers, validateTerminationString, VariantType } from \"@moveGeneration/GameInformation/GameData\";\r\nimport { truncateNumber } from \"@utils/NumberUtils\";\r\nimport { tagNamesEqual, unwrapTag, wrapTag } from \"../Utils\";\r\nconst variantTypeTag = \"Variant\";\r\nexport const createVariantTypeTag = () => ({\r\n    tag: \"variantType\",\r\n    currentValue: VariantType.FFA,\r\n    verifyTagInParsing(inputTag) {\r\n        return tagNamesEqual(inputTag, variantTypeTag);\r\n    },\r\n    parseTag(inputTag) {\r\n        const tagContents = unwrapTag(inputTag, variantTypeTag);\r\n        for (const type of Object.values(VariantType)) {\r\n            if (tagContents === type)\r\n                return type;\r\n        }\r\n        return VariantType.FFA;\r\n    },\r\n    serialize(board) {\r\n        return wrapTag(variantTypeTag, board.gameType.type);\r\n    }\r\n});\r\nconst variantDateTag = \"Date\";\r\nexport const createDateTag = () => ({\r\n    tag: \"date\",\r\n    currentValue: new Date(),\r\n    verifyTagInParsing(inputTag) {\r\n        return tagNamesEqual(inputTag, variantDateTag);\r\n    },\r\n    parseTag(tagContents) {\r\n        return new Date(unwrapTag(tagContents, variantDateTag));\r\n    },\r\n    serialize(board) {\r\n        if (!board.gameData.date)\r\n            return;\r\n        if (typeof board.gameData.date === \"object\") {\r\n            return wrapTag(variantDateTag, board.gameData.date.toUTCString());\r\n        }\r\n        else {\r\n            return wrapTag(variantDateTag, board.gameData.date);\r\n        }\r\n    }\r\n});\r\nconst variantSiteTag = \"Site\";\r\nexport const createSiteTag = () => ({\r\n    tag: \"site\",\r\n    currentValue: \"\",\r\n    verifyTagInParsing(inputTag) {\r\n        return tagNamesEqual(inputTag, variantSiteTag);\r\n    },\r\n    parseTag(tagContents) {\r\n        return unwrapTag(tagContents, variantSiteTag);\r\n    },\r\n    serialize(board) {\r\n        if (!board.gameData.site)\r\n            return;\r\n        return wrapTag(variantSiteTag, board.gameData.site);\r\n    }\r\n});\r\nconst variantTimeControlTag = \"TimeControl\", getDefaultTimeControl = () => ({ baseTime: 180, increment: 2, isDelay: false });\r\nexport const createTimeControlTag = () => ({\r\n    tag: \"timeControl\",\r\n    currentValue: getDefaultTimeControl(),\r\n    verifyTagInParsing(inputTag) {\r\n        return tagNamesEqual(inputTag, variantTimeControlTag);\r\n    },\r\n    parseTag(inputTag) {\r\n        const defaultTC = getDefaultTimeControl();\r\n        const matchArray = unwrapTag(inputTag, variantTimeControlTag)\r\n            .match(/^((?:0\\.\\d\\d?)?|(?:\\d\\d?s?))(?:(?:(?:\\+|\\|)(\\d\\d?)(D?))|(\\smin))$/)?.slice(1);\r\n        if (matchArray) {\r\n            const [minutesMatch, secondsMatch, delay] = matchArray;\r\n            if (!secondsMatch)\r\n                return defaultTC;\r\n            defaultTC.isDelay = delay ? true : false;\r\n            if (/\\smin/.test(secondsMatch)) {\r\n                defaultTC.increment = 0;\r\n            }\r\n            else {\r\n                defaultTC.increment = Number(secondsMatch);\r\n            }\r\n            if (minutesMatch.endsWith(\"s\")) {\r\n                defaultTC.baseTime = Math.round(Number(minutesMatch.slice(0, -1)));\r\n            }\r\n            else {\r\n                defaultTC.baseTime = Number(minutesMatch) * 60;\r\n            }\r\n        }\r\n        return defaultTC;\r\n    },\r\n    serialize(board) {\r\n        const timeControl = board.gameData.timeControl;\r\n        const noIncrement = timeControl.increment === 0;\r\n        let timeControlString = \"\";\r\n        if (timeControl.baseTime < 60) {\r\n            timeControlString += noIncrement ? `${timeControl.baseTime * 60} sec` : `${timeControl.baseTime * 60}s`;\r\n        }\r\n        else if (timeControl.baseTime > 60 && noIncrement) {\r\n            timeControlString += `${truncateNumber(timeControl.baseTime / 60, 1)} min`;\r\n        }\r\n        else {\r\n            timeControlString += truncateNumber(timeControl.baseTime / 60, 1);\r\n        }\r\n        if (!noIncrement) {\r\n            timeControlString += \"|\";\r\n            timeControlString += timeControl.increment;\r\n        }\r\n        if (timeControl.isDelay) {\r\n            timeControlString += \"D\";\r\n        }\r\n        return wrapTag(variantTimeControlTag, timeControlString);\r\n    }\r\n});\r\nconst variantTerminationTag = \"Termination\";\r\nexport const createTerminationTag = () => ({\r\n    tag: \"termination\",\r\n    currentValue: undefined,\r\n    verifyTagInParsing(inputTag) {\r\n        return tagNamesEqual(inputTag, variantTerminationTag);\r\n    },\r\n    parseTag(inputTag) {\r\n        const tagContents = unwrapTag(inputTag, variantTerminationTag);\r\n        return validateTerminationString(tagContents) ? tagContents : undefined;\r\n    },\r\n    serialize(board) {\r\n        if (!board.gameData.termination)\r\n            return;\r\n        return wrapTag(variantTerminationTag, board.gameData.termination);\r\n    }\r\n});\r\nconst variantGameId = \"GameNr\";\r\nexport const createGameNumberTag = () => ({\r\n    tag: \"gameNumber\",\r\n    currentValue: undefined,\r\n    verifyTagInParsing(inputTag) {\r\n        return tagNamesEqual(inputTag, variantGameId);\r\n    },\r\n    parseTag(inputTag) {\r\n        const id = Number(unwrapTag(inputTag, variantGameId));\r\n        return isNaN(id) ? undefined : id;\r\n    },\r\n    serialize(board) {\r\n        if (!board.gameData.gameNumber)\r\n            return;\r\n        return wrapTag(variantGameId, board.gameData.gameNumber.toString());\r\n    }\r\n});\r\nexport const createPlayerDataTag = () => ({\r\n    tag: \"playerData\",\r\n    currentValue: createTupleFromCallback(() => ({}), totalPlayers),\r\n    verifyTagInParsing(inputTag) {\r\n        for (const color of colors) {\r\n            const playerName = getPlayerNameFromColor(color);\r\n            if (tagNamesEqual(inputTag, playerName) || tagNamesEqual(inputTag, `${playerName}Elo`))\r\n                return true;\r\n        }\r\n        return false;\r\n    },\r\n    parseTag(inputTag) {\r\n        for (const color of colors) {\r\n            const playerName = getPlayerNameFromColor(color);\r\n            const newCurrentValue = [...this.currentValue];\r\n            if (tagNamesEqual(inputTag, playerName)) {\r\n                const name = unwrapTag(inputTag, playerName);\r\n                if (name)\r\n                    newCurrentValue[color] = { ...newCurrentValue[color], name };\r\n                return newCurrentValue;\r\n            }\r\n            else if (tagNamesEqual(inputTag, `${playerName}Elo`)) {\r\n                const elo = Number(unwrapTag(inputTag, playerName));\r\n                if (!isNaN(elo))\r\n                    newCurrentValue[color] = { ...newCurrentValue[color], elo };\r\n                return newCurrentValue;\r\n            }\r\n        }\r\n        throw new Error(\"Tag does not match any player data signature\");\r\n    },\r\n    serialize(board) {\r\n        const uniqueResultingTags = [];\r\n        for (const color of colors) {\r\n            const playerData = board.gameData.players[color];\r\n            if (playerData.elo) {\r\n                uniqueResultingTags.push(wrapTag(`${playerNames[color]}Elo`, String(playerData.elo)));\r\n            }\r\n            if (playerData.name) {\r\n                uniqueResultingTags.push(wrapTag(`${playerNames[color]}`, String(playerData.name)));\r\n            }\r\n        }\r\n        return uniqueResultingTags.join(\"\\n\");\r\n    }\r\n});\r\nconst resultsTag = \"Results\";\r\nexport const createResultsTag = () => ({\r\n    tag: \"results\",\r\n    currentValue: \"\",\r\n    verifyTagInParsing(inputTag) {\r\n        return tagNamesEqual(inputTag, resultsTag);\r\n    },\r\n    parseTag(tagContents) {\r\n        return unwrapTag(tagContents, resultsTag);\r\n    },\r\n    serialize(board) {\r\n        if (!board.gameData.result)\r\n            return;\r\n        return wrapTag(resultsTag, board.gameData.result);\r\n    }\r\n});\r\n","import { createBaseParsingTypes, parseVariantRules } from \"@moveGeneration/VariantRules/VariantRuleSetup\";\r\nimport { tagNamesEqual, unwrapTag, wrapTag } from \"../Utils\";\r\nconst variantRulesTag = \"RuleVariants\";\r\nexport const createVariantRulesTag = () => ({\r\n    tag: \"variantRules\",\r\n    currentValue: createBaseParsingTypes(),\r\n    verifyTagInParsing(inputTag) {\r\n        return tagNamesEqual(inputTag, variantRulesTag);\r\n    },\r\n    parseTag(tagContents) {\r\n        return parseVariantRules(unwrapTag(tagContents, variantRulesTag));\r\n    },\r\n    serialize(board) {\r\n        const resultingRuleList = [], variantRules = board.variantRules;\r\n        const mergedRuleList = [\r\n            ...variantRules.boardDecorators,\r\n            ...variantRules.fenDataDecorators,\r\n            ...variantRules.pieceControlDecorators\r\n        ];\r\n        for (const rule of mergedRuleList) {\r\n            const serializedForm = rule.serializeToParsingForm();\r\n            if (serializedForm) {\r\n                resultingRuleList.push(serializedForm);\r\n            }\r\n        }\r\n        return wrapTag(variantRulesTag, resultingRuleList.join(\" \"));\r\n    }\r\n});\r\n","export function parseSingleCoordinate(coordinate) {\r\n    if (coordinate.length === 0)\r\n        return;\r\n    const parsedCoordinate = [14 - Number(coordinate.slice(1)), coordinate.charCodeAt(0) - 97];\r\n    if (Number.isNaN(parsedCoordinate[0]) || Number.isNaN(parsedCoordinate[1]))\r\n        return;\r\n    if (parsedCoordinate[0] < 0 || parsedCoordinate[0] > 13 || parsedCoordinate[1] < 0 || parsedCoordinate[1] > 13)\r\n        return;\r\n    return parsedCoordinate;\r\n}\r\nexport function parseEnPassantCoordinates(coordinates) {\r\n    if (coordinates.length === 0)\r\n        return;\r\n    const coordinatesArray = coordinates.split(\":\");\r\n    return [[14 - Number(coordinatesArray[0].slice(1)), coordinatesArray[0].charCodeAt(0) - 97],\r\n        [14 - Number(coordinatesArray[1].slice(1)), coordinatesArray[1].charCodeAt(0) - 97]];\r\n}\r\nexport const wrapTag = (baseTag, content) => `[${baseTag} \"${content}\"]`;\r\nexport const tagNamesEqual = (baseTag, definedTag) => baseTag.toLowerCase().startsWith(`[${definedTag.toLowerCase()} \"`);\r\nexport const unwrapTag = (baseTag, definedTag) => baseTag.replace(`[${definedTag} \"`, \"\").slice(0, -1);\r\n","export function shuffleArray(array) {\r\n    let i = array.length;\r\n    let r = 0;\r\n    while (i !== 0) {\r\n        r = Math.floor(Math.random() * i--);\r\n        [array[i], array[r]] = [array[r], array[i]];\r\n    }\r\n    return array;\r\n}\r\nexport function compareArrays(arr1, arr2) {\r\n    if (arr1 === arr2)\r\n        return true;\r\n    if (arr1.length !== arr2.length)\r\n        return false;\r\n    for (let i = 0; i < arr1.length; i++) {\r\n        const first = arr1[i], second = arr2[i];\r\n        if (Array.isArray(first) && Array.isArray(second)) {\r\n            if (!compareArrays(first, second))\r\n                return false;\r\n        }\r\n        else if (first !== second) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nexport function countMinimumOf2DArrayExcludingZero(array) {\r\n    let minimum = Infinity;\r\n    for (const row of array) {\r\n        for (const number of row) {\r\n            if (number !== 0 && number < minimum) {\r\n                minimum = number;\r\n            }\r\n        }\r\n    }\r\n    return minimum;\r\n}\r\nexport function findLastIndex(array, callback) {\r\n    let i = array.length;\r\n    while (i--) {\r\n        if (callback(array[i], i, array))\r\n            return i;\r\n    }\r\n    return -1;\r\n}\r\n","export function truncateNumber(number, digits) {\r\n    const multiplier = Math.pow(10, digits);\r\n    const adjusted = number * multiplier;\r\n    if (adjusted < 0) {\r\n        return Math.ceil(adjusted / multiplier);\r\n    }\r\n    else {\r\n        return Math.floor(adjusted / multiplier);\r\n    }\r\n}\r\nexport function bitCount(number) {\r\n    number = number - ((number >> 1) & 0x55555555);\r\n    number = (number & 0x33333333) + ((number >> 2) & 0x33333333);\r\n    return ((number + (number >> 4) & 0xF0F0F0F) * 0x1010101) >> 24;\r\n}\r\n","export function copyClass(instance, baseClass, customProperties = false) {\r\n    const prototype = Object.getPrototypeOf(instance);\r\n    if (typeof prototype !== 'object')\r\n        throw new Error(\"Expected prototype to be an object\");\r\n    const properties = Object.create(prototype);\r\n    if (typeof properties !== 'object' || properties === null)\r\n        throw new Error(\"Expected prototype to be an object\");\r\n    const copy = Object.assign(properties, customProperties ? {} : instance);\r\n    if (!(copy instanceof baseClass))\r\n        throw new Error(\"Expected prototype to not be overridden\");\r\n    return copy;\r\n}\r\nexport const verifyObjectType = (v) => typeof v === \"object\" && v !== null;\r\nexport function verifyPropertiesInObject(obj, keys) {\r\n    for (const key of keys) {\r\n        if (!Object.prototype.hasOwnProperty.call(obj, key))\r\n            return false;\r\n    }\r\n    return true;\r\n}\r\n","export function formatOrdinalNumber(num) {\r\n    const lastTwoDigits = Number(String(num).slice(-2));\r\n    if (lastTwoDigits > 3 && lastTwoDigits < 21)\r\n        return 'th';\r\n    switch (lastTwoDigits % 10) {\r\n        case 1: return \"st\";\r\n        case 2: return \"nd\";\r\n        case 3: return \"rd\";\r\n        default: return \"th\";\r\n    }\r\n}\r\nexport function compileEnumeration(list) {\r\n    if (list.length === 0)\r\n        return \"\";\r\n    if (list.length === 1)\r\n        return list[0];\r\n    let result = \"\";\r\n    for (let i = 0; i < list.length; i++) {\r\n        if (i === list.length - 2) {\r\n            result += ` ${list[i]} or `;\r\n        }\r\n        else if (i === list.length - 1) {\r\n            result += list[i];\r\n        }\r\n        else {\r\n            result += list[i] + \", \";\r\n        }\r\n    }\r\n    return result;\r\n}\r\nexport function prefixWithIndefiniteArticle(str) {\r\n    const vowels = /[AEUIO]/i;\r\n    return vowels.test(str.charAt(0)) ? \"an \" + str : \"a \" + str;\r\n}\r\nexport function convertSecondsToFlexibleHoursMinutesSeconds(seconds) {\r\n    if (seconds >= 3600) {\r\n        return new Date(seconds * 1000).toISOString().substring(11, 16);\r\n    }\r\n    else {\r\n        return new Date(seconds * 1000).toISOString().substring(14, 19);\r\n    }\r\n}\r\nexport function convertCamelCaseToKebabCase(baseString) {\r\n    return baseString.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\r\n}\r\nexport function hashString(string) {\r\n    let hash = 0;\r\n    for (let i = 0; i < string.length; i++) {\r\n        const char = string.charCodeAt(i);\r\n        hash = ((hash << 5) - hash) + char;\r\n        hash |= 0;\r\n    }\r\n    return hash;\r\n}\r\n","var map = {\n\t\"./BoardDecorators/AllowPassing.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/AllowPassing.ts\",\n\t\"./BoardDecorators/AlternativeTeams.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/AlternativeTeams.ts\",\n\t\"./BoardDecorators/BarePieceRule.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/BarePieceRule.ts\",\n\t\"./BoardDecorators/Blindfold.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/Blindfold.ts\",\n\t\"./BoardDecorators/CaptureTheKing.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/CaptureTheKing.ts\",\n\t\"./BoardDecorators/Chess960.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/Chess960.ts\",\n\t\"./BoardDecorators/Crazyhouse.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/Crazyhouse.ts\",\n\t\"./BoardDecorators/DuckChess.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/DuckChess.ts\",\n\t\"./BoardDecorators/FogOfWar.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/FogOfWar.ts\",\n\t\"./BoardDecorators/ForcedCapture.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/ForcedCapture.ts\",\n\t\"./BoardDecorators/GameMetadataRules.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/GameMetadataRules.ts\",\n\t\"./BoardDecorators/Ghostboard.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/Ghostboard.ts\",\n\t\"./BoardDecorators/ParadigmChess30.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/ParadigmChess30.ts\",\n\t\"./BoardDecorators/PiecesFaceCenter.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/PiecesFaceCenter.ts\",\n\t\"./BoardDecorators/SeirawanSetup.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/SeirawanSetup.ts\",\n\t\"./BoardDecorators/SelfCheck.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/SelfCheck.ts\",\n\t\"./BoardDecorators/SetupChess.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/SetupChess.ts\",\n\t\"./BoardDecorators/Taboo.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardDecorators/Taboo.ts\",\n\t\"./BoardVariantModules/EngineMoveGeneration/Algorithms/ComfuterEvaluation.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardVariantModules/EngineMoveGeneration/Algorithms/ComfuterEvaluation.ts\",\n\t\"./BoardVariantModules/EngineMoveGeneration/Algorithms/ComfuterEvaluationExtensions.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardVariantModules/EngineMoveGeneration/Algorithms/ComfuterEvaluationExtensions.ts\",\n\t\"./BoardVariantModules/EngineMoveGeneration/Algorithms/MixedAlgorithms.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardVariantModules/EngineMoveGeneration/Algorithms/MixedAlgorithms.ts\",\n\t\"./BoardVariantModules/EngineMoveGeneration/Algorithms/RandomEvaluation.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardVariantModules/EngineMoveGeneration/Algorithms/RandomEvaluation.ts\",\n\t\"./BoardVariantModules/EngineMoveGeneration/Algorithms/RandomEvaluationExtensions.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardVariantModules/EngineMoveGeneration/Algorithms/RandomEvaluationExtensions.ts\",\n\t\"./BoardVariantModules/EngineMoveGeneration/BotInterface.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardVariantModules/EngineMoveGeneration/BotInterface.ts\",\n\t\"./BoardVariantModules/InsufficientMaterial/InsufficientMaterialGeneration.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardVariantModules/InsufficientMaterial/InsufficientMaterialGeneration.ts\",\n\t\"./BoardVariantModules/InsufficientMaterial/PieceMedianCounter.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardVariantModules/InsufficientMaterial/PieceMedianCounter.ts\",\n\t\"./FENDataDecorators/Atomic.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/Atomic.ts\",\n\t\"./FENDataDecorators/DeadKingWalking.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/DeadKingWalking.ts\",\n\t\"./FENDataDecorators/EnPassant.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/EnPassant.ts\",\n\t\"./FENDataDecorators/FatalCapture.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/FatalCapture.ts\",\n\t\"./FENDataDecorators/FiftyMoveRule.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/FiftyMoveRule.ts\",\n\t\"./FENDataDecorators/Giveaway.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/Giveaway.ts\",\n\t\"./FENDataDecorators/KingOfTheHill.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/KingOfTheHill.ts\",\n\t\"./FENDataDecorators/NCheck.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/NCheck.ts\",\n\t\"./FENDataDecorators/OppositeMultiplier.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/OppositeMultiplier.ts\",\n\t\"./FENDataDecorators/OppositeSideCastling.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/OppositeSideCastling.ts\",\n\t\"./FENDataDecorators/PiecesGoToBanks.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/PiecesGoToBanks.ts\",\n\t\"./FENDataDecorators/PlayForMate.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/PlayForMate.ts\",\n\t\"./FENDataDecorators/PointsForMate.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/PointsForMate.ts\",\n\t\"./FENDataDecorators/StalemateOptions.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/StalemateOptions.ts\",\n\t\"./FENDataDecorators/Takeover.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/Takeover.ts\",\n\t\"./FENDataDecorators/ThreefoldRepetition.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/FENDataDecorators/ThreefoldRepetition.ts\",\n\t\"./PieceControlDecorators/AnyCapture.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/PieceControlDecorators/AnyCapture.ts\",\n\t\"./PieceControlDecorators/PromoteTo.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/PieceControlDecorators/PromoteTo.ts\",\n\t\"./PieceControlDecorators/PromotionRank.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/PieceControlDecorators/PromotionRank.ts\",\n\t\"./PieceControlDecorators/RoyalsCannotCapture.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/PieceControlDecorators/RoyalsCannotCapture.ts\",\n\t\"./PieceControlDecorators/Sideways.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/PieceControlDecorators/Sideways.ts\",\n\t\"./PieceControlDecorators/Stonewall.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/PieceControlDecorators/Stonewall.ts\",\n\t\"./PieceControlDecorators/Torpedo.ts\": \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/PieceControlDecorators/Torpedo.ts\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions sync recursive \\\\.ts$\";"],"names":[],"sourceRoot":""}