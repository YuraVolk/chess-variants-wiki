{"version":3,"file":"5.react-app.js","mappings":"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","sources":["webpack://spring-react-app/./src/main/client/ts/baseTypes.ts","webpack://spring-react-app/./src/main/client/ts/logic/BaseInterfaces.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/GameInformation/GameData.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/GameInformation/GameUnits/GameUnits.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/PieceControl/PieceControlInterface.ts","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardVariantModules/InsufficientMaterial/Utilities.ts","webpack://spring-react-app/./src/main/client/ts/utils/ArrayUtils.ts","webpack://spring-react-app/./src/main/client/ts/utils/NumberUtils.ts","webpack://spring-react-app/webpack/bootstrap","webpack://spring-react-app/webpack/runtime/define property getters","webpack://spring-react-app/webpack/runtime/hasOwnProperty shorthand","webpack://spring-react-app/./src/main/client/ts/logic/movegen/VariantRules/VariantRuleDefinitions/BoardVariantModules/InsufficientMaterial/PieceMedianCounter.ts"],"sourcesContent":["// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type FunctionType = (...args: any[]) => any;\nexport const verifyFunctionType = (func: unknown): func is FunctionType => typeof func === \"function\";\n\nexport type Length<T extends unknown[]> = T extends { length: infer L } ? L : never;\nexport type Tuple<T, N extends number> = N extends N ? (number extends N ? T[] : _TupleOf<T, N, []>) : never;\ntype _TupleOf<T, N extends number, R extends unknown[]> = R[\"length\"] extends N ? R : _TupleOf<T, N, [T, ...R]>;\n\nexport type Add<A extends number, B extends number> = Length<[...Tuple<unknown, A>, ...Tuple<unknown, B>]>;\nexport const createTuple = <T, L extends number>(val: T, length: L) => Array.from<L, T>({ length }).fill(val);\nexport const createTupleFromCallback = <T, L extends number>(val: (v: unknown, k: number) => T, length: L): Tuple<T, L> =>\n\tArray.from({ length }, val);\nexport const verifyTupleType = <T, L extends number>(arr: T[], length: L): arr is Tuple<T, L> => arr.length === length;\n\nexport type ImplementInterface<T, U> = Pick<T, Exclude<keyof T, keyof U>> & U;\n\nexport function assertNonUndefined<T>(data: T): asserts data is NonNullable<T> {\n\tif (data == null) throw new Error(\"Expected the data above to be anything but null or undefined\");\n}\nexport function assertDevOnly(condition: boolean): asserts condition {\n\tif (process.env.NODE_ENV === \"development\") {\n\t\tif (!condition) throw new Error(\"Dev only condition assertion is not satisfied, the condition resulted in false\");\n\t}\n}\n\nexport function throwOnNever(arg: never): never {\n\tconsole.dir(arg);\n\tthrow new TypeError(`Unexpected argument that is supposed to be of type never`);\n}\n\nexport function importAll(r: __WebpackModuleApi.RequireContext) {\n\tr.keys().forEach(r);\n}\n\nexport function getEnumKeys<T extends Record<PropertyKey, unknown>>(object: Record<keyof T, unknown>): Array<keyof T> {\n\tconst resultingArray: Array<keyof T> = [];\n\tlet key: keyof T;\n\tfor (key in object) resultingArray.push(key);\n\treturn resultingArray;\n}\n\ntype ArrayKeys<T extends unknown[] | readonly unknown[]> = Exclude<Partial<T>[\"length\"], T[\"length\"]> extends never | undefined\n\t? number\n\t: Exclude<Partial<T>[\"length\"], T[\"length\"]>;\n\ndeclare global {\n\tinterface Array<T> {\n\t\tindexOf(searchElement: T, fromIndex?: number): ArrayKeys<this> | -1;\n\t\tlastIndexOf(searchElement: T, fromIndex?: number): ArrayKeys<this> | -1;\n\t\tevery<S extends T>(predicate: (value: T, index: ArrayKeys<this>, array: T[]) => value is S): this is { [K in keyof this]: S };\n\t\tevery(predicate: (value: T, index: ArrayKeys<this>, array: T[]) => unknown, thisArg?: T[]): boolean;\n\t\tsome(predicate: (value: T, index: ArrayKeys<this>, array: T[]) => unknown, thisArg?: T[]): boolean;\n\t\tforEach(callbackfn: (value: T, index: ArrayKeys<this>, array: T[]) => void, thisArg?: T[]): void;\n\t\tmap<U>(callbackfn: (value: T, index: ArrayKeys<this>, array: T[]) => U): { [K in keyof this]: U };\n\t\tfilter<S extends T>(predicate: (value: T, index: ArrayKeys<this>, array: T[]) => value is S, thisArg?: T[]): S[];\n\t\tfilter(predicate: (value: T, index: ArrayKeys<this>, array: T[]) => unknown, thisArg?: T[]): T[];\n\t\treduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: ArrayKeys<this>, array: T[]) => T): T;\n\t\treduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: ArrayKeys<this>, array: T[]) => T, initialValue: T): T;\n\t\treduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: ArrayKeys<this>, array: T[]) => U, initialValue: U): U;\n\t\treduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: ArrayKeys<this>, array: T[]) => T): T;\n\t\treduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: ArrayKeys<this>, array: T[]) => T, initialValue: T): T;\n\t\treduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: ArrayKeys<this>, array: T[]) => U, initialValue: U): U;\n\t}\n\n\tinterface ReadonlyArray<T> {\n\t\tindexOf(searchElement: T, fromIndex?: number): ArrayKeys<this> | -1;\n\t\tlastIndexOf(searchElement: T, fromIndex?: number): ArrayKeys<this> | -1;\n\t\tevery<S extends T>(\n\t\t\tpredicate: (value: T, index: ArrayKeys<this>, array: readonly T[]) => value is S,\n\t\t\tthisArg?: T[]\n\t\t): this is { readonly [K in keyof this]: S };\n\t\tevery(predicate: (value: T, index: ArrayKeys<this>, array: readonly T[]) => unknown, thisArg?: T[]): boolean;\n\t\tsome(predicate: (value: T, index: ArrayKeys<this>, array: readonly T[]) => unknown, thisArg?: T[]): boolean;\n\t\tforEach(callbackfn: (value: T, index: ArrayKeys<this>, array: readonly T[]) => void, thisArg?: T[]): void;\n\t\tmap<U>(callbackfn: (value: T, index: ArrayKeys<this>, array: readonly T[]) => U, thisArg?: T[]): U[];\n\t\tfilter<S extends T>(predicate: (value: T, index: ArrayKeys<this>, array: readonly T[]) => value is S, thisArg?: T[]): S[];\n\t\tfilter(predicate: (value: T, index: ArrayKeys<this>, array: readonly T[]) => unknown, thisArg?: T[]): T[];\n\t\treduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: ArrayKeys<this>, array: readonly T[]) => T): T;\n\t\treduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: ArrayKeys<this>, array: readonly T[]) => T, initialValue: T): T;\n\t\treduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: ArrayKeys<this>, array: readonly T[]) => U, initialValue: U): U;\n\t\treduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: ArrayKeys<this>, array: readonly T[]) => T): T;\n\t\treduceRight(\n\t\t\tcallbackfn: (previousValue: T, currentValue: T, currentIndex: ArrayKeys<this>, array: readonly T[]) => T,\n\t\t\tinitialValue: T\n\t\t): T;\n\t\treduceRight<U>(\n\t\t\tcallbackfn: (previousValue: U, currentValue: T, currentIndex: ArrayKeys<this>, array: readonly T[]) => U,\n\t\t\tinitialValue: U\n\t\t): U;\n\t}\n\n\tinterface ArrayConstructor {\n\t\tfrom<L extends number, T>(arrayLike: { readonly length: L }): Tuple<T, L>;\n\t\tfrom<T, U, L extends number>(iterable: { readonly length: L }, mapfn: (v: T, k: number) => U, thisArg?: T[]): Tuple<U, L>;\n\t}\n}\n","import { NumericColor } from \"@moveGeneration/GameInformation/GameUnits/GameUnits\";\nimport { createTupleFromCallback, Tuple } from \"../baseTypes\";\nimport { boardDimension } from \"./movegen/GameInformation/GameData\";\n\nexport interface Cloneable<T> {\n\tcreateClone(): T;\n}\n\nexport interface Memento<S> {\n\tcreateSnapshot(): S;\n\tloadSnapshot(snapshot: S): void;\n}\n\nexport type BoardSquares<T> = Tuple<Tuple<T, typeof boardDimension>, typeof boardDimension>;\nexport const initializeBoardSquares = <T>(baseValue: (v: unknown, k: number) => T): BoardSquares<T> =>\n\tcreateTupleFromCallback(() => createTupleFromCallback(baseValue, boardDimension), boardDimension);\n\nexport const isVerticalPlacement = (color: NumericColor): color is 0 | 2 => color % 2 === 0;\nexport function getVerticalPlacementModulus(num: number): 0 | 1 {\n\tconst result = num % 2;\n\tif (result !== 0 && result !== 1) throw new Error(`Invalid number passed: ${num}`);\n\treturn result;\n}\nexport function getHorizontalPlacementModulus(num: number): 0 | 1 {\n\tconst result = num % 2 ^ 1;\n\tif (result !== 0 && result !== 1) throw new Error(`Invalid number passed: ${num}`);\n\treturn result;\n}\n","import { throwOnNever, Tuple } from \"@client/ts/baseTypes\";\nimport { truncateNumber } from \"@utils/NumberUtils\";\nimport type { Coordinate, NumericColor } from \"./GameUnits/GameUnits\";\n\nexport type PlayerName = \"Red\" | \"Blue\" | \"Yellow\" | \"Green\" | \"White\" | \"Black\";\nexport type IndividualTermination = \"Won the Race\" | \"Checkmated\" | \"Stalemated\" | \"Forfeits on Time\" | \"Resigned\" | \"Claimed the Win\";\nexport type GeneralTermination = \"King of the Hill\" | \"King Captured\" | \"Checkmate\" | \"Stalemate\";\nexport type Result = \"1-0\" | \"0-1\" | \"½-½\";\nexport type DrawnResult = \"Threefold Repetition\" | \"Insufficient Material\" | \"Timeout vs Insufficient Material\" | \"50-move Rule\";\nexport type Termination =\n\t| `${Uppercase<PlayerName>} ${Uppercase<IndividualTermination>}!`\n\t| `${Uppercase<GeneralTermination | DrawnResult>} • ${Result}`\n\t| `${Uppercase<GeneralTermination>}!`\n\t| `${Uppercase<DrawnResult>}`\n\t| \"½-½ AGREED.\";\nexport const validateComprehensiveUnionArray =\n\t<T>() =>\n\t<U extends readonly T[]>(arr: U & ([T] extends [U[number]] ? unknown : never)) =>\n\t\tarr;\n\nexport interface TimeControl {\n\tbaseTime: number;\n\tincrement: number;\n\tisDelay: boolean;\n}\n\nexport const playerNames = validateComprehensiveUnionArray<PlayerName>()([\"Red\", \"Blue\", \"Yellow\", \"Green\", \"White\", \"Black\"] as const);\nconst individualTerminations = validateComprehensiveUnionArray<IndividualTermination>()([\n\t\"Won the Race\",\n\t\"Checkmated\",\n\t\"Stalemated\",\n\t\"Forfeits on Time\",\n\t\"Claimed the Win\",\n\t\"Resigned\"\n] as const);\nconst generalWinningTerminations = validateComprehensiveUnionArray<GeneralTermination>()([\n\t\"Checkmate\",\n\t\"King Captured\",\n\t\"King of the Hill\",\n\t\"Stalemate\"\n] as const);\nexport const verifyWinningTermination = (termination: string): termination is GeneralTermination => {\n\tconst generalWins: readonly string[] = generalWinningTerminations;\n\treturn generalWins.includes(termination);\n};\nconst generalDrawingTerminations = validateComprehensiveUnionArray<DrawnResult>()([\n\t\"50-move Rule\",\n\t\"Insufficient Material\",\n\t\"Threefold Repetition\",\n\t\"Timeout vs Insufficient Material\"\n] as const);\nexport const verifyDrawingTermination = (termination: string): termination is DrawnResult => {\n\tconst generalDraws: readonly string[] = generalDrawingTerminations;\n\treturn generalDraws.includes(termination);\n};\nconst generalTerminations = validateComprehensiveUnionArray<GeneralTermination | DrawnResult>()([\n\t...generalWinningTerminations,\n\t...generalDrawingTerminations\n] as const);\nconst results = validateComprehensiveUnionArray<Result>()([\"0-1\", \"1-0\", \"½-½\"]);\n\nexport interface GamePlayerData {\n\telo?: number;\n\tname?: string;\n}\nexport interface GameData {\n\tgameNumber: number | undefined;\n\ttimeControl: TimeControl;\n\tplayers: Tuple<GamePlayerData, typeof totalPlayers>;\n\tsite: string | undefined;\n\tdate: Date | string | undefined;\n\tresult: string | undefined;\n\ttermination: Termination | undefined;\n}\n\nexport const validateTerminationString = (termination: string): termination is Termination => {\n\tconst capitalizedTermination = termination.toUpperCase();\n\tif (\n\t\tplayerNames.some((str) => capitalizedTermination.startsWith(str.toUpperCase())) &&\n\t\tindividualTerminations.some((str) => capitalizedTermination.endsWith(str.toUpperCase() + \"!\"))\n\t) {\n\t\treturn true;\n\t} else if (\n\t\t/.*?\\s•\\s.*/.test(capitalizedTermination) &&\n\t\tgeneralTerminations.some((str) => capitalizedTermination.startsWith(str.toUpperCase())) &&\n\t\tresults.some((str) => capitalizedTermination.endsWith(str.toUpperCase()))\n\t) {\n\t\treturn true;\n\t} else if (capitalizedTermination === \"½-½ AGREED.\") {\n\t\treturn true;\n\t}\n\n\treturn false;\n};\n\nexport const stringifyTimeControl = (timeControl: TimeControl): string => {\n\tconst noIncrement = timeControl.increment === 0;\n\tlet timeControlString = \"\";\n\tif (timeControl.baseTime < 60) {\n\t\ttimeControlString += noIncrement ? `${timeControl.baseTime * 60} sec` : `${timeControl.baseTime * 60}s`;\n\t} else if (timeControl.baseTime > 60 && noIncrement) {\n\t\ttimeControlString += `${truncateNumber(timeControl.baseTime / 60, 1)} min`;\n\t} else {\n\t\ttimeControlString += truncateNumber(timeControl.baseTime / 60, 1);\n\t}\n\n\tif (!noIncrement) {\n\t\ttimeControlString += \"|\";\n\t\ttimeControlString += timeControl.increment;\n\t}\n\tif (timeControl.isDelay) {\n\t\ttimeControlString += \"D\";\n\t}\n\n\treturn timeControlString;\n};\nexport const obtainTimeControlType = (timeControl: TimeControl): TimeControlType => {\n\tconst { baseTime, increment, isDelay } = timeControl;\n\tif (isDelay) {\n\t\tconst formula = baseTime / 40 + increment;\n\t\tif (formula > 11.5) {\n\t\t\treturn TimeControlType.Rapid;\n\t\t} else if (formula <= 1.375) {\n\t\t\treturn TimeControlType.Hyperbullet;\n\t\t} else if (formula <= 4.5) {\n\t\t\treturn TimeControlType.Bullet;\n\t\t} else {\n\t\t\treturn TimeControlType.Blitz;\n\t\t}\n\t} else {\n\t\tconst formula = baseTime / 60 + increment;\n\t\tif (formula > 7.5) {\n\t\t\treturn TimeControlType.Rapid;\n\t\t} else if (formula <= 0.5) {\n\t\t\treturn TimeControlType.Hyperbullet;\n\t\t} else if (formula <= 3) {\n\t\t\treturn TimeControlType.Bullet;\n\t\t} else {\n\t\t\treturn TimeControlType.Blitz;\n\t\t}\n\t}\n};\n\nexport const convertCoordinateToPGN4 = (coordinate: Coordinate, dimension = boardDimension): string => {\n\tif (dimension === boardDimension) {\n\t\treturn `${String.fromCharCode(coordinate[1] + 97)}${boardDimension - coordinate[0]}`;\n\t} else {\n\t\tconst alternation = (boardDimension - dimension) / 2;\n\t\treturn `${String.fromCharCode(coordinate[1] - alternation + 97)}${boardDimension - coordinate[0] - alternation}`;\n\t}\n};\nexport const convertCoordinateToPGN4Array = (coordinate: Coordinate, dimension = boardDimension): [string, number] => {\n\tif (dimension === boardDimension) {\n\t\treturn [String.fromCharCode(coordinate[1] + 97), boardDimension - coordinate[0]];\n\t} else {\n\t\tconst alternation = (boardDimension - dimension) / 2;\n\t\treturn [String.fromCharCode(coordinate[1] - alternation + 97), boardDimension - coordinate[0] - alternation];\n\t}\n};\n\nexport const getOppositePlacedColor = (color: NumericColor) => {\n\tswitch (color) {\n\t\tcase 0:\n\t\t\treturn 2;\n\t\tcase 1:\n\t\t\treturn 3;\n\t\tcase 2:\n\t\t\treturn 0;\n\t\tcase 3:\n\t\t\treturn 1;\n\t\tdefault:\n\t\t\treturn throwOnNever(color);\n\t}\n};\nexport const getPlayerNameFromColor = (color: NumericColor, wb = false): PlayerName => {\n\tswitch (color) {\n\t\tcase 0:\n\t\t\treturn wb ? \"White\" : \"Red\";\n\t\tcase 1:\n\t\t\treturn \"Blue\";\n\t\tcase 2:\n\t\t\treturn wb ? \"Black\" : \"Yellow\";\n\t\tcase 3:\n\t\t\treturn \"Green\";\n\t\tdefault:\n\t\t\treturn throwOnNever(color);\n\t}\n};\n\ninterface NumericColorAugmentationSettings {\n\twb: boolean;\n}\nexport const createDefaultNumericColorAdjustment = (): NumericColorAugmentationSettings => ({\n\twb: false\n});\n\nexport enum TimeControlType {\n\tHyperbullet = \"Hyperbullet\",\n\tBullet = \"Bullet\",\n\tBlitz = \"Blitz\",\n\tRapid = \"Rapid\"\n}\nexport enum VariantType {\n\tFFA = \"FFA\",\n\tTeams = \"Teams\",\n\tSolo = \"Solo\"\n}\n\nexport const totalPlayers = 4;\nexport const boardDimension = 14;\nexport const colors: readonly NumericColor[] = [0, 1, 2, 3];\n","import type { PlayerName } from \"../GameData\";\n\nexport type Coordinate = [i: number, j: number] | [i: number, j: number, promotion: string];\nexport type NumericColor = 0 | 1 | 2 | 3;\nexport const verifyNumericColor = (num: number): num is NumericColor => num >= 0 && num < 4;\nexport const nonPlayablePieces = {\n\twall: \"X\",\n\ttransparentWall: \"x\",\n\tduck: \"Θ\"\n} as const;\n\nexport const colorEnum = {\n\tr: 0,\n\tb: 1,\n\ty: 2,\n\tg: 3\n} as const;\nexport const verifyColorEnumValue = (value: string): value is keyof typeof colorEnum => value in colorEnum;\n\nexport const playerEnum: Record<PlayerName, NumericColor> = {\n\tRed: 0,\n\tBlue: 1,\n\tYellow: 2,\n\tGreen: 3,\n\tWhite: 0,\n\tBlack: 2\n} as const;\nexport const verifyPlayerEnumValue = (player: string): player is PlayerName => player in playerEnum;\n\nexport const stringColorEnum = {\n\t[0]: \"r\",\n\t[1]: \"b\",\n\t[2]: \"y\",\n\t[3]: \"g\",\n\t[4]: \"d\"\n} as const;\nexport type ColorEnum = (typeof stringColorEnum)[keyof typeof stringColorEnum];\n","import type { PieceString } from \"@moveGeneration/GameInformation/GameUnits/PieceString\";\nimport { Coordinate, nonPlayablePieces, NumericColor } from \"../GameInformation/GameUnits/GameUnits\";\nimport type { PieceControl } from \"./PieceControl\";\n\nexport const enum AttackType {\n\tNormal,\n\tMoveOnly,\n\tAttackOnly,\n\tRayGen,\n\tRayTrace,\n\tRayTraceLimited\n}\nexport interface PieceControlHooks {\n\tuseTrajectory: Coordinate[] | undefined;\n\tusePerspective: boolean[] | undefined;\n\tusePawnLogic: { promotionRanks?: [number, number, number, number]; promotionPieces?: PieceLetter[] } | undefined;\n\tuseHopping: boolean;\n}\nexport interface PieceControlConfiguration {\n\tdisplacement: Coordinate;\n\tspecial?: AttackType;\n\tlimit?: number;\n\tsquareBlockingIndex?: number;\n\trayGenCache?: Coordinate;\n\tirreversible?: true;\n}\n\nexport interface PieceControlConfigSettings {\n\tpoints: {\n\t\tsinglesPoints: number;\n\t\tteamsPoints: number;\n\t\tbotFFAValue: number;\n\t\tbotTeamsValue: number;\n\t};\n\tpiece: string;\n\tmoveGenerationSettings: {\n\t\tisComplex: boolean;\n\t\tisJumping: boolean;\n\t\tisSliding: boolean;\n\t\tisPawn: boolean;\n\t\tisColorBound: boolean;\n\t};\n\tnaming: {\n\t\tname: string;\n\t\tshortName: string;\n\t\tdescription?: string;\n\t};\n}\n\nexport const nonPlayableValues: string[] = Object.values(nonPlayablePieces);\ndeclare const pieceLetterTag: unique symbol;\nexport type PieceLetter = string & { _: typeof pieceLetterTag };\nexport const verifyPieceLetter = (piece: string): piece is PieceLetter =>\n\tpiece in pieceControlConfigSettings || nonPlayableValues.includes(piece);\n\nexport const pieceControlConfigSettings = nonPlayableValues.reduce<Record<PieceLetter, PieceControlSettings>>(\n\t(p, n) => ({\n\t\t...p,\n\t\t[n]: {\n\t\t\tpoints: {\n\t\t\t\tsinglesPoints: 0,\n\t\t\t\tteamsPoints: 0,\n\t\t\t\tbotFFAValue: 0,\n\t\t\t\tbotTeamsValue: 0\n\t\t\t},\n\t\t\tpiece: n,\n\t\t\tmoveGenerationSettings: {\n\t\t\t\tisComplex: false,\n\t\t\t\tisJumping: false,\n\t\t\t\tisSliding: false,\n\t\t\t\tisPawn: false\n\t\t\t},\n\t\t\tnaming: {\n\t\t\t\tname: \"Wall\",\n\t\t\t\tshortName: n\n\t\t\t}\n\t\t}\n\t}),\n\t{}\n);\nexport interface PieceControlSettings extends PieceControlConfigSettings {\n\tconstruct: new () => PieceControl;\n}\ninterface PieceControlDeclarationConfiguration<T extends PieceControl> {\n\tconfiguration: PieceControlConfigSettings;\n\tbaseClassRef: new () => T;\n}\nexport const createPieceDeclaration = <T extends PieceControl>(configuration: PieceControlDeclarationConfiguration<T>) => {\n\tpieceControlConfigSettings[configuration.configuration.piece as PieceLetter] = {\n\t\t...configuration.configuration,\n\t\tconstruct: configuration.baseClassRef\n\t};\n\n\treturn new configuration.baseClassRef();\n};\n\nexport interface PieceControlGeneratedMove {\n\tmove: Coordinate;\n\tirreversible: boolean;\n}\n\nexport interface PieceControlInternalMove {\n\ti: number;\n\tj: number;\n\tisRayGen?: boolean;\n\tirreversible?: boolean;\n}\n\nexport interface ControlConfiguration {\n\tcoordinates: [number, number];\n\tboard: PieceString[][];\n\timmunePieces: [boolean, boolean, boolean, boolean];\n\tcolor: NumericColor;\n\tbaseRank?: boolean;\n}\n\nfunction createPredefinedPieceLetter(letter: string) {\n\treturn letter as PieceLetter;\n}\n\nexport const pawnPieceLetter = createPredefinedPieceLetter(\"P\");\nexport const wallPieceLetter = createPredefinedPieceLetter(nonPlayablePieces.wall);\nexport const grasshopperPieceLetter = createPredefinedPieceLetter(\"G\");\nexport const defaultPieces = {\n\tqueen: createPredefinedPieceLetter(\"Q\"),\n\trook: createPredefinedPieceLetter(\"R\"),\n\tbishop: createPredefinedPieceLetter(\"B\"),\n\tknight: createPredefinedPieceLetter(\"N\"),\n\tking: createPredefinedPieceLetter(\"K\")\n} as const;\nexport const emptyLetter = createPredefinedPieceLetter(\"\");\nexport const duckLetter = createPredefinedPieceLetter(nonPlayablePieces.duck);\nexport const dameLetter = createPredefinedPieceLetter(\"D\");","import { boardDimension } from \"@moveGeneration/GameInformation/GameData\";\nimport { PieceLetter, verifyPieceLetter } from \"@moveGeneration/PieceControl/PieceControlInterface\";\nimport { bitCount } from \"@utils/NumberUtils\";\n\nexport const binaryMasks = Array(boardDimension)\n\t.fill(1)\n\t.map((v, i) => (v << boardDimension) | (v << (boardDimension - 1 - i)));\nexport const oneBitMask = 1 << boardDimension;\n\nexport function countBitsOnBoard(board: Uint16Array): number {\n\tlet setBits = 0;\n\tfor (let x = 0; x < boardDimension; x++) {\n\t\tsetBits += bitCount(board[x] ^ oneBitMask);\n\t}\n\n\treturn setBits;\n}\n\nexport function findMinimumOnBoardSquares(board: Uint16Array[][]): number {\n\tlet minimum = Infinity;\n\tfor (let i = 0; i < boardDimension; i++) {\n\t\tfor (let j = 0; j < boardDimension; j++) {\n\t\t\tconst setBits = countBitsOnBoard(board[i][j]);\n\t\t\tif (setBits !== 0 && setBits < minimum) {\n\t\t\t\tminimum = setBits;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn minimum;\n}\n\nexport function optimizePieceSet(possiblePieces: string[], maximumTarget: boolean): Set<PieceLetter> {\n\tconst optimalRoyalMoveSets = [\n\t\t[\"β\", \"W\", \"R\", \"E\", \"M\", \"Q\", \"D\", \"A\"],\n\t\t[\"γ\", \"F\", \"B\", \"H\", \"M\", \"Q\", \"D\", \"A\", \"Δ\"],\n\t\t[\"Y\", \"Z\"],\n\t\t[\"I\", \"J\"],\n\t\t[\"S\", \"T\"],\n\t\t[\"S\", \"Y\"],\n\t\t[\"I\", \"Y\"],\n\t\t[\"U\", \"N\", \"O\"],\n\t\t[\"H\", \"A\"],\n\t\t[\"E\", \"A\"],\n\t\t[\"Δ\", \"H\"],\n\t\t[\"C\", \"L\"],\n\t\t[\"C\", \"V\"]\n\t];\n\tconst moveSet = new Set<PieceLetter>();\n\tfor (const optimalMoveSet of optimalRoyalMoveSets) {\n\t\tconst detractionSet = maximumTarget ? optimalMoveSet.slice().reverse() : optimalMoveSet;\n\t\tfor (const piece of possiblePieces) {\n\t\t\tif (detractionSet.includes(piece)) {\n\t\t\t\tconst target = detractionSet.slice(0, -detractionSet.indexOf(piece));\n\t\t\t\ttarget.forEach((t) => {\n\t\t\t\t\tif (possiblePieces.includes(t) && verifyPieceLetter(t)) moveSet.add(t);\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (moveSet.size === 0) {\n\t\tpossiblePieces.forEach((p) => {\n\t\t\tif (verifyPieceLetter(p)) moveSet.add(p);\n\t\t});\n\t}\n\n\treturn moveSet;\n}\n","import { Tuple } from \"../baseTypes\";\n\nexport function shuffleArray<T>(array: T[]): T[];\nexport function shuffleArray<T, L extends number>(array: Tuple<T, L>): Tuple<T, L>;\nexport function shuffleArray<T, L extends number>(array: T[] | Tuple<T, L>): T[] | Tuple<T, L> {\n\tlet i = array.length;\n\tlet r = 0;\n\twhile (i !== 0) {\n\t\tr = Math.floor(Math.random() * i--);\n\t\t[array[i], array[r]] = [array[r], array[i]];\n\t}\n\n\treturn array;\n}\n\nexport function compareArrays(arr1: unknown[] | readonly unknown[], arr2: unknown[] | readonly unknown[]): boolean {\n\tif (arr1 === arr2) return true;\n\tif (arr1.length !== arr2.length) return false;\n\tfor (let i = 0; i < arr1.length; i++) {\n\t\tconst first = arr1[i],\n\t\t\tsecond = arr2[i];\n\t\tif (Array.isArray(first) && Array.isArray(second)) {\n\t\t\tif (!compareArrays(first, second)) return false;\n\t\t} else if (first !== second) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nexport function countMinimumOf2DArrayExcludingZero(array: number[][]): number {\n\tlet minimum = Infinity;\n\tfor (const row of array) {\n\t\tfor (const number of row) {\n\t\t\tif (number !== 0 && number < minimum) {\n\t\t\t\tminimum = number;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn minimum;\n}\n\nexport function findLastIndex<T>(array: T[], callback: (value: T, index: number, arr: T[]) => boolean): number {\n\tlet i = array.length;\n\twhile (i--) {\n\t\tif (callback(array[i], i, array)) return i;\n\t}\n\treturn -1;\n}\n","export function truncateNumber(number: number, digits: number): number {\n\tconst multiplier = Math.pow(10, digits);\n\tconst adjusted = number * multiplier;\n\tif (adjusted < 0) {\n\t\treturn Math.ceil(adjusted / multiplier);\n\t} else {\n\t\treturn Math.floor(adjusted / multiplier);\n\t}\n}\n\nexport function bitCount(number: number): number {\n\tnumber = number - ((number >> 1) & 0x55555555);\n\tnumber = (number & 0x33333333) + ((number >> 2) & 0x33333333);\n\treturn (((number + (number >> 4)) & 0xf0f0f0f) * 0x1010101) >> 24;\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","import { createTupleFromCallback, Tuple } from \"@client/ts/baseTypes\";\nimport { BoardSquares, initializeBoardSquares } from \"@client/ts/logic/BaseInterfaces\";\nimport { boardDimension, colors, totalPlayers } from \"@moveGeneration/GameInformation/GameData\";\nimport type { PieceLetter } from \"@moveGeneration/PieceControl/PieceControlInterface\";\nimport { countMinimumOf2DArrayExcludingZero } from \"@client/ts/utils/ArrayUtils\";\nimport { countBitsOnBoard } from \"./Utilities\";\n\nexport type PieceMedianCounterReturnType = Tuple<number | undefined, typeof totalPlayers>;\ninterface PieceMedianCounterSettings {\n\twalls: BoardSquares<boolean>;\n\tmoveRegistryArray: ArrayBufferLike[][];\n\troyalPieceSet: Tuple<PieceLetter[], typeof totalPlayers>;\n\troyalMoves: Tuple<ArrayBufferLike[][], typeof totalPlayers>;\n}\n\nself.onmessage = (e: MessageEvent<PieceMedianCounterSettings>) => {\n\tconst { walls, royalPieceSet, royalMoves, moveRegistryArray } = e.data;\n\tconst resultingMedianArray = createTupleFromCallback<BoardSquares<number> | undefined, typeof totalPlayers>(\n\t\t() => initializeBoardSquares(() => 0),\n\t\ttotalPlayers\n\t);\n\tfor (let i = 0; i < boardDimension; i++) {\n\t\tfor (let j = 0; j < boardDimension; j++) {\n\t\t\tif (walls[i][j]) continue;\n\t\t\tconst moves = new Uint16Array(moveRegistryArray[i][j]);\n\t\t\tfor (const color of colors) {\n\t\t\t\tif (royalPieceSet[color].length === 0) {\n\t\t\t\t\tresultingMedianArray[color] = undefined;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tlet resultingSquares = 0;\n\t\t\t\t\tfor (let royalI = 0; royalI < boardDimension; royalI++) {\n\t\t\t\t\t\tfor (let royalJ = 0; royalJ < boardDimension; royalJ++) {\n\t\t\t\t\t\t\tconst royalMoveSet = new Uint16Array(royalMoves[color][royalI][royalJ]);\n\t\t\t\t\t\t\tconst result = moves.map((e, x) => e & royalMoveSet[x]);\n\t\t\t\t\t\t\tconst newResultingSquares = countBitsOnBoard(result);\n\n\t\t\t\t\t\t\tif (newResultingSquares > resultingSquares) {\n\t\t\t\t\t\t\t\tresultingSquares = newResultingSquares;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst resultingMedian = resultingMedianArray[color];\n\t\t\t\t\tif (resultingMedian) resultingMedian[i][j] = resultingSquares;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpostMessage(\n\t\tresultingMedianArray.map((arr) => {\n\t\t\tif (arr) {\n\t\t\t\tconst minimum = countMinimumOf2DArrayExcludingZero(arr);\n\t\t\t\treturn minimum === Infinity ? 0 : minimum;\n\t\t\t} else return arr;\n\t\t})\n\t);\n};\n"],"names":["createTupleFromCallback","val","length","Array","from","initializeBoardSquares","baseValue","boardDimension","generalWinningTerminations","generalDrawingTerminations","totalPlayers","colors","nonPlayablePieces","wall","transparentWall","duck","nonPlayableValues","Object","values","reduce","p","n","_objectSpread","points","singlesPoints","teamsPoints","botFFAValue","botTeamsValue","piece","moveGenerationSettings","isComplex","isJumping","isSliding","isPawn","naming","name","shortName","fill","map","v","i","oneBitMask","countBitsOnBoard","board","setBits","x","bitCount","countMinimumOf2DArrayExcludingZero","array","_step","minimum","Infinity","_iterator","_createForOfIteratorHelper","s","done","_step2","_iterator2","value","number","err","e","f","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","d","definition","key","o","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","self","onmessage","_e$data","data","walls","royalPieceSet","royalMoves","moveRegistryArray","resultingMedianArray","j","moves","Uint16Array","color","resultingSquares","royalI","_loop","royalMoveSet","royalJ","result","newResultingSquares","resultingMedian","postMessage","arr"],"sourceRoot":""}