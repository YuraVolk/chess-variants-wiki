{"version":3,"file":"src_main_client_javascript_logic_index_GameBoardWorker_ts.react-app.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,kBAAkB,SAAI,IAAI,SAAI;AAC9B;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA,kBAAkB,SAAI,IAAI,SAAI;AAC9B;AACA;AAC0B;AAC0B;AACoB;AACY;AACoC;AACnC;AACnC;AACmB;AACU;AACJ;AAC0B;AACjC;AAC7D;AACA;AACA;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gCAAgC,yFAAmB;AACnD;AACA;AACA;AACA,yBAAyB,8DAAK;AAC9B,qBAAqB,mGAAyB,aAAa,8DAAK;AAChE;AACA,2BAA2B,6FAAgB;AAC3C;AACA,QAAQ,kGAAqB;AAC7B;AACA;AACA;AACA;AACA,2BAA2B,yEAAW,IAAI,kFAAY;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,4BAA4B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gEAAa;AACzB;AACA,YAAY,gFAAkB;AAC9B;AACA;AACA;AACA;AACA,YAAY,mFAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8FAAkB;AAClC,+BAA+B,+DAA+D,gHAA6B,MAAM;AACjI;AACA,qBAAqB,8FAAkB;AACvC,+BAA+B,yBAAyB,gHAA6B,uBAAuB;AAC5G;AACA;AACA;AACA;AACA,aAAa,8FAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,eAAe,iFAAc;AAC7B;AACA;AACA;AACA;AACA,kEAAkE,gHAA6B;AAC/F;AACA;AACA;AACA;AACA,0DAA0D,yFAAmB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,yFAAmB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7asI;AAC/H;AACP;AACA;AACA,QAAQ,+EAAkB;AAC1B;AACA;AACA,aAAa,+EAAkB;AAC/B;AACA;AACA,aAAa,+EAAkB;AAC/B;AACA;AACA;AACA,kEAAkE,qBAAqB;AACvF;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,yEAAY;AACjE;AACA;AACA,YAAY,+EAAkB,+BAA+B,8EAAqB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AChC+E;AAC7B;AACc;AACwC;AACzB;AACD;AACe;AACtF;AACP;AACA,wBAAwB,yDAAc;AACtC;AACA;AACA,0EAA0E,yEAAW,sCAAsC,mEAAY;AACvI;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA,oBAAoB,mCAAmC;AACvD,mCAAmC,yEAAqB,GAAG,8BAA8B;AACzF;AACA,aAAa;AACb;AACA;AACA,wCAAwC,4EAAiB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sEAAkB;AACtC;AACA;AACA;AACA;AACA,mCAAmC,2FAAmB;AACtD,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,qEAAqB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gEAAa;AACxC;AACA;AACA;AACA;AACA,4BAA4B,IAAI,mEAAY,EAAE;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0DAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,kDAAkD,0DAAe;AACjE,IAAI,gFAAkB;AACtB;AACA;AACA;AACA;AACA,yDAAyD,wEAAiB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,6DAAM;AACtC;AACA;AACA,uCAAuC,iFAAsB,YAAY,IAAI,cAAc;AAC3F;AACA;AACA;AACA;AACA","sources":["webpack://spring-react-app/./src/main/client/javascript/logic/index/GameBoardWorker.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/Board/BoardMoveValidator.ts","webpack://spring-react-app/./src/main/client/javascript/logic/movegen/MoveTree/MoveTreeValidator.ts"],"sourcesContent":["var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nimport \"reflect-metadata\";\r\nimport { Board } from \"@moveGeneration/Board/Board\";\r\nimport { totalPlayers } from \"@moveGeneration/GameInformation/GameData\";\r\nimport { PieceString } from \"@moveGeneration/GameInformation/GameUnits/PieceString\";\r\nimport { verifyStandardMove, verifyDroppingMove, verifyRequiredMove } from \"@moveGeneration/MoveTree/MoveTreeInterface\";\r\nimport { decorateClassWithVariants } from \"@moveGeneration/VariantRules/VariantRule\";\r\nimport { compareArrays } from \"@utils/ArrayUtils\";\r\nimport { serializeBoard } from \"../utils/Tags/InputOutputProcessing\";\r\nimport { assertNonUndefined, createTuple } from \"@client/javascript/baseTypes\";\r\nimport { stringifyCoordinate } from \"@moveGeneration/Board/BoardInterface\";\r\nimport { changeGameTermination, validateMoveTree } from \"@moveGeneration/MoveTree/MoveTreeValidator\";\r\nimport { assertValidMove } from \"@moveGeneration/MoveTree/MoveTree\";\r\nexport const requiredDispatches = [];\r\nexport const initialDispatches = [];\r\nexport const dispatchSyncRecord = {};\r\nfunction withWorkerResult() {\r\n    return function (_, propertyKey, descriptor) {\r\n        const originalMethod = descriptor.value;\r\n        descriptor.value = (function (...args) {\r\n            postMessage([propertyKey, originalMethod.apply(this, args)]);\r\n        });\r\n    };\r\n}\r\nfunction workerDataSync(type, gameObjectPropertySync) {\r\n    return function (_, propertyKey) {\r\n        if (type === \"required\") {\r\n            initialDispatches.push(propertyKey);\r\n            requiredDispatches.push(propertyKey);\r\n        }\r\n        else {\r\n            initialDispatches.push(propertyKey);\r\n        }\r\n        dispatchSyncRecord[propertyKey] = gameObjectPropertySync;\r\n    };\r\n}\r\nclass RequestManager {\r\n    board;\r\n    initiallyAliveColors = [];\r\n    internalMoves = [];\r\n    legalMoves = new Map();\r\n    fogOfWarPerspective = false;\r\n    stripPieceStrings(object) {\r\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\r\n        return JSON.parse(JSON.stringify(object));\r\n    }\r\n    generateInitiallyAliveColors() {\r\n        return this.board.data.fenOptions.tag(\"dead\").map(d => !d).reduce((p, n, i) => {\r\n            if (n) {\r\n                return [...p, i];\r\n            }\r\n            else\r\n                return p;\r\n        }, []);\r\n    }\r\n    generateCurrentMoves() {\r\n        this.internalMoves = this.board.getAllowedInternalMoves(), this.legalMoves = new Map();\r\n        for (const piece of this.board.getPlayerPieces()[this.board.data.sideToMove]) {\r\n            this.legalMoves.set(stringifyCoordinate(piece), this.board.getLegalMoves(piece[0], piece[1]));\r\n        }\r\n    }\r\n    construct(pgn4) {\r\n        this.board = new Board(pgn4);\r\n        this.board = decorateClassWithVariants(this.board, Board, this.board.variantRules.boardDecorators);\r\n        this.generateInitiallyAliveColors();\r\n        this.board.moves = validateMoveTree(this.board, this.board.moves);\r\n        this.board.moves.currentMove = [-1];\r\n        changeGameTermination(this.board);\r\n        this.generateCurrentMoves();\r\n    }\r\n    getFENSettings() {\r\n        const board = this.board;\r\n        const royalCount = createTuple(0, totalPlayers);\r\n        let isCustomRoyals = false;\r\n        for (const row of this.board.board) {\r\n            for (const square of row) {\r\n                if (square.isPiece() && square.piece === \"K\" && ((++royalCount[square.color]) > 1)) {\r\n                    isCustomRoyals = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (isCustomRoyals)\r\n                break;\r\n        }\r\n        return {\r\n            sideToMove: board.data.sideToMove, points: [...board.data.points],\r\n            isCustomRoyals,\r\n            fenOptions: {\r\n                areBanksEnabled: board.data.fenOptions.tag(\"areBanksEnabled\"),\r\n                whiteBlack: board.data.fenOptions.tag(\"wb\"), dimension: board.data.fenOptions.tag(\"dim\"),\r\n                noCorners: board.data.fenOptions.tag(\"noCorners\"), dead: board.data.fenOptions.tag(\"dead\"),\r\n                resigned: board.data.fenOptions.tag(\"resigned\"), zombieType: board.data.fenOptions.tag(\"zombieType\"),\r\n                zombieImmune: board.data.fenOptions.tag(\"zombieImmune\"), royal: board.data.fenOptions.tag(\"royal\"),\r\n                lives: board.data.fenOptions.tag(\"lives\"), dim: board.data.fenOptions.tag(\"dim\"),\r\n                termination: board.data.gameOver,\r\n                bank: board.data.fenOptions.tag(\"bank\").map(map => {\r\n                    const result = [];\r\n                    for (const [key, value] of map) {\r\n                        result.push([key.toObject(), value]);\r\n                    }\r\n                    return result;\r\n                })\r\n            }\r\n        };\r\n    }\r\n    getInitiallyAliveColors() {\r\n        return this.initiallyAliveColors;\r\n    }\r\n    getMoveTree() {\r\n        const traverse = (moves, fullMoveCounter = 0) => {\r\n            const results = [];\r\n            for (const moveWrapper of moves) {\r\n                const resultingWrapper = {\r\n                    alternativeLines: [],\r\n                    comment: moveWrapper.comment,\r\n                    path: moveWrapper.path.slice(),\r\n                    cachedNames: { ...moveWrapper.cachedNames },\r\n                    metadata: {\r\n                        currentSideToMove: moveWrapper.metadata.currentSideToMove,\r\n                        playerClock: moveWrapper.metadata.playerClock,\r\n                        highlightedArrows: moveWrapper.metadata.highlightedArrows,\r\n                        highlightedSquares: moveWrapper.metadata.highlightedSquares\r\n                    }\r\n                };\r\n                if (moveWrapper.metadata.currentFullMove)\r\n                    resultingWrapper.metadata.currentFullMove = moveWrapper.metadata.currentFullMove;\r\n                for (const alternativeLine of moveWrapper.alternativeLines) {\r\n                    resultingWrapper.alternativeLines.push(traverse(alternativeLine, fullMoveCounter - 1));\r\n                }\r\n                results.push(resultingWrapper);\r\n            }\r\n            return results;\r\n        };\r\n        return traverse(this.board.moves.moves);\r\n    }\r\n    loadSnapshotByPath(path) {\r\n        let snapshot;\r\n        if (compareArrays(path, [-1])) {\r\n            const preliminarySnapshot = this.board.moves.getBoardSnapshot(-1);\r\n            assertNonUndefined(preliminarySnapshot);\r\n            snapshot = preliminarySnapshot;\r\n        }\r\n        else {\r\n            const currentMove = this.board.moves.getMove(path);\r\n            assertValidMove(currentMove);\r\n            const preliminarySnapshot = this.board.moves.getBoardSnapshot(currentMove);\r\n            if (!preliminarySnapshot)\r\n                return false;\r\n            snapshot = preliminarySnapshot;\r\n        }\r\n        this.board.loadSnapshot(snapshot.boardSnapshot);\r\n        this.board.moves.currentMove = [...path];\r\n        this.generateCurrentMoves();\r\n        return true;\r\n    }\r\n    verifyNextChainedMovesAreDeleted(move) {\r\n        return !(\"nextChainedMoves\" in move);\r\n    }\r\n    convertStrippedMoveToNormal(move) {\r\n        const newMove = [];\r\n        for (const moveComponent of move) {\r\n            delete moveComponent.nextChainedMoves;\r\n            if (!this.verifyNextChainedMovesAreDeleted(moveComponent))\r\n                throw new Error(\"Could not delete nextChainedMoves in move component\");\r\n            if (verifyStandardMove(moveComponent)) {\r\n                newMove.push({ ...moveComponent, promotion: moveComponent.promotion?.map(p => PieceString.fromObjectToClass(p)) });\r\n            }\r\n            else if (verifyDroppingMove(moveComponent)) {\r\n                newMove.push({ ...moveComponent, piece: PieceString.fromObjectToClass(moveComponent.piece) });\r\n            }\r\n            else\r\n                newMove.push(moveComponent);\r\n        }\r\n        if (!verifyRequiredMove(newMove))\r\n            throw new Error(\"Supplied move object had 0 move components\");\r\n        return newMove;\r\n    }\r\n    makeMove(passedMove) {\r\n        const board = this.board, move = this.convertStrippedMoveToNormal(passedMove);\r\n        board.moves.augmentMoveWithMetadata({\r\n            move, board, makeMoveFunction: () => {\r\n                return board.makeMove(move);\r\n            }\r\n        });\r\n        this.generateCurrentMoves();\r\n    }\r\n    serializeBoardToPGN() {\r\n        return serializeBoard(this.board);\r\n    }\r\n    getDroppingMoves(pieceString) {\r\n        if (this.board.data.gameOver)\r\n            return [];\r\n        return this.stripPieceStrings(this.board.getDroppingMoves(PieceString.fromObjectToClass(pieceString)));\r\n    }\r\n    getLegalMoves(i, j) {\r\n        if (this.board.data.gameOver)\r\n            return [];\r\n        return this.stripPieceStrings(this.legalMoves.get(stringifyCoordinate([i, j])) ?? this.board.getLegalMoves(i, j));\r\n    }\r\n    getInternalMoves() {\r\n        if (this.board.data.gameOver)\r\n            return [];\r\n        return this.stripPieceStrings(this.internalMoves);\r\n    }\r\n    getVariantData() {\r\n        return this.stripPieceStrings(this.board.variantData);\r\n    }\r\n    getBoard() {\r\n        return this.board.board.map(r => r.map(p => p.toObject()));\r\n    }\r\n    getGameData() {\r\n        const newGameData = { ...this.board.gameData };\r\n        if (typeof newGameData.date === \"object\") {\r\n            newGameData.date = newGameData.date.toUTCString();\r\n        }\r\n        return newGameData;\r\n    }\r\n    getCurrentMove() {\r\n        return this.board.moves.currentMove;\r\n    }\r\n    getVariantRules() {\r\n        const resultingRules = [];\r\n        let key;\r\n        for (key in this.board.variantRules) {\r\n            if (!Object.prototype.hasOwnProperty.call(this.board.variantRules, key))\r\n                continue;\r\n            for (const variantRule of this.board.variantRules[key]) {\r\n                resultingRules.push(variantRule.getPublicProperties());\r\n            }\r\n        }\r\n        return resultingRules;\r\n    }\r\n    getVariantType() {\r\n        return this.board.gameType.type;\r\n    }\r\n    deleteMove(path) {\r\n        if (this.board.moves.moves.length !== 0)\r\n            this.board.moves.deleteMove(path);\r\n    }\r\n    playPreferredBotMove() {\r\n        if (this.board.data.getRealPlayers() <= 1)\r\n            return;\r\n        const legalMoves = [];\r\n        for (const piece of this.board.getPlayerPieces()[this.board.data.sideToMove]) {\r\n            legalMoves.push(...(this.legalMoves.get(stringifyCoordinate(piece)) ?? this.board.getLegalMoves(piece[0], piece[1])));\r\n        }\r\n        // TODO Pick strongest piece\r\n        legalMoves.push(...this.board.preGeneratedAttacks[this.board.data.sideToMove].pieceDrops.piece);\r\n        legalMoves.push(...this.board.preGeneratedAttacks[this.board.data.sideToMove].pieceDrops.pawn);\r\n        legalMoves.push(...this.internalMoves);\r\n        const algorithm = this.board.data.fenOptions.getDefaultZombieAlgorithm(this.board.data.sideToMove);\r\n        const moves = algorithm.evaluate(legalMoves, this.board);\r\n        return this.stripPieceStrings(algorithm.pickPreferredMove(moves));\r\n    }\r\n    changeFogPerspective() {\r\n        if (!this.board.variantData.fogOfWar || this.board.data.getRealPlayers() <= 1)\r\n            return this.fogOfWarPerspective;\r\n        if (this.fogOfWarPerspective === false) {\r\n            this.fogOfWarPerspective = this.board.data.sideToMove;\r\n        }\r\n        else {\r\n            const newPerspective = this.board.data.nextTurn(this.fogOfWarPerspective);\r\n            if (newPerspective === this.board.data.sideToMove) {\r\n                this.fogOfWarPerspective = false;\r\n            }\r\n            else\r\n                this.fogOfWarPerspective = newPerspective;\r\n        }\r\n        return this.fogOfWarPerspective;\r\n    }\r\n    getSquareVisibility() {\r\n        if (this.fogOfWarPerspective === false) {\r\n            return this.board.getSquareVisibility();\r\n        }\r\n        else {\r\n            const sideToMove = this.board.data.sideToMove;\r\n            this.board.data.sideToMove = this.fogOfWarPerspective;\r\n            const squareVisibility = this.board.getSquareVisibility();\r\n            this.board.data.sideToMove = sideToMove;\r\n            return squareVisibility;\r\n        }\r\n    }\r\n}\r\n__decorate([\r\n    withWorkerResult(),\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", [String]),\r\n    __metadata(\"design:returntype\", void 0)\r\n], RequestManager.prototype, \"construct\", null);\r\n__decorate([\r\n    workerDataSync(\"required\", \"publicFENSettings\"),\r\n    withWorkerResult(),\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", []),\r\n    __metadata(\"design:returntype\", void 0)\r\n], RequestManager.prototype, \"getFENSettings\", null);\r\n__decorate([\r\n    workerDataSync(\"initial\", \"initiallyAliveColors\"),\r\n    withWorkerResult(),\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", []),\r\n    __metadata(\"design:returntype\", void 0)\r\n], RequestManager.prototype, \"getInitiallyAliveColors\", null);\r\n__decorate([\r\n    workerDataSync(\"required\", \"moveTree\"),\r\n    withWorkerResult(),\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", []),\r\n    __metadata(\"design:returntype\", void 0)\r\n], RequestManager.prototype, \"getMoveTree\", null);\r\n__decorate([\r\n    withWorkerResult(),\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", [Array]),\r\n    __metadata(\"design:returntype\", void 0)\r\n], RequestManager.prototype, \"loadSnapshotByPath\", null);\r\n__decorate([\r\n    withWorkerResult(),\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", [Object]),\r\n    __metadata(\"design:returntype\", void 0)\r\n], RequestManager.prototype, \"makeMove\", null);\r\n__decorate([\r\n    workerDataSync(\"required\", \"serializedPGN\"),\r\n    withWorkerResult(),\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", []),\r\n    __metadata(\"design:returntype\", void 0)\r\n], RequestManager.prototype, \"serializeBoardToPGN\", null);\r\n__decorate([\r\n    withWorkerResult(),\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", [Object]),\r\n    __metadata(\"design:returntype\", void 0)\r\n], RequestManager.prototype, \"getDroppingMoves\", null);\r\n__decorate([\r\n    withWorkerResult(),\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", [Number, Number]),\r\n    __metadata(\"design:returntype\", void 0)\r\n], RequestManager.prototype, \"getLegalMoves\", null);\r\n__decorate([\r\n    workerDataSync(\"required\", \"allowedInternalMoves\"),\r\n    withWorkerResult(),\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", []),\r\n    __metadata(\"design:returntype\", void 0)\r\n], RequestManager.prototype, \"getInternalMoves\", null);\r\n__decorate([\r\n    workerDataSync(\"initial\", \"variantDataRules\"),\r\n    withWorkerResult(),\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", []),\r\n    __metadata(\"design:returntype\", void 0)\r\n], RequestManager.prototype, \"getVariantData\", null);\r\n__decorate([\r\n    workerDataSync(\"required\", \"boardSquares\"),\r\n    withWorkerResult(),\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", []),\r\n    __metadata(\"design:returntype\", void 0)\r\n], RequestManager.prototype, \"getBoard\", null);\r\n__decorate([\r\n    workerDataSync(\"required\", \"gameData\"),\r\n    withWorkerResult(),\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", []),\r\n    __metadata(\"design:returntype\", void 0)\r\n], RequestManager.prototype, \"getGameData\", null);\r\n__decorate([\r\n    workerDataSync(\"required\", \"currentMove\"),\r\n    withWorkerResult(),\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", []),\r\n    __metadata(\"design:returntype\", void 0)\r\n], RequestManager.prototype, \"getCurrentMove\", null);\r\n__decorate([\r\n    workerDataSync(\"initial\", \"variantRules\"),\r\n    withWorkerResult(),\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", []),\r\n    __metadata(\"design:returntype\", void 0)\r\n], RequestManager.prototype, \"getVariantRules\", null);\r\n__decorate([\r\n    workerDataSync(\"initial\", \"variantType\"),\r\n    withWorkerResult(),\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", []),\r\n    __metadata(\"design:returntype\", void 0)\r\n], RequestManager.prototype, \"getVariantType\", null);\r\n__decorate([\r\n    withWorkerResult(),\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", [Array]),\r\n    __metadata(\"design:returntype\", void 0)\r\n], RequestManager.prototype, \"deleteMove\", null);\r\n__decorate([\r\n    withWorkerResult(),\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", []),\r\n    __metadata(\"design:returntype\", void 0)\r\n], RequestManager.prototype, \"playPreferredBotMove\", null);\r\n__decorate([\r\n    withWorkerResult(),\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", []),\r\n    __metadata(\"design:returntype\", void 0)\r\n], RequestManager.prototype, \"changeFogPerspective\", null);\r\n__decorate([\r\n    workerDataSync(\"required\", \"squareVisibility\"),\r\n    withWorkerResult(),\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", []),\r\n    __metadata(\"design:returntype\", void 0)\r\n], RequestManager.prototype, \"getSquareVisibility\", null);\r\nconst requestManager = new RequestManager();\r\nself.onmessage = (e) => {\r\n    if (!(e.data.requestName in RequestManager.prototype))\r\n        return;\r\n    const method = RequestManager.prototype[e.data.requestName];\r\n    method.apply(requestManager, e.data.parameters);\r\n};\r\n","import { compareMoves, SpecialMove, verifyDroppingMove, verifyInternalMove, verifyStandardMove } from \"../MoveTree/MoveTreeInterface\";\r\nexport function validateBoardMove(board, move) {\r\n    let startingMoves;\r\n    const firstMove = move[0];\r\n    if (verifyStandardMove(firstMove)) {\r\n        startingMoves = board.getLegalMoves(firstMove.startCoordinates[0], firstMove.startCoordinates[1]);\r\n    }\r\n    else if (verifyDroppingMove(firstMove)) {\r\n        startingMoves = board.getDroppingMoves(firstMove.piece);\r\n    }\r\n    else if (verifyInternalMove(firstMove)) {\r\n        startingMoves = board.getAllowedInternalMoves();\r\n    }\r\n    else\r\n        throw new Error(`Unexpected move signature encountered: ${JSON.stringify(move)}`);\r\n    const specialMoveSettings = {\r\n        hasEnPassant: false\r\n    };\r\n    if (board.variantData.duckChess && move.length === 1)\r\n        return false;\r\n    for (const moveComponent of move) {\r\n        const move = startingMoves.find(legalMove => compareMoves(legalMove, moveComponent));\r\n        if (!move)\r\n            return false;\r\n        if (verifyStandardMove(move) && move.specialType === SpecialMove.EnPassant) {\r\n            specialMoveSettings.hasEnPassant = true;\r\n        }\r\n        if (move.nextChainedMoves) {\r\n            startingMoves = move.nextChainedMoves;\r\n        }\r\n    }\r\n    return specialMoveSettings;\r\n}\r\n","import { assertNonUndefined, createTuple } from \"@client/javascript/baseTypes\";\r\nimport { findLastIndex } from \"@utils/ArrayUtils\";\r\nimport { validateBoardMove } from \"../Board/BoardMoveValidator\";\r\nimport { colors, getPlayerNameFromColor, totalPlayers, VariantType } from \"../GameInformation/GameData\";\r\nimport { createPieceFromData } from \"../GameInformation/GameUnits/PieceString\";\r\nimport { assertValidMove, createMoveTree, verifyValidMove } from \"./MoveTree\";\r\nimport { createBaseMoveWrapper, SpecialMove, verifyStandardMove } from \"./MoveTreeInterface\";\r\nexport function validateMoveTree(board, moves) {\r\n    const clonedBoard = board.createClone();\r\n    clonedBoard.moves = createMoveTree(clonedBoard.createSnapshot());\r\n    clonedBoard.pregenerateAttacks();\r\n    const dimension = Math.max(...clonedBoard.data.fenOptions.tag(\"dim\"));\r\n    function traverse(current, currentFullMove = 0, currentTimeOnClocks = createTuple(board.gameData.timeControl.baseTime, totalPlayers)) {\r\n        const moves = [];\r\n        let previousSideToMove = -1;\r\n        for (let i = 0; i < current.length; i++) {\r\n            const moveWrapper = current[i];\r\n            const { moveData, path, alternativeLines } = moveWrapper;\r\n            const newMoveWrapper = createBaseMoveWrapper({ moveData, path: path.slice() }, {\r\n                comment: moveWrapper.comment\r\n            });\r\n            let validationResult;\r\n            try {\r\n                if ((validationResult = validateBoardMove(clonedBoard, moveData) || undefined)) {\r\n                    newMoveWrapper.moveData = moveData;\r\n                }\r\n                else\r\n                    break;\r\n            }\r\n            catch (_) {\r\n                break;\r\n            }\r\n            let firstStandardMoveSet = false;\r\n            for (const moveComponent of moveData) {\r\n                if (verifyStandardMove(moveComponent)) {\r\n                    if (\"promotion\" in moveComponent) {\r\n                        moveComponent.promotion = moveComponent.promotion?.map(p => {\r\n                            if (p.isWall())\r\n                                return p;\r\n                            return createPieceFromData(clonedBoard.data.sideToMove, p.piece);\r\n                        });\r\n                    }\r\n                    if (!firstStandardMoveSet) {\r\n                        newMoveWrapper.metadata.movingPiece =\r\n                            clonedBoard.board[moveComponent.startCoordinates[0]][moveComponent.startCoordinates[1]];\r\n                        firstStandardMoveSet = true;\r\n                    }\r\n                    if (validationResult.hasEnPassant) {\r\n                        moveComponent.specialType = SpecialMove.EnPassant;\r\n                        validationResult.hasEnPassant = false;\r\n                        newMoveWrapper.metadata.isCapture = true;\r\n                    }\r\n                    if (clonedBoard.data.getCapturedPieces(moveComponent).length > 0)\r\n                        newMoveWrapper.metadata.isCapture = true;\r\n                }\r\n            }\r\n            if (i === 0 || findLastIndex(clonedBoard.data.fenOptions.tag(\"dead\"), (b) => !b) === previousSideToMove) {\r\n                newMoveWrapper.metadata.currentFullMove = ++currentFullMove;\r\n            }\r\n            newMoveWrapper.metadata.currentSideToMove = previousSideToMove = clonedBoard.data.sideToMove;\r\n            const results = clonedBoard.makeMove(moveData);\r\n            for (let i = 0; i < totalPlayers; i++) {\r\n                if (results.checkmates[i]) {\r\n                    newMoveWrapper.metadata.checkmates++;\r\n                }\r\n                else if (results.checks[i]) {\r\n                    newMoveWrapper.metadata.checks++;\r\n                }\r\n            }\r\n            for (const line of alternativeLines) {\r\n                newMoveWrapper.alternativeLines.push(traverse(line, currentFullMove, [...currentTimeOnClocks]));\r\n            }\r\n            if (moveWrapper.metadata.playerClock) {\r\n                currentTimeOnClocks[previousSideToMove] -= moveWrapper.metadata.playerClock;\r\n            }\r\n            newMoveWrapper.metadata.playerClock = currentTimeOnClocks[previousSideToMove];\r\n            newMoveWrapper.metadata.highlightedArrows = moveWrapper.metadata.highlightedArrows;\r\n            newMoveWrapper.metadata.highlightedSquares = moveWrapper.metadata.highlightedSquares;\r\n            newMoveWrapper.metadata.annotation = moveWrapper.metadata.annotation;\r\n            const currentMove = clonedBoard.moves.getMove(newMoveWrapper.path);\r\n            assertValidMove(currentMove);\r\n            currentMove.metadata = newMoveWrapper.metadata;\r\n            currentMove.comment = moveWrapper.comment;\r\n            clonedBoard.moves.stringifyMove(currentMove, dimension);\r\n        }\r\n        return moves;\r\n    }\r\n    traverse(moves.moves);\r\n    return clonedBoard.moves;\r\n}\r\nexport function changeGameTermination(board) {\r\n    const currentMove = board.moves.getMove([board.moves.moves.length - 1]);\r\n    const snapshot = board.moves.getBoardSnapshot(verifyValidMove(currentMove) ? currentMove : -1);\r\n    assertNonUndefined(snapshot);\r\n    if (snapshot.boardSnapshot.data.gameOver) {\r\n        board.gameData.termination = snapshot.boardSnapshot.data.gameOver;\r\n        if (board.gameData.result)\r\n            return;\r\n        if (board.isTwoPlayer || board.gameType.type === VariantType.Teams) {\r\n            const currentSnapshot = board.createSnapshot();\r\n            board.loadSnapshot(snapshot.boardSnapshot);\r\n            board.gameData.result = board.data.getCurrentResult();\r\n            board.loadSnapshot(currentSnapshot);\r\n        }\r\n        else {\r\n            const currentResults = [];\r\n            const dead = board.data.fenOptions.tag(\"dead\"), resigned = board.data.fenOptions.tag(\"resigned\"), wb = board.data.fenOptions.tag(\"wb\"), points = snapshot.boardSnapshot.data.points;\r\n            for (const color of colors) {\r\n                if (dead[color] || resigned[color])\r\n                    continue;\r\n                currentResults.push(`${getPlayerNameFromColor(color, wb)}: ${points[color]}`);\r\n            }\r\n            board.gameData.result = currentResults.join(\" – \");\r\n        }\r\n    }\r\n}\r\n"],"names":[],"sourceRoot":""}